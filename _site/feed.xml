<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-02-25T20:26:15+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Gon’s Tech Jurnal</title><subtitle>The Record of Backend Development</subtitle><author><name>Yong gon Yun</name></author><entry><title type="html">GDB 를 사용 기초 및 systemcall GDB 적용</title><link href="http://localhost:4000/gdp01.html" rel="alternate" type="text/html" title="GDB 를 사용 기초 및 systemcall GDB 적용" /><published>2024-02-25T10:32:20+09:00</published><updated>2024-02-25T10:32:20+09:00</updated><id>http://localhost:4000/gdp01</id><content type="html" xml:base="http://localhost:4000/gdp01.html"><![CDATA[<style>
    summary::-webkit-details-marker {
        display: none;
    }
    summary {
        list-style: none;
    }
</style>

<details><summary></summary>
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
</details>

<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) - Rootfs 빌드 강의 내용 (https://comento.kr/)</p>

<h3 id="gdb-기초">GDB 기초</h3>

<ol>
  <li>GDB 사용을 위한 라이브러리 설치</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>gdb-multiarch
</code></pre></div></div>

<ol>
  <li>GDB 로 관찰할 systemcall 작성</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>vi fact.c
</code></pre></div></div>

<ul>
  <li>test 용 code</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">*=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">ret</span> <span class="o">*=</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"result: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>gcc build</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>gcc <span class="nt">-g</span> fact.c <span class="nt">-o</span> fact 
<span class="c"># -g : 컴파일된 실행 파일에 디버깅 정보를 포함</span>
<span class="c"># GDB를 사용할 때 소스 코드의 라인 번호, 변수 이름 등의 상세한 정보에 접근 가능</span>
</code></pre></div></div>

<ol>
  <li>GDB 실행</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>gdb-multiarch fact
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;https://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from fact...
(gdb)
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) start 10          # --- (1)
Temporary breakpoint 1 at 0x11bd: file fact.c, line 14. # --- (2)
Starting program: /home/gon/fact 10     
[Thread debugging using libthread_db enabled]   --- (3)
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1". # --- (4)

Temporary breakpoint 1, main (argc=2, argv=0x7fffffffe108) at fact.c:14
14          int i = atoi(argv[1]);
</code></pre></div></div>
<p>(1) start 명령은 프로그램을 시작하고, 주어진 프로그램의 첫번째 인자(10)와 함께 메인 함수의 첫 번째 라인에서 일시적인 중단점을 설정.  이렇게 하면 프로그램이 실제로 실행되기 시작하며, 사용자가 프로그램의 초기 상태를 검사할 수 있게 된다.</p>

<p>(2) 현재 중단점 code 상 line 의 위치와 메모리 주소. 즉 main 함수 내 첫번째 줄.</p>

<p>(3) 멀티스레딩 프로그램을 디버깅하기 위해 libthread_db 라이브러리를 사용하고 있음을 표시</p>

<p>(4) 호스트 시스템의 libthread_db 라이브러리를 사용하고 있음을 표시. 이 라이브러리는 스레드와 관련된 정보를 제공하여 디버거가 스레드를 효율적으로 관리할 수 있게 돕는다.</p>

<h3 id="systemcall-에-대한-gdb-적용">systemcall 에 대한 GDB 적용</h3>

<ol>
  <li>Debug mode 로 빌드된 Linux kernel 생성을 위한 설정 변경</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">cd </span>kernel
user@DESKTOP:~/kernel<span class="nv">$ ARCH</span><span class="o">=</span>arm64 make menuconfig 
</code></pre></div></div>

<ul>
  <li>kernel hacking -&gt;  Kernel debugging 선택</li>
  <li>kernel hacking -&gt;  Compile-time checks and compiler options -&gt; Debug information (Disable debug information) -&gt;  Rely on the toolchain’s implicit default DWARF version 선택</li>
</ul>

<ol>
  <li>re-build</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/kernel<span class="nv">$ </span> make <span class="nt">-j</span>&lt;cpu 수&gt;
</code></pre></div></div>

<ol>
  <li>QEMU 실행</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/kernel<span class="nv">$ </span><span class="nb">cd</span> ..
user@DESKTOP:~<span class="nv">$ </span>qemu-system-aarch64 <span class="nt">-kernel</span> kernel/arch/arm64/boot/Image <span class="nt">-driv</span>
e <span class="nv">format</span><span class="o">=</span>raw,file<span class="o">=</span>buildroot/output/images/rootfs.ext4,if<span class="o">=</span>virtio <span class="nt">-append</span> <span class="s2">"root=/dev/vda console
=ttyAMA0 nokaslr"</span> <span class="nt">-nographic</span> <span class="nt">-M</span> virt <span class="nt">-cpu</span> cortex-a72 <span class="nt">-m</span> 2G <span class="nt">-smp</span> 2 <span class="nt">-s</span> <span class="nt">-S</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">-s</code> : gdb 가 붙을 수 있도록 1234 포트를 열어둠
<code class="language-plaintext highlighter-rouge">-S</code> : QEMU 가 시작하자마자 멈춰있는 상태로 만듬. (break-point 를 걸수 있는 시점을 마련하기 위함)</p>

<p>(실행시 <code class="language-plaintext highlighter-rouge">-S</code> 옵션으로 인해 멈춰있게 됨. 그래서 다른 cli 상에서 <code class="language-plaintext highlighter-rouge">gdb-multiarch</code>를 사용하여 <code class="language-plaintext highlighter-rouge">linux/vmlinux</code> 경로에 위치한 리눅스 커널 이미지를 디버깅 모드로 염)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>gdb-multiarch kernel/vmlinux
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from kernel/vmlinux...
(gdb)
</code></pre></div></div>

<p>따라서 vmlinux 내 debugging 정보가 읽어지게 됨.</p>

<ol>
  <li>QEUM 가 연 포트에 접근</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) target remote :1234
Remote debugging using :1234
warning: Selected architecture i386:x86-64 is not compatible with reported target architecture aarch64
warning: Architecture rejected target-supplied description
0x0000000000000000 in fixed_percpu_data ()  # bootloader 의 첫 시작 주소
</code></pre></div></div>

<ol>
  <li>break-point 걸기</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">start_kernel</code> 이라는 가장 처음에 시작되는 함수에 break-point 걸기</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) break start_kernel
Breakpoint 1 at 0xffffffff821889e0: file init/main.c, line 875.
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="systemcall" /><category term="gdb-multiarch" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 09]]></summary></entry><entry><title type="html">systemcall 기초 1</title><link href="http://localhost:4000/systemcall01.html" rel="alternate" type="text/html" title="systemcall 기초 1" /><published>2024-02-24T10:32:20+09:00</published><updated>2024-02-24T10:32:20+09:00</updated><id>http://localhost:4000/systemcall01</id><content type="html" xml:base="http://localhost:4000/systemcall01.html"><![CDATA[<style>
    summary::-webkit-details-marker {
        display: none;
    }
    summary {
        list-style: none;
    }
</style>

<details><summary></summary>
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
</details>

<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) - Rootfs 빌드 강의 내용 (https://comento.kr/)</p>

<h4 id="1-syscall_define-매크로">1. SYSCALL_DEFINE 매크로</h4>

<p>1.1 생성할 systemcall 이 추가될 linux kernel 디렉토리 내 해당 source 추가</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">cd </span>kernel/kernel
user@DESKTOP:~/kernel/kernel<span class="nv">$ </span>vim new_syscall.
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="c1"> // kenel 에서 사용할 soruce code 에 필요한 라이브러리</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/syscalls.h&gt;</span><span class="c1"> // SYSCALL_DEFINE 매크로를 사용하기 위한 라이브러리</span><span class="cp">
</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">new_syscall</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span> <span class="c1">// SYSCALL_DEFINE 매크로 + 1개 인자 (system call  이름, (첫번째)인자 타입, (첫번째)인자 이름)</span>
<span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"Hello World~!!!! %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span> <span class="c1">// syscall 호출 확인을 위해 log 출력 \n 로 종료해야 시스템이 해당 로그 message 가 종료 되었음을 인지함. (없으면 종료 상태가 결정되지 않아 원하는 시점에 출력 되지 않을 수 있음.)</span>
    <span class="k">return</span> <span class="n">code</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>1.2 Makefile 수정</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/kernel/kernel<span class="nv">$ </span>vi Makefile
</code></pre></div></div>

<p>해당 파일에 다음과 같이 반드시 실행되는 목적 파일들이 <code class="language-plaintext highlighter-rouge">obj-y</code> 로 나열되어 있다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">obj-y</span>     <span class="o">=</span> fork.o exec_domain.o panic.o <span class="se">\</span>
            cpu.o exit.o softirq.o resource.o <span class="se">\</span>
            sysctl.o capability.o ptrace.o user.o <span class="se">\</span>
            signal.o sys.o umh.o workqueue.o pid.o task_work.o <span class="se">\</span>
            extable.o params.o <span class="se">\</span>
            kthread.o sys_ni.o nsproxy.o <span class="se">\</span>
            notifier.o ksysfs.o cred.o reboot.o <span class="se">\</span>
            async.o range.o smpboot.o ucount.o regset.o ksyms_common.o
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">obj-$(CONFIG명)</code> 항목들의 경우, 관련 CONFIG 설정이 <code class="language-plaintext highlighter-rouge">y</code> 라면 실행되지만, 그렇지 않은 경우 실행되지 않는다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">obj-$(CONFIG_USERMODE_DRIVER)</span> <span class="o">+=</span> usermode_driver.o
<span class="nv">obj-$(CONFIG_MULTIUSER)</span> <span class="o">+=</span> groups.o
<span class="nv">obj-$(CONFIG_VHOST_TASK)</span> <span class="o">+=</span> vhost_task.o
</code></pre></div></div>

<p>해당 항목의 config 값 설정을 보려면 .config 파일에서 찾아 볼 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/kernel/kernel<span class="nv">$ </span>vim ../.config
</code></pre></div></div>

<p>해당 파일을 열어보면, <code class="language-plaintext highlighter-rouge">CONFIG_MULTIUSER=y</code> 만 존재한다.</p>

<p>이것은 곧, <code class="language-plaintext highlighter-rouge">CONFIG_MULTIUSER</code> 의 값은 y 로 <code class="language-plaintext highlighter-rouge">obj-y</code>로 설정, 빌드 및 실행에 적용되나, <code class="language-plaintext highlighter-rouge">CONFIG_USERMODE_DRIVER</code>, <code class="language-plaintext highlighter-rouge">CONFIG_VHOST_TASK</code> 는 존재하지 않으므로, <code class="language-plaintext highlighter-rouge">obj-</code> 상태이므로 kernel build 및 실행 시 영향이 없으므로 삭제하여도 동일한 상태임을 확인할 수 있다.</p>

<p>해당 상태는  menuconfig 화면에서도 확인 가능하다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/kernel/kernel<span class="nv">$ </span><span class="nb">cd</span> ..
user@DESKTOP:~/kernel<span class="nv">$ ARCH</span><span class="o">=</span>arm64 make menuconfig
</code></pre></div></div>
<p>화면에서 <code class="language-plaintext highlighter-rouge">/</code> 를 눌러서 찾게 모드 사용 (vi 와 동일). <code class="language-plaintext highlighter-rouge">CONFIG_MULTIUSER</code> 검색 시.</p>

<center><img src="assets\img\posts\2024-02-24-systemcall011.png" width="600" /></center>

<p>해당 Symbol 설정이 <code class="language-plaintext highlighter-rouge">=y</code> 로 되어 있으나,</p>

<center><img src="assets\img\posts\2024-02-24-systemcall012.png" width="600" /></center>

<p><code class="language-plaintext highlighter-rouge">CONFIG_USERMODE_DRIVER</code> 의 경우 <code class="language-plaintext highlighter-rouge">=n</code> 임을 확인할 수 있다.</p>

<p>위와 같이, <code class="language-plaintext highlighter-rouge">obj-y</code> 를 사용하여 새로 작성한 ‘new__syscall<code class="language-plaintext highlighter-rouge"> 을 </code>Makefile` 에 추가해 준다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CFLAGS_stackleak.o</span> <span class="o">+=</span> <span class="p">$(</span>DISABLE_STACKLEAK_PLUGIN<span class="p">)</span>
<span class="nv">obj-$(CONFIG_GCC_PLUGIN_STACKLEAK)</span> <span class="o">+=</span> stackleak.o
<span class="nv">KASAN_SANITIZE_stackleak.o</span> <span class="o">:=</span> n
<span class="nv">KCSAN_SANITIZE_stackleak.o</span> <span class="o">:=</span> n
<span class="nv">KCOV_INSTRUMENT_stackleak.o</span> <span class="o">:=</span> n

<span class="nv">obj-$(CONFIG_SCF_TORTURE_TEST)</span> <span class="o">+=</span> scftorture.o

<span class="c"># obj- 추가 가장 마지막 항목으로 신규 systemcall 추가
</span><span class="nv">obj-y</span> <span class="o">+=</span> new_syscall.o

<span class="nl">$(obj)/configs.o</span><span class="o">:</span> <span class="nf">$(obj)/config_data.gz</span>

<span class="nv">targets</span> <span class="o">+=</span> config_data config_data.gz
<span class="nl">$(obj)/config_data.gz</span><span class="o">:</span> <span class="nf">$(obj)/config_data FORCE</span>
        <span class="nf">$(</span><span class="nb">call</span> if_changed,gzip<span class="p">)</span>

<span class="nv">filechk_cat</span> <span class="o">=</span> <span class="nb">cat</span> <span class="nv">$&lt;</span>
</code></pre></div></div>

<h4 id="2-커널에-새로운-소스-코드-추가">2. 커널에 새로운 소스 코드 추가</h4>

<p>2.1 systemcall 번호 할당</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/kernel<span class="nv">$ </span>vim include/uapi/asm-generic/unistd.h
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>

<span class="n">__SYSCALL</span><span class="p">(</span><span class="n">__NR_futex_wait</span><span class="p">,</span> <span class="n">sys_futex_wait</span><span class="p">)</span>
<span class="cp">#define __NR_futex_requeue 456
</span><span class="n">__SYSCALL</span><span class="p">(</span><span class="n">__NR_futex_requeue</span><span class="p">,</span> <span class="n">sys_futex_requeue</span><span class="p">)</span>

<span class="cp">#undef __NR_syscalls
#define __NR_syscalls 457 // 기존 마지막 syscall 번호
</span></code></pre></div></div>

<p>457 번 syscall 을 추가하고 마지막 번호를 458 로 변경한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>

<span class="n">__SYSCALL</span><span class="p">(</span><span class="n">__NR_futex_wait</span><span class="p">,</span> <span class="n">sys_futex_wait</span><span class="p">)</span>
<span class="cp">#define __NR_futex_requeue 456
</span><span class="n">__SYSCALL</span><span class="p">(</span><span class="n">__NR_futex_requeue</span><span class="p">,</span> <span class="n">sys_futex_requeue</span><span class="p">)</span>

<span class="cp">#define __NR_new_syscall 457
</span><span class="n">__SYSCALL</span><span class="p">(</span><span class="n">__NR_new_syscall</span><span class="p">,</span> <span class="n">sys_new_syscall</span><span class="p">)</span> <span class="c1">// SYSCALL_DEFINE macro 를 사용함</span>

<span class="cp">#undef __NR_syscalls
#define __NR_syscalls 458
</span></code></pre></div></div>

<p>여기서 사용한 SYSCALL_DEFINE macro 의 내용은  <code class="language-plaintext highlighter-rouge">syscall_wrapper.h</code> 에 포함되어 있으며 architecture 마다 다르므로 아래 경로 파일에서 확인 가능하다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/kernel<span class="nv">$ </span>vi <span class="nb">arch</span>/arm64/include/asm/syscall_wrapper.h
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define COMPAT_SYSCALL_DEFINEx(x, name, ...)                                            \
        asmlinkage long __arm64_compat_sys##name(const struct pt_regs *regs);           \
        ALLOW_ERROR_INJECTION(__arm64_compat_sys##name, ERRNO);                         \
        static long __se_compat_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));              \
        static inline long __do_compat_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));       \
        asmlinkage long __arm64_compat_sys##name(const struct pt_regs *regs)            \
        {                                                                               \
                return __se_compat_sys##name(SC_ARM64_REGS_TO_ARGS(x,__VA_ARGS__));     \
        }                                                                               \
        static long __se_compat_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))               \
        {                                                                               \
                return __do_compat_sys##name(__MAP(x,__SC_DELOUSE,__VA_ARGS__));        \
        }                                                                               \
        static inline long __do_compat_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))
</span></code></pre></div></div>

<h4 id="3-커널에-새로운-시스템콜-추가">3. 커널에 새로운 시스템콜 추가</h4>

<p>3.1 build 진행 (이미지 생성)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/kernel<span class="nv">$ ARCH</span><span class="o">=</span>arm64 <span class="nv">CROSS_COMPILE</span><span class="o">=</span>/home/gon/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu- make <span class="nt">-j16</span>
</code></pre></div></div>

<h4 id="4-새로운-시스템콜을-사용하는-응용프로그램-만들기">4. 새로운 시스템콜을 사용하는 응용프로그램 만들기</h4>

<p>4.1 응용 프로그램 추가</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>vi hello.c
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="c1"> // syscall 함수 포함</span><span class="cp">
</span>
<span class="cp">#define  __NR_new_syscall 462 // 커널 쪽 unistd.h 에는 추가하였으나, toolchaing 측 unistd.h 에는 추가히자 않았으며로 여기에서 명시해줌
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">syscall</span><span class="p">(</span><span class="n">__NR_new_syscall</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"ret : %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>4.2 응용 프로그램 빌드</p>

<p>여기서 빌드될 응용 프로그램은 앞에서 작업한 커널 이미지를 QEMU 를 통해 실행한 환경에서 사용할 것이므로 단순 <code class="language-plaintext highlighter-rouge">gcc</code> 아닌 해당 toolchain 을 사용하여 빌드해야 한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-gcc <span class="nt">-o</span> hello hello.c
</code></pre></div></div>

<p>제대로 빌드되었는지 생서된 실행파일의 정보를 확인한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>file hello
hello: ELF 64-bit LSB executable, ARM aarch64, version 1 <span class="o">(</span>SYSV<span class="o">)</span>, dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, <span class="k">for </span>GNU/Linux 3.7.0, with debug_info, not stripped
</code></pre></div></div>

<p>위와 같이 <code class="language-plaintext highlighter-rouge">ARM aarch64</code> 로 정상적으로 빌드되었음을 확인할 수 있다.</p>

<h4 id="5-새로운-시스템콜-실행하기">5. 새로운 시스템콜 실행하기</h4>

<p>5.1 빌드한 프로그램을 rootfs 이미지 내로 (<code class="language-plaintext highlighter-rouge">/usr/bin</code>) 에 복사하기</p>

<p>해당 작업은 mnt 디렉토리에 mount 하여 사용할 수 있다. 여깃 <code class="language-plaintext highlighter-rouge">/mnt</code> 는 일반적으로 임시적으로 mount 할 공간이 필요할 경우 사용되는 디렉토리이다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">sudo </span>mount <span class="nt">-o</span> loop buildroot/output/images/rootfs.ext4 /mnt
</code></pre></div></div>
<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">-o loop</code> : loop는 이 옵션의 인자로, 일반적인 파일 시스템이 아닌 파일(예: 이미지 파일)을 마운트할 때 사용되는 옵션. loop 장치를 사용하면, 파일을 마치 별도의 물리적 드라이브인 것처럼 마운트할 수 있다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">buildroot/output/images/rootfs.ext4</code> : 리눅스 루트 파일 시스템 중 ext4 파일 시스템 포맷을 사용하는 이미지</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">/mnt</code> : 이는 마운트 포인트를 지정</p>
  </li>
</ul>

<p>이러게 마우트된 파일 시스템에 앞에서 필드한 <code class="language-plaintext highlighter-rouge">hello</code> 를 복사한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">sudo cp </span>hello /mnt/usr/bin
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">sync</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">sync</code> 명령어는 리눅스 및 유닉스 계열 운영 시스템에서 사용되며, 메모리에 버퍼링된 파일 시스템의 쓰기 작업을 디스크에 강제로 동기화하는 역할을 한다. 시스템이 정상적으로 셧다운되기 전이나 중요한 파일 시스템 작업을 수행한 후 데이터의 손실을 방지하기 위해 사용된다.</p>

<p><code class="language-plaintext highlighter-rouge">sync</code> 명령어를 사용하면, 이러한 버퍼링된 모든 쓰기 작업이 완료되고 디스크에 안전하게 저장될 때까지 기다린다. 명령어는 별도의 출력 없이 실행되며, 명령이 완료되면 모든 변경 사항이 디스크에 반영된 상태가 된다.</p>

<p>이렇게 작업이 <code class="language-plaintext highlighter-rouge">hello</code> 실행 파일을 이미지에 추가시킨 후 마우트 해제한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">sudo </span>umount /mnt
</code></pre></div></div>

<p>5.2 QEMU 실행하기</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>qemu-system-aarch64 <span class="nt">-kernel</span> kernel/arch/arm64/boot/Image <span class="nt">-drive</span> <span class="nv">format</span><span class="o">=</span>raw,file<span class="o">=</span>buildroot/output/images/rootfs.ext4,if<span class="o">=</span>virtio <span class="nt">-append</span> <span class="s2">"root=/dev/vda console=ttyAMA0 nokaslr"</span> <span class="nt">-nographic</span> <span class="nt">-M</span> virt <span class="nt">-cpu</span> cortex-a72 <span class="nt">-m</span> 2G <span class="nt">-smp</span> 2
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>
</code></pre></div></div>

<p>5.3 빌드한 프로그램 실행하기</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>
</code></pre></div></div>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="systemcall" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 08]]></summary></entry><entry><title type="html">Buildroot 설치 및 Kernel build</title><link href="http://localhost:4000/buildroot-setting01.html" rel="alternate" type="text/html" title="Buildroot 설치 및 Kernel build" /><published>2024-02-22T10:32:20+09:00</published><updated>2024-02-22T10:32:20+09:00</updated><id>http://localhost:4000/buildroot-setting01</id><content type="html" xml:base="http://localhost:4000/buildroot-setting01.html"><![CDATA[<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) - Rootfs 빌드 강의 내용 (https://comento.kr/)</p>

<h3 id="1-buildroot--다운로드-및-설치">1. buildroot  다운로드 및 설치</h3>

<h3 id="11-buildroot--다운로드">1.1 buildroot  다운로드</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span>git clone git://git.buildroot.net/buildroot
</code></pre></div></div>

<h4 id="12-qemu-설정">1.2 qemu 설정</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span> <span class="nb">sudo </span>apt-get <span class="nb">install </span>libncurses-dev <span class="c"># 필수 라이브러리 설치</span>
root@:~<span class="nv">$ </span><span class="nb">cd </span>buildroot
root@:~/buildroot<span class="nv">$ </span><span class="nb">ls </span>configs  <span class="c"># config 종류 확인</span>
root@:~/buildroot<span class="nv">$ </span>make qemu_aarch64_virt_defconfig
root@:~/buildroot<span class="nv">$ </span>make menuconfig
</code></pre></div></div>

<center><img src="assets\img\posts\2024-02-22-buildroot-setting01.png" width="600" /></center>

<p>다음과 같이 설정을 진행</p>

<ul>
  <li>system configuration -&gt; init system -&gt; systemd 선택</li>
  <li>kernel -&gt; linux kernel  해제</li>
  <li>target packages -&gt; text editors -&gt; vim -&gt; target packages -&gt; libaries -&gt; Crypto -&gt; openssl support 선택 -&gt; openssl binary 도 선택</li>
  <li>Filesystem images -&gt; ext2/3/4 -&gt; ext4 -&gt; exact size -&gt; 128M</li>
  <li>host utilities -&gt; 모두 선택 해제 (해제 불가 항목은 그대로 둠) -&gt; 최종 exit -&gt; 저장</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/buildroot<span class="nv">$ </span><span class="nb">cat</span> /proc/cpuinfo | <span class="nb">grep </span>processor | <span class="nb">wc</span> <span class="nt">-l</span> <span class="c"># cpu 갯수 확인</span>
root@:~/buildroot<span class="nv">$ </span>make <span class="nt">-j</span>&lt;cpu 수&gt;
</code></pre></div></div>

<h4 id="13-에러-처리">1.3 에러 처리</h4>

<p>다만 해당 실행 시 에러가 발생하였는데 관련 내용은 다음과 같다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/buildroot<span class="nv">$ </span>make <span class="nt">-j</span>&lt;cpu 수&gt;
Your PATH contains spaces, TABs, and/or newline <span class="o">(</span><span class="se">\n</span><span class="o">)</span> characters.
This doesn<span class="s1">'t work. Fix you PATH.
make: *** [support/dependencies/dependencies.mk:27: dependencies] Error 1
</span></code></pre></div></div>

<p>이 에러 메시지는 Linux 시스템의 PATH 환경 변수에 공백, 탭(TABs), 또는 줄바꿈 문자(newline, \n)가 포함되어 있어서 발생한 것이다. make와 같은 빌드 시스템에서는 PATH 환경 변수를 사용하여 필요한 실행 파일들을 찾는다. 만약 PATH에 이러한 특수 문자가 포함되어 있다면, 빌드 프로세스가 제대로 실행 파일들을 찾지 못하게 되어 오류가 발생하게 된다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/buildroot<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$PATH</span>
</code></pre></div></div>

<p>이 명령어를 실행하면 PATH에 설정된 디렉토리들이 콜론(:)으로 구분되어 출력된다. 여기서 공백, 탭, 또는 줄바꿈 문자가 있는지 확인해보니 몇 군데 공백이 확인 되었다. 따라서, PATH에서 문제가 되는 문자를 아래와 같이 제거함.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/buildroot<span class="nv">$ </span><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="nv">$PATH</span> | <span class="nb">tr</span> <span class="nt">-d</span> <span class="s1">' \t\n'</span><span class="si">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">echo $PATH</code> 로 제거가 되었는지 확인한 이후, 다시 make 실행에 unzip 이 설치되어 있지 않다고 에러가 발생하여 이를 설치하였다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/buildroot<span class="nv">$ </span><span class="nb">sudo </span>apt-get update
root@:~/buildroot<span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>unzip
</code></pre></div></div>

<h4 id="14-buildroot-설치">1.4 buildroot 설치</h4>

<p>그리고 최종적으로 make 를 실행하여 설치함 (20 여분 소요)</p>

<p>해당 작업을 통해 Buildroot 는 위 설정에 따라 다음의 주요 작업을 진행, embedded system S/W stackt 을 빌드 한다.</p>

<ol>
  <li>
    <p>구성 검증: Buildroot는 .config 파일이나 다른 구성 파일에 정의된 설정을 검증한다. 이 설정은 make menuconfig, make xconfig 또는 make nconfig와 같은 명령어를 통해 사전에 사용자에 의해 정의 것들 이다..</p>
  </li>
  <li>
    <p>툴체인(Toolchain) 빌드 또는 다운로드: 툴체인은 컴파일러, 링커, 라이브러리 등 임베디드 소프트웨어를 컴파일하기 위해 필요한 도구들의 집합이다. Buildroot는 선택된 설정에 따라 적절한 툴체인을 빌드하거나 사전에 빌드된 툴체인을 다운로드한다. 다만 현재의 설정에서 toolchain 빌드는 따로 진행된다.</p>
  </li>
  <li>
    <p>리눅스 커널 빌드: 사용자가 지정한 버전의 리눅스 커널을 다운로드하고, 필요한 패치를 적용한 후 커널을 크로스 컴파일한다. 역시 현재의 설정에서 커널 빌드는 따로 진행된다.</p>
  </li>
  <li>
    <p>루트 파일 시스템(Root Filesystem) 구성: Buildroot는 사용자가 선택한 모든 소프트웨어 패키지를 다운로드하고, 이들을 크로스 컴파일하여 루트 파일 시스템을 구성. 이 과정에는 라이브러리, 시스템 유틸리티, 애플리케이션 등이 포함된다.</p>
  </li>
  <li>
    <p>부트로더(Bootloader) 빌드: 필요한 경우, 선택된 부트로더(예: U-Boot)를 빌드.</p>
  </li>
  <li>
    <p>이미지 생성: 모든 빌드 과정이 완료되면, Buildroot는 이들을 통합하여 임베디드 시스템을 위한 최종 이미지(예: SD 카드 이미지, NAND 플래시 이미지)를 생성한다. 이 이미지는 실제 하드웨어에서 직접 부팅할 수 있다. 3 번과 마찬가지로 현재 설정에서 해당 과정은 별도로 커널 빌드 때 진행된다.</p>
  </li>
</ol>

<h3 id="2-kernel-build-다운로드-및-이미지-생성">2. Kernel Build 다운로드 및 이미지 생성</h3>

<h4 id="21-kernel-download-httpskernelorg">2.1 kernel download (https://kernel.org/)</h4>

<center><img src="assets\img\posts\2024-02-22-buildroot-setting012.png" width="600" /></center>

<p>해당 사이트 git 주소 -&gt; “stable/linux” 검색 해서 나온 kernel/git/stable/linux.git 경로를 git clone 하여 다운 받음.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/buildroot<span class="nv">$ </span><span class="nb">cd</span> ..
root@:~<span class="nv">$ </span>git clone https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/
</code></pre></div></div>
<p>-&gt;  linux 디렉토리에 해당 repository 파일 다운로드 완료</p>

<h4 id="22-kernel-build-에-필요한-라이브러리-설치">2.2 kernel build 에 필요한 라이브러리 설치</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>bison flex libelf-dev libssl-dev
</code></pre></div></div>

<p>(각 라이브러리 들의 기능에 대한 이해는 부족한 상태임. 추가학습 필요)</p>

<ol>
  <li>Bison</li>
</ol>

<ul>
  <li>용도: bison은 GNU 프로젝트의 구문 분석기 생성기로, 커널 소스 코드 내의 구문을 분석하는 데 사용된다. 커널 빌드 과정에서는 특히 커널의 구성 설정 도구인 kconfig에 의해 사용됨.</li>
</ul>

<ol>
  <li>Flex</li>
</ol>

<ul>
  <li>용도: flex는 텍스트 스캔을 위한 패턴 매칭을 수행하는 렉서(lexer) 또는 스캐너(scanner) 생성기. lex의 GNU 버전으로, 텍스트 입력 스트림에서 패턴을 인식하고 처리하는 프로그램을 생성한다. bison과 함께 kconfig에 의해 사용되며, 커널의 설정 옵션을 해석하고 처리하는 데 필요.</li>
</ul>

<ol>
  <li>libelf-dev</li>
</ol>

<ul>
  <li>용도: libelf-dev는 ELF(Executable and Linkable Format) <a href="https://doitnow-man.tistory.com/entry/ELF-1-ELF-%EB%9E%80">(참고 자료 : ELF 란?)</a> 파일을 다루기 위한 개발 라이브러리. ELF 파일 포맷은 리눅스 시스템에서 실행 파일, 오브젝트 코드, 공유 라이브러리, 코어 덤프 등을 위해 사용. 커널 모듈과 같은 ELF 형식의 바이너리 파일을 생성하고 조작하는 데 사용되므로 커널 모듈을 빌드하고 분석하는 데 필수적.</li>
</ul>

<ol>
  <li>libssl-dev</li>
</ol>

<ul>
  <li>용도: libssl-dev는 OpenSSL 라이브러리의 개발 버전 패키지. OpenSSL은 네트워크 연결에 대한 암호화 통신을 제공하는 라이브러리로, SSL(Secure Sockets Layer)과 TLS(Transport Layer Security) 프로토콜을 구현한다. 커널에서는 예를 들어, 보안 통신이 필요한 네트워크 기능을 개발할 때 이 라이브러리가 사용될 수 있다.</li>
</ul>

<h4 id="23-buildroot-에-있는-config-복사-및-config-파일-생성">2.3 buildroot 에 있는 config 복사 및 .config 파일 생성</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/linux<span class="nv">$ </span><span class="nb">cp</span> ../buildroot/board/qemu/aarch64-virt/linux.config <span class="nb">arch</span>/arm64/configs/qemu_defconfig
root@:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 make qemu_defconfig <span class="c"># 반환값으로 .config 생성</span>
</code></pre></div></div>

<h4 id="24-kernel-build-를-위한-toolchain-download-httpsdeveloperarmcom">2.4 kernel build 를 위한 toolchain download (https://developer.arm.com/)</h4>

<p>-&gt; Tools and Software -&gt; Compilers and Libraries -&gt; Arm GNU toolchain -&gt; GNU Toolchain releases for A-profile processors -&gt; GNU-A Downloads (https://developer.arm.com/downloads/-/gnu-a) -&gt; AArch64 GNU/Linux target (aarch64-none-linux-gnu) (gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz) 다운로드</p>

<hr />

<p>(해당 작업을 wsl2 로 설치한 ubuntu 로 진행하는 경우 다운로드 파일은 windows file system) 내부로 들어오게 된다. 이것을 linux 로 복사하기 위해서는 다음과 같이 복사 및 압풀 해제를 진행한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/linux<span class="nv">$ </span><span class="nb">cd</span> ..
root@:~<span class="nv">$ </span><span class="nb">cp</span> /mnt/c/Users/&lt;사용자 이름&gt;/Downloads/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz <span class="nb">.</span>
</code></pre></div></div>
<hr />

<h4 id="25-toolchain-압축-풀기">2.5 toolchain 압축 풀기</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span> <span class="nb">tar </span>xvf gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz
</code></pre></div></div>

<h4 id="26-build-진행-이미지-생성">2.6 build 진행 (이미지 생성)</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span><span class="nb">cd </span>linux
root@:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 <span class="nv">CROSS_COMPILE</span><span class="o">=</span>/home/gon/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu- make <span class="nt">-j16</span>
</code></pre></div></div>
<center><img src="assets\img\posts\2024-02-22-buildroot-setting013.png" width="400" /></center>

<p>build 가 완료되면 위와 같이  vmlinux 를 생성하고 이것을 가지고 arch/arm64/boot/Image 가 생성된것을 확인할 수 있다.</p>

<h3 id="3-buildroot-이미지-실행">3. buildroot 이미지 실행</h3>

<h4 id="31-qemu-설치">3.1 QEMU 설치</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span><span class="nb">sudo </span>apt <span class="nb">install </span>qemu-system-arm
</code></pre></div></div>

<h4 id="32-이미지-실행">3.2 이미지 실행</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span>qemu-system-aarch64 <span class="se">\</span>
<span class="o">&gt;</span> <span class="nt">-kernel</span> linux/arch/arm64/boot/Image <span class="se">\</span>
<span class="o">&gt;</span> <span class="nt">-drive</span> <span class="nv">format</span><span class="o">=</span>raw,file<span class="o">=</span>buildroot/output/images/rootfs.ext4,if<span class="o">=</span>virtio <span class="se">\</span>
<span class="o">&gt;</span> <span class="nt">-append</span> <span class="s2">"root=/dev/vda console=ttyAMA0 nokaslr"</span> <span class="se">\</span>
<span class="o">&gt;</span> <span class="nt">-nographic</span> <span class="nt">-M</span> virt <span class="nt">-cpu</span> cortex-a72 <span class="se">\</span>
<span class="o">&gt;</span> <span class="nt">-m</span> 2G <span class="se">\</span>
<span class="o">&gt;</span> <span class="nt">-smp</span> 2
</code></pre></div></div>

<center><img src="assets\img\posts\2024-02-22-buildroot-setting014.png" width="600" /></center>

<h4 id="33-이미지-종료">3.3 이미지 종료</h4>

<p>터미널 창을 별도로 열어서 kill 명령어로 종료</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">kill</span> <span class="nt">-9</span> qemu-system-aarch64
</code></pre></div></div>

<p>또는 qemu 내에서 shutdown 명령어로 종료</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shutdown <span class="nt">-h</span> now
</code></pre></div></div>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="buildroot" /><category term="kernel build" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 06]]></summary></entry><entry><title type="html">Makefile 기본 문법 01</title><link href="http://localhost:4000/makfile01.html" rel="alternate" type="text/html" title="Makefile 기본 문법 01" /><published>2024-02-21T14:32:20+09:00</published><updated>2024-02-21T14:32:20+09:00</updated><id>http://localhost:4000/makfile01</id><content type="html" xml:base="http://localhost:4000/makfile01.html"><![CDATA[<h3 id="makefile-변수-macro-사용">Makefile 변수 (macro) 사용</h3>

<p>의존성 부분은 일반적으로 매크로로 선언하여 사용함.</p>

<p>매크로를 사용하여 값을 할당할 때, 여러가지 할당 방법이 존재</p>

<h4 id="-recursive-assignment"><code class="language-plaintext highlighter-rouge">=</code> (Recursive Assignment)</h4>
<p><code class="language-plaintext highlighter-rouge">=</code> 연산자는 재귀적 할당을 수행한다. 이는 매크로가 사용될 때마다 평가되어 확장된다. 매크로의 값이 다른 매크로를 참조하는 경우, 참조된 변수의 최종값에 따라 달라진다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">FOO</span> <span class="o">=</span> <span class="p">${</span>BAR<span class="p">}</span>
<span class="nv">BAR</span> <span class="o">=</span> bar_value

<span class="nl">all</span><span class="o">:</span>
        <span class="err">@echo</span> <span class="err">$(FOO)</span>
</code></pre></div></div>

<p>해당 Makefile 을 실행하면 <code class="language-plaintext highlighter-rouge">FOO</code> 매크로는 <code class="language-plaintext highlighter-rouge">BAR</code>의 값을 참조한다. 따라서 실행될 때, <code class="language-plaintext highlighter-rouge">BAR</code> 의 값은 <code class="language-plaintext highlighter-rouge">bar_value</code> 이므로  <code class="language-plaintext highlighter-rouge">bar_value</code> 가 출력된다.</p>

<h4 id="-simle-assignment"><code class="language-plaintext highlighter-rouge">:=</code> (Simle Assignment)</h4>
<p><code class="language-plaintext highlighter-rouge">:=</code> 연산자를 사용한 단순할당의 경우, 매크로에 값이 할당될 때 시점의 값으로 바로 평가, 확장된다. 따라서 이후 참조하고 있는 매크로의 값이 변경되더라도, 최초에 할당된 값을 유지한다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">BAR</span> <span class="o">=</span> bar_value
<span class="nv">FOO</span> <span class="o">:=</span> <span class="p">$(</span>BAR<span class="p">)</span>
<span class="nv">BAR</span> <span class="o">=</span> new_value

<span class="nl">all</span><span class="o">:</span>
        <span class="err">@echo</span> <span class="err">$(FOO)</span>
</code></pre></div></div>

<p>이 경우, <code class="language-plaintext highlighter-rouge">FOO</code> 는 <code class="language-plaintext highlighter-rouge">BAR</code> 의 현재값인 <code class="language-plaintext highlighter-rouge">bar_value</code> 로 초기화 되고, 이후 <code class="language-plaintext highlighter-rouge">BAR</code> 의 값이 변경되더라도 <code class="language-plaintext highlighter-rouge">FOO</code> 의 값은 변하지 않는다. 따라서 해당 Makefile 을 실행하면 출력값은 <code class="language-plaintext highlighter-rouge">bar_value</code> 가 된다.</p>

<h4 id="-append"><code class="language-plaintext highlighter-rouge">+=</code> (Append)</h4>

<p>기존 변수의 값에 값을 추가함. 만약 매크로가 정의되어 있지 않았었다면 해당 매크로를 생성한다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CFLAGS</span> <span class="o">:=</span> <span class="nt">-Wall</span>
<span class="nv">CFLAGS</span> <span class="o">+=</span> <span class="nt">-g</span>   <span class="c"># CFLAGS는 이제 "-Wall -g"</span>
</code></pre></div></div>

<h4 id="-conditional-assignment"><code class="language-plaintext highlighter-rouge">?=</code> (Conditional Assignment)</h4>

<p>매크로가 아직 값이 할당되어 있지 않을 경우에만 값을 할당. 이미 값이 있으면 할당하지 않음.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CC</span> <span class="o">?=</span> gcc <span class="c"># CC가 이전에 정의되지 않았다면 gcc를 사용</span>
</code></pre></div></div>

<h4 id="-target-name"><code class="language-plaintext highlighter-rouge">$@</code> (Target Name)</h4>

<p><code class="language-plaintext highlighter-rouge">$@</code> : 현재 target 의 이름을 명시</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">all</span><span class="o">:</span> <span class="nf">program</span>
<span class="nl">program</span><span class="o">:</span> <span class="nf">program.o</span>
        <span class="err">gcc</span> <span class="err">-o</span> <span class="err">$@</span> <span class="err">$^</span>
</code></pre></div></div>
<p>이 경우 <code class="language-plaintext highlighter-rouge">program: program.o</code> 에서  <code class="language-plaintext highlighter-rouge">program</code> 이 현재 target 이다.  따라서 <code class="language-plaintext highlighter-rouge">$@</code> 는 <code class="language-plaintext highlighter-rouge">program</code> 으로 대체 된다.</p>

<h4 id="-first-dependency"><code class="language-plaintext highlighter-rouge">$&lt;</code> (First Dependency)</h4>

<p><code class="language-plaintext highlighter-rouge">$&lt;</code> 는 규치의 첫 번째 의존성을 나타냄.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">program.o</span><span class="o">:</span> <span class="nf">program.c</span>
        <span class="err">gcc</span> <span class="err">-c</span> <span class="err">$&lt;</span> <span class="err">-o</span> <span class="err">$@</span>
</code></pre></div></div>
<p>여기서  <code class="language-plaintext highlighter-rouge">$&lt;</code> 는 <code class="language-plaintext highlighter-rouge">program.c</code> 을 의미하므로 <code class="language-plaintext highlighter-rouge">gcc -c $&lt; -o $@</code> 는 <code class="language-plaintext highlighter-rouge">gcc -c program.c -o program.o</code> 를 의미한다.</p>

<h4 id="-all-dependencies"><code class="language-plaintext highlighter-rouge">$^</code> (All Dependencies)</h4>

<p>현재 규칙의 모든 의존성 목록을 나타낸다. 중복된 의존성은 제거된다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">program</span><span class="o">:</span> <span class="nf">main.o lib.o util.o</span>
        <span class="err">gcc</span> <span class="err">-o</span> <span class="err">$@</span> <span class="err">$^</span>
</code></pre></div></div>
<p>여기서 <code class="language-plaintext highlighter-rouge">$^</code> 는 <code class="language-plaintext highlighter-rouge">main.o lib.o util.o</code> 을 의미하므로 <code class="language-plaintext highlighter-rouge">gcc -o $@ $^</code> 는 <code class="language-plaintext highlighter-rouge">gcc -o program main.o lib.o util.o</code> 를 의미한다.</p>

<h4 id="확장자-룰-sffix-rule-과-패턴-규칙pattern-rule">확장자 룰 (sffix rule) 과 패턴 규칙(pattern rule)</h4>

<p>Makefile 의 확장자 룰은 오래된 규칙으로, 파일 변환 규칙을 정의하는데 사용됨. 주로 한 종류의 파일을 다른 종류로 변환하는데 사용되며, 확장자만으로 이 변환 과정을 식별한다. <code class="language-plaintext highlighter-rouge">.SUFFIXES</code> 리스트에 정의된 확장자들을 사용하여, 소스파일에서 목적파일로 변환에 사용될 수 있다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">.SUFFIXES</span><span class="o">:</span> <span class="nf">.c .o</span>

<span class="nl">.c.o</span><span class="o">:</span>
        <span class="err">gcc</span> <span class="err">-c</span> <span class="err">$&lt;</span> <span class="err">-o</span> <span class="err">$@</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">.c.o:</code> 은 <code class="language-plaintext highlighter-rouge">.c</code> 파일을 <code class="language-plaintext highlighter-rouge">.o</code> 파일로 변환하는 규칙을 정의한 target 이다. 따라서 <code class="language-plaintext highlighter-rouge">gcc -c $&lt; -o $@</code> 은 첫번째 의존성 <code class="language-plaintext highlighter-rouge">.c</code> 파일을 동일 파일 이름의 <code class="language-plaintext highlighter-rouge">.o</code> 파일로 compile 하라는 의미 이다. <br /></p>

<p>그러나 현대의 Makefile 작성에서는 패턴 규칙을 사용하는 것이 더 권장된다. 확장자 규칙은 유연성과 명확성이 떨어질 수 있으며, GNU Make와 같은 최신 도구에서는 보다 강력하고 유연한 패턴 규칙을 사용할 수 있다. 패턴 규칙은 특정 파일 세트에 대해 적용할 수 있는 규칙을 정의할 때 % 와일드카드를 사용하여 보다 일반적인 규칙을 작성할 수 있게 해준다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">%.o</span><span class="o">:</span> <span class="nf">%.c</span>
        <span class="err">gcc</span> <span class="err">-c</span> <span class="err">$&lt;</span> <span class="err">-o</span> <span class="err">$@</span>
</code></pre></div></div>

<p>이는 앞의 확장자 룰과 동일한 명령을 수행하며, 좀더 명확하고 간결하게 표현된다.</p>

<p>그러나 결론적으로 동일한 파일명의 소스파일에서 목적 파일을 생성하는 룰은 Makefile 에 기본으로 내장되어 있기 때문에 사용자가 정의하는 Makefile 에서는 해당 내용을 생략해도 실행된다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">executable</span><span class="o">:</span> <span class="nf">distance.o main.o</span>
        <span class="err">ld</span> <span class="err">-o</span> <span class="err">executable</span> <span class="err">*.o</span> <span class="err">/usr/lib/x86_64-linux-gnu/crt1.o</span> <span class="err">-lm</span> <span class="err">-lc</span> <span class="nv">-dynamic-linker</span><span class="o">=</span>/lib64/ld-linux-x86-64.so.2

<span class="nl">distance.o </span><span class="o">:</span> <span class="nf">distance.c</span>
        <span class="err">gcc</span> <span class="err">-c</span> <span class="err">-o</span> <span class="err">distance.o</span> <span class="err">distance.c</span>

<span class="nl">main.o </span><span class="o">:</span> <span class="nf">main.c</span>
        <span class="err">gcc</span> <span class="err">-c</span> <span class="err">-o</span> <span class="err">main.o</span> <span class="err">main.c</span>
</code></pre></div></div>
<p>위 내용은 아래와 같이 명시적으로 작성하지 않아도,</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">executable</span><span class="o">:</span> <span class="nf">distance.o main.o</span>
        <span class="err">ld</span> <span class="err">-o</span> <span class="err">executable</span> <span class="err">*.o</span> <span class="err">/usr/lib/x86_64-linux-gnu/crt1.o</span> <span class="err">-lm</span> <span class="err">-lc</span> <span class="nv">-dynamic-linker</span><span class="o">=</span>/lib64/ld-linux-x86-64.so.2
</code></pre></div></div>
<p>최종 실행 파일 생성만 구현하고 <code class="language-plaintext highlighter-rouge">make</code>를 실행해도 이전과 동일하게 각 소스코드에서 목적파일이 생성되고 최종적으로 실행파일이 생성된다. 또한 점진적 빌드 (Incremental build) 도 정상적으로 동작한다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nl">buildroot_download</span><span class="o">:</span> 
        

</code></pre></div></div>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="bash" /><category term="makefile" /><category term="incremental build" /><category term="suffix rule" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 05]]></summary></entry><entry><title type="html">Shell Script 사용한 시스템 구축 01 (사용자 계정 생성)</title><link href="http://localhost:4000/shell-script04-systemsetting01-copy.html" rel="alternate" type="text/html" title="Shell Script 사용한 시스템 구축 01 (사용자 계정 생성)" /><published>2024-02-20T14:32:20+09:00</published><updated>2024-02-20T14:32:20+09:00</updated><id>http://localhost:4000/shell-script04-systemsetting01%20copy</id><content type="html" xml:base="http://localhost:4000/shell-script04-systemsetting01-copy.html"><![CDATA[<p>참고 자료 : <a href="https://product.kyobobook.co.kr/detail/S000001810353">처음 배우는 셸 스크립트 8장 시스템 구축</a></p>

<p>shell script 를 사용하여 사용자 개정을 생성하는 파일을 작성 및 실행</p>

<p>프로세스</p>
<ol>
  <li>사용자 계정과 패스워드 입력</li>
  <li>입력 정보가 없으면 에러 메세지를 보여주고, script 종료</li>
  <li>여러명의 사용자 계정을 생성할 경우 반복문을 사용하여 순회</li>
  <li>각 계정이 이미 사용자 계정에 포함되어 있는지 확인</li>
  <li>포함되어있지 않다면, 계정을 생성하고 패스워드 설정</li>
  <li>이미 존재하는 계정이라면, 이를 메세지로 보여줌.</li>
</ol>

<h3 id="1-다수의-사용자-계정-생성">1. 다수의 사용자 계정 생성</h3>

<p>(1) <code class="language-plaintext highlighter-rouge">if [[ -n $1 ]] &amp;&amp; [[ -n $2 ]]</code>
<br />해당 script 실행시 매개 변수로 사용자 계정(<code class="language-plaintext highlighter-rouge">$1</code>)과 패스워드(<code class="language-plaintext highlighter-rouge">$2</code>)가 모두 입력 되었는지 확인(<code class="language-plaintext highlighter-rouge">-n</code> : 비워있지 않아야 함) 한다. <code class="language-plaintext highlighter-rouge">$1</code> 과 <code class="language-plaintext highlighter-rouge">$2</code> 모두 외부 입력값이므로 이중 중괄호 <code class="language-plaintext highlighter-rouge">[[]]</code> 를 사용한다.
<br /></p>

<p>(2) <code class="language-plaintext highlighter-rouge">IFS=' ' read -r -a UserList &lt;&lt;&lt; "$1"</code> <br />
입력된 매개변수 값을 공백을 기준으로 값을 slice 하여 배열의 형태로 shell script 변수로 저장함.<br /></p>
<ul>
  <li>IFS (Internal Field Separator) : IFS 는 shell scirpt 에서 사용하는 내부 필드 구분자. 이 변수는 문자열을 분리하여 배열이나 개별 변수로 읽을 때 사용하는 구분자을 정의한다. 기본값은 공백, 탭, 개행 문자.</li>
  <li><code class="language-plaintext highlighter-rouge">read</code> : 표준 입력이나 파일로부터 입력을 읽어드림. 이 명령어를 사용하여 변수에 값을 할당할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">-r</code> : <code class="language-plaintext highlighter-rouge">read</code> 옵션 중 백슬래시(<code class="language-plaintext highlighter-rouge">\</code>) 가 이스케이프 문자로 처리되지 않고, 그대로 읽어드림.</li>
  <li><code class="language-plaintext highlighter-rouge">-a</code> : <code class="language-plaintext highlighter-rouge">read</code> 명령어에 의히 읽힌 값을 배열로 저장.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;&lt;&lt;</code> (Here String) :  “$1” 로 받은 외부 입력 값을 UserList 변수 값으로 취할 수 있도록 redirection 해줌. 
<br /></li>
</ul>

<p>(3) <code class="language-plaintext highlighter-rouge">for (( i=0 ; i &lt; ${#UserList[@]}; i++ ))</code> <br />
배열 <code class="language-plaintext highlighter-rouge">UserList</code> 의 길이만큼 반복할 수 있도록 설정
<br /></p>

<p>(4) <code class="language-plaintext highlighter-rouge">if [[ $(cat /etc/passwd | grep -w ${UserList[$i]} | wc -l) == 0 ]] </code><br /></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">$(cat /etc/passwd</code> 파일의 내용을 가져와서,</li>
  <li><code class="language-plaintext highlighter-rouge">UserList[$i]</code> 의 값과 정확히 (<code class="language-plaintext highlighter-rouge">-w</code>)일치하는 사용자 계정을 찾고,</li>
  <li><code class="language-plaintext highlighter-rouge">wc</code> (word count) 의 라인 수(<code class="language-plaintext highlighter-rouge">-l</code>) 을 출력,</li>
  <li>해당 값이 0 아니라면, 동일 계정이 존재한다는 것을 의미함.
<br /></li>
</ul>

<p>(5) <code class="language-plaintext highlighter-rouge">useradd ${UserList[$i]}</code> <br />
기존 계정이 존재하지 않는 경우, 해당 값 <code class="language-plaintext highlighter-rouge">${UserList{$i}}</code> 의 계정을 생성함. 
<br /></p>

<p>(6) <code class="language-plaintext highlighter-rouge">echo "${UserList[$i]}:${Password[$i]}" | chpasswd</code> <br />
새로 생성한 계정에 대한 패스워드 값을 사용하여 패스워드를 설정
<br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c"># 사용자 계정 및 패스워드가 입력되었는지 확인</span>
<span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="nv">$1</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="nv">$2</span> <span class="o">]]</span> <span class="c">#  (1)</span>
<span class="k">then

        </span><span class="nv">IFS</span><span class="o">=</span><span class="s1">' '</span> <span class="nb">read</span> <span class="nt">-r</span> <span class="nt">-a</span> UserList <span class="o">&lt;&lt;&lt;</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="c">#  (2)</span>
        <span class="nv">IFS</span><span class="o">=</span><span class="s1">' '</span> <span class="nb">read</span> <span class="nt">-r</span> <span class="nt">-a</span> Password <span class="o">&lt;&lt;&lt;</span> <span class="s2">"</span><span class="nv">$2</span><span class="s2">"</span>

        <span class="c"># for 문을 이용하여 사용자 계정 생성</span>
        <span class="k">for</span> <span class="o">((</span> <span class="nv">i</span><span class="o">=</span>0 <span class="p">;</span> i &lt; <span class="k">${#</span><span class="nv">UserList</span><span class="p">[@]</span><span class="k">}</span><span class="p">;</span> i++ <span class="o">))</span> <span class="c">#  (3)</span>
        <span class="k">do</span>
                <span class="c"># if문을 사용하여 사용자 계정이 있는지 확인</span>
                <span class="k">if</span> <span class="o">[[</span> <span class="si">$(</span><span class="nb">cat</span> /etc/passwd | <span class="nb">grep</span> <span class="nt">-w</span> <span class="k">${</span><span class="nv">UserList</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span> | <span class="nb">wc</span> <span class="nt">-l</span><span class="si">)</span> <span class="o">==</span> 0 <span class="o">]]</span> <span class="c">#  (4)</span>
                <span class="k">then</span>
                        <span class="c"># 사용자 생성 및 패스워드 설정</span>
                        useradd <span class="k">${</span><span class="nv">UserList</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span> <span class="c">#  (5)</span>
                        <span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">UserList</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span><span class="s2">:</span><span class="k">${</span><span class="nv">Password</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span><span class="s2">"</span> | chpasswd <span class="c">#  (6)</span>
                <span class="k">else</span>
                        <span class="c"># 사용자가 있다고 메세지를 보여줌</span>
                        <span class="nb">echo</span> <span class="s2">"this user </span><span class="k">${</span><span class="nv">UserList</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span><span class="s2"> is existing."</span>
                <span class="k">fi
        done

else</span>
        <span class="c"># 사용자가 계정과 패스워드를 입력하라는 메세지를 보여줌</span>
        <span class="nb">echo</span> <span class="nt">-e</span> <span class="s1">'Please input user id and password. \nUsage: adduser-script.sh "user01 user02" "pw01 pw02"'</span>
<span class="k">fi</span>
</code></pre></div></div>
<p>해당 script 를  <code class="language-plaintext highlighter-rouge">adduser-script.sh</code> 에 저장하고 아래와 같이 실행</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gon@DESKTOP:~/book/ch08<span class="nv">$ </span><span class="nb">sudo </span>bash adduser-script.sh <span class="s2">"user1 user2"</span> <span class="s2">"1111 2222"</span>
</code></pre></div></div>
<p>여기에서 <code class="language-plaintext highlighter-rouge">sh</code> 가 아닌 <code class="language-plaintext highlighter-rouge">bash</code> 명령어를 사용한 이유는, 일부 리눅스 (ex. Ubuntu) shell 이 <code class="language-plaintext highlighter-rouge">bash</code> 가 아닌 <code class="language-plaintext highlighter-rouge">dash</code> 에서 실행되는 경우가 있다. 이런 경우, <code class="language-plaintext highlighter-rouge">dash</code> 에서 지원되지 않는 기능 (ex. redirection <code class="language-plaintext highlighter-rouge">&lt;&lt;&lt;</code>)을 shell script 내 사용한 경우, 다음과 같은 에러가 발생한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gon@DESKTOP:~/book/ch08<span class="nv">$ </span><span class="nb">sudo </span>sh adduser-script.sh <span class="s2">"user1 user2"</span> <span class="s2">"1111 2222"</span>
adduser-script.sh: 7: Syntax error: redirection unexpected
</code></pre></div></div>

<p>이를 해결하는 다른 방법으로, 해당 파일의 실행 권한을 아예 변경하고, 직접 실행 시키면 된다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gon@DESKTOP:~/book/ch08<span class="nv">$ </span><span class="nb">chmod</span> +x adduser-script.sh
gon@DESKTOP:~/book/ch08<span class="nv">$ </span>./adduser-script.sh <span class="s2">"user1 user2"</span> <span class="s2">"1111 2222"</span>
</code></pre></div></div>

<p>최종적으로, 해당 실행이 정상적으로 동작했는지를 위해 <code class="language-plaintext highlighter-rouge">/etc/passwd</code> 파일 내용을 확인하면 아래 해당 user 가 추가된 것을 확인할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gon@DESKTOP:~/book/ch08<span class="nv">$ </span><span class="nb">cat</span> /etc/passwd

...
user1:x:1001:1001::/home/user1:/bin/sh
user2:x:1002:1002::/home/user2:/bin/sh
</code></pre></div></div>

<h3 id="2-ssh--를-활용하여-다른-서버에-사용자-계정-생성">2. ssh  를 활용하여 다른 서버에 사용자 계정 생성</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="k">for </span>server <span class="k">in</span> <span class="s2">"host01 host02 host03"</span>
<span class="k">do</span>
        <span class="c"># 여러 대의 시스템에 사용자 생성 및 패스워드 설정</span>
        <span class="nb">echo</span> <span class="nv">$server</span>
        ssh root@<span class="nv">$server</span> <span class="s2">"useradd </span><span class="nv">$1</span><span class="s2">"</span>  <span class="c"># (1)</span>
        ssh root@<span class="nv">$server</span> <span class="s2">"echo </span><span class="nv">$2</span><span class="s2">:</span><span class="nv">$1</span><span class="s2"> | chpasswd"</span> 
<span class="k">done</span>
</code></pre></div></div>

<p>(1) <code class="language-plaintext highlighter-rouge">ssh root@$server "useradd $1"</code></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ssh</code> : SSH protocol 을 사용하여 원격 서버에 접속하가나 원격 서버에서 명령을 실행하기 위한 client 프로그램</li>
  <li><code class="language-plaintext highlighter-rouge">root@$server</code> : <code class="language-plaintext highlighter-rouge">사용자명@호스트명</code> 형식으로 접속할 원격 서버의 최고 관리자 계정을 의미</li>
  <li><code class="language-plaintext highlighter-rouge">"useradd $1"</code> : ssh root 계정으로 해당 host 에 접속하여 사용자 계정 추가를 실행</li>
</ul>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="bash" /><category term="shell scirpt" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 04]]></summary></entry><entry><title type="html">Shell Script 기본 문법 03 (큰따옴표 작은 따음표)</title><link href="http://localhost:4000/shell-script03-quates.html" rel="alternate" type="text/html" title="Shell Script 기본 문법 03 (큰따옴표 작은 따음표)" /><published>2024-02-10T12:32:20+09:00</published><updated>2024-02-10T12:32:20+09:00</updated><id>http://localhost:4000/shell-script03-quates</id><content type="html" xml:base="http://localhost:4000/shell-script03-quates.html"><![CDATA[<p>Bash 스크립트에서 큰따옴표(““)와 작은따옴표(‘‘)는 문자열을 묶는 데 사용되지만, 그들이 처리하는 방식에는 중요한 차이가 있다.</p>

<h3 id="큰따옴표">큰따옴표(“”)</h3>

<ol>
  <li>
    <p>변수 확장(Expansion)<br />
  큰따옴표 안에 있는 변수는 그 값으로 확장됨. 예를 들어, “$VARIABLE”은 VARIABLE의 값을 나타냄.</p>
  </li>
  <li>
    <p>명령어 치환(Command Substitution)<br />
  큰따옴표 안에서 명령어 치환. 예를 들어, “$(date)”는 현재 날짜와 시간으로 치환됨.</p>
  </li>
  <li>
    <p>공백과 특수 문자<br /> 
  큰따옴표 안의 공백, 탭 등은 문자열의 일부로 유지됨. 이는 여러 단어나 공백을 포함하는 문자열을 하나의 인자나 값으로 처리해야 할 때 유용.</p>
  </li>
</ol>

<h3 id="작은따옴표">작은따옴표(‘’)</h3>

<ol>
  <li>
    <p>문자 그대로의 값<br /> 
  작은따옴표 안의 모든 문자는 그대로의 값으로 처리됨. 변수 확장이나 명령어 치환 같은 것은 일어나지 않는다. 예를 들어, ‘$VARIABLE’은 표기된 문자열 “$VARIABLE” 그 자체를 의미.</p>
  </li>
  <li>
    <p>공백과 특수 문자<br /> 
  작은따옴표 안의 공백과 특수 문자도 문자열의 일부로 유지되며, 이 역시 여러 단어나 공백을 포함하는 문자열을 하나의 인자나 값으로 처리하고자 할 때 유용.</p>
  </li>
</ol>

<h3 id="사용-예시">사용 예시</h3>

<ol>
  <li>
    <p>변수 확장이 필요한 경우<br /> 
  “Hello, $USER” (USER 변수에 해당하는 사용자 이름으로 확장.)</p>
  </li>
  <li>
    <p>명령어 치환을 사용하는 경우<br /> 
  “Today is $(date)” (현재 날짜로 치환.)</p>
  </li>
  <li>
    <p>문자 그대로의 값이 필요한 경우<br /> 
  ‘Data $5 not processed’ (문자열이 그대로 출력, 변수 확장이나 치환 없이.)</p>
  </li>
</ol>

<h3 id="결론">결론</h3>

<p>각각의 사용법은 스크립트에서 변수의 값이나 명령어의 결과를 어떻게 처리할지에 따라 달라진다. 문자열 내에서 변수의 값을 그대로 사용하고 싶지 않거나, 특수 문자를 명령어의 일부로 해석되지 않게 하고 싶을 때 작은따옴표를 사용한다. 반면, 변수의 값을 확장하거나 명령어의 결과를 사용하고자 할 때는 큰따옴표를 사용한다.</p>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="bash" /><category term="shell scirpt" /><category term="quates" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 03]]></summary></entry><entry><title type="html">Shell Script 기본 문법 02 (types)</title><link href="http://localhost:4000/shell-script02-types-copy.html" rel="alternate" type="text/html" title="Shell Script 기본 문법 02 (types)" /><published>2024-02-10T08:32:20+09:00</published><updated>2024-02-10T08:32:20+09:00</updated><id>http://localhost:4000/shell-script02-types%20copy</id><content type="html" xml:base="http://localhost:4000/shell-script02-types-copy.html"><![CDATA[<p>Bash Shell Script에서는 다른 프로그래밍 언어들처럼 명시적인 데이터 타입 선언을 사용하지 않는다. Bash는 기본적으로 모든 변수를 문자열로 처리하지만, Bash 스크립트 내에서 다양한 형태의 데이터를 다룰 수 있으며, 이를 위해 특정 명령어나 구문을 사용하여 숫자, 문자열, 배열 등과 같은 다양한 “형태”의 데이터를 다루게 된다. 아래는 Bash에서 사용될 수 있는 주요 “데이터 타입”의 개념과 예시이다.</p>

<h3 id="문자열-string">문자열 (String)</h3>
<p>Bash에서 가장 기본적이고 자주 사용되는 데이터 타입. 변수에 값을 할당할 때 따옴표를 사용하지 않거나, 단일 따옴표(‘)나 이중 따옴표(“)를 사용하여 문자열을 할당.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">name</span><span class="o">=</span><span class="s2">"John Doe"</span>
<span class="nv">greeting</span><span class="o">=</span><span class="s1">'Hello, World!'</span>
</code></pre></div></div>

<h3 id="정수integer">정수(Integer)</h3>
<p>Bash에서는 declare -i 명령어를 사용하여 변수를 정수로 선언할 수 있다. 또한, 산술 연산에서 Bash는 변수를 자동으로 정수로 취급</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">declare</span> <span class="nt">-i</span> number
<span class="nv">number</span><span class="o">=</span>10
<span class="nb">echo</span> <span class="k">$((</span>number <span class="o">+</span> <span class="m">5</span><span class="k">))</span>  <span class="c"># 15 출력</span>
</code></pre></div></div>

<h3 id="배열array">배열(Array)</h3>
<p>Bash에서 배열은 여러 값을 저장할 수 있는 데이터 구조. 배열은 0부터 시작하는 인덱스를 가지며, ()를 사용하여 배열을 선언.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">arr</span><span class="o">=(</span>1 2 <span class="s2">"hello"</span> <span class="s2">"world"</span><span class="o">)</span>
<span class="nb">echo</span> <span class="k">${</span><span class="nv">arr</span><span class="p">[0]</span><span class="k">}</span>  <span class="c"># 1 출력</span>
<span class="nb">echo</span> <span class="k">${</span><span class="nv">arr</span><span class="p">[3]</span><span class="k">}</span>  <span class="c"># world 출력</span>
</code></pre></div></div>

<ul>
  <li>Bash 배열과 다른 프로그래밍 언어 배열 (ex. C)과 다른점 <br /></li>
</ul>

<ol>
  <li>
    <p>index &amp; mata-data <br />
Bash 배열의 구현은 C 배열과 달리 고수준에서 이루어지기 때문에, 원소가 저장된 메모리에 대한 접근 방법 등을 고려할 필요가 없다.  Bash 배열은 각 원소애 대한 index 와 mata-data 를 내부적으로 유지하며, 여기에 원소의 위치, 길이 등이 포함될 수 있다. <br /></p>
  </li>
  <li>
    <p>동적 할당과 관리<br />
Bash는 필요에 따라 동적으로 메모리를 할당하고, 배열의 원소를 관리한다. 사용자가 배열에 원소를 추가하거나 제거할 때, Bash는 내부적으로 이러한 변경을 처리하고, 배열의 각 원소가 올바르게 접근될 수 있도록 한다.</p>
  </li>
  <li>
    <p>추상화된 접근 방식<br />
사용자가 배열의 원소에 접근할 때, Bash는 추상화된 인터페이스(예: 인덱스를 사용-한 접근)를 제공ㄹ. 사용자는 인덱스를 통해 간단하게 원소에 접근할 수 있으며, Bash가 원소의 실제 메모리 위치와 경계를 관리한다.<br /></p>
  </li>
</ol>

<h3 id="연관-배열associative-arrays">연관 배열(Associative Arrays)</h3>
<p>ash 4 이상에서는 연관 배열(키-값 쌍을 저장하는 배열)을 사용할 수 있음. declare -A를 사용하여 연관 배열을 선언.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">declare</span> <span class="nt">-A</span> fruits
fruits[apple]<span class="o">=</span><span class="s2">"red"</span>
fruits[banana]<span class="o">=</span><span class="s2">"yellow"</span>
<span class="nb">echo</span> <span class="k">${</span><span class="nv">fruits</span><span class="p">[apple]</span><span class="k">}</span>  <span class="c"># red 출력</span>
</code></pre></div></div>

<h3 id="부동-소수점floating-point-numbers">부동 소수점(Floating Point Numbers)</h3>
<p>Bash 자체는 부동 소수점 수를 직접 지원하지 않는다. 부동 소수점 연산을 수행하려면 bc나 awk와 같은 외부 도구를 사용해야 함.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">result</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="s2">"3.5 + 4.2"</span> | bc<span class="si">)</span>
<span class="nb">echo</span> <span class="nv">$result</span>  <span class="c"># 7.7 출력</span>
</code></pre></div></div>

<h3 id="환경-변수environment-variables">환경 변수(Environment Variables)</h3>
<p>환경 변수는 운영 체제의 환경 설정을 포함하는 전역 변수. Bash 스크립트에서는 이러한 환경 변수를 읽고 설정할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="nv">$PATH</span>
<span class="nb">export </span><span class="nv">MY_VAR</span><span class="o">=</span><span class="s2">"SomeValue"</span>
</code></pre></div></div>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="bash" /><category term="shell scirpt" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 02]]></summary></entry><entry><title type="html">Shell Script 기본 문법 01</title><link href="http://localhost:4000/shell-script01.html" rel="alternate" type="text/html" title="Shell Script 기본 문법 01" /><published>2024-02-10T08:32:20+09:00</published><updated>2024-02-10T08:32:20+09:00</updated><id>http://localhost:4000/shell-script01</id><content type="html" xml:base="http://localhost:4000/shell-script01.html"><![CDATA[<h3 id="1-간단한-함수를-사용한-script-1">1. 간단한 함수를 사용한 script 1</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c"># 함수 정의: 두 인자를 받아 출력함</span>
add_inner_numbers<span class="o">()</span> <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">"첫 번째 숫자: </span><span class="nv">$1</span><span class="s2">"</span>
    <span class="nb">echo</span> <span class="s2">"두 번째 숫자: </span><span class="nv">$2</span><span class="s2">"</span>
    
    <span class="nb">local sum</span><span class="o">=</span>0
    <span class="nb">sum</span><span class="o">=</span><span class="k">$((</span> <span class="nv">$1</span> <span class="o">+</span> <span class="nv">$2</span> <span class="k">))</span>
    <span class="nb">echo</span> <span class="s2">"두 수의 합: </span><span class="nv">$sum</span><span class="s2">"</span>
<span class="o">}</span>

<span class="c"># 함수 호출: 5와 10을 인자로 전달</span>
add_inner_numbers 5 10
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">#!/bin/bash</code>
    <ul>
      <li>“shebang” (또는 “hashbang”)</li>
      <li>해당 script를 실행할 때 사용할 interpreter 의 경로를 진행</li>
      <li>여기서는 Bash shell 을 사용하여 실행되어야 함을 의미</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">subtract_num() {}</code></li>
  <li>
    <p>script 함수를 정의할 때, 매개변수는 명시하지 않는다. 함수 내 $1, $2, $3 … 과 같이 함수 내부에 명시된 value 의 숫자값에 순서대로 매칭되어 입력된다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">sum=$(( $1 + $2 ))</code>
    <ul>
      <li>첫번째 괄호는 $() 로 연산 결과를 값으로 취함을 의미</li>
      <li>두번째 괄호는 연산에 대한 괄호</li>
      <li>띄어쓰기는 여기서는 결과에 영향을 미치지는 않지만 일반적인 작성 기준을 따름.</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>실행 결과</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@DESKTOP:~<span class="nv">$ </span>./example.sh
첫 번째 숫자: 5
두 번째 숫자: 10
두 수의 합: 15
</code></pre></div></div>

<h3 id="2-간단한-함수를-사용한-script-2-외부-입력">2. 간단한 함수를 사용한 script 2 (외부 입력)</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c">#  두수를 빼는  함수 정의</span>
subtract_num<span class="o">()</span> <span class="o">{</span>
        <span class="nb">local </span><span class="nv">sub</span><span class="o">=</span>0
        <span class="nv">sub</span><span class="o">=</span><span class="k">$((</span> <span class="nv">$2</span> <span class="o">-</span> <span class="nv">$1</span> <span class="k">))</span>
        <span class="nb">echo</span> <span class="s2">"두 수의 차: </span><span class="nv">$sub</span><span class="s2">"</span>
<span class="o">}</span>

<span class="c"># 사용자로부터 두수 입력 받기</span>
<span class="nb">read</span> <span class="nt">-p</span> <span class="s2">"첫번째 수를 입력하세요: "</span> num1
<span class="nb">read</span> <span class="nt">-p</span> <span class="s2">"두번째 수를 입력하세요: "</span> num2

<span class="c"># 함수 호출</span>
subtract_num <span class="nv">$num1</span> <span class="nv">$num2</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">read -p "첫번째 수를 입력하세요: " num1</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">read</code> 명령어로 표준입력 값을 받을 수 있다.</li>
      <li><code class="language-plaintext highlighter-rouge">-p</code> 옵션으로 <code class="language-plaintext highlighter-rouge">echo</code> 명령어를 사용하지 않고 프롬프트 메세지를 보여줄 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>실행 결과</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@DESKTOP:~<span class="nv">$ </span>./example.sh
첫번째 수를 입력하세요: 2
두번째 수를 입력하세요: <span class="nt">-5</span>
두 수의 차: <span class="nt">-7</span>
</code></pre></div></div>

<h3 id="3-간단한-함수를-사용한-script-3-외부-입력-조건문">3. 간단한 함수를 사용한 script 3 (외부 입력, 조건문)</h3>

<p>외부 입력을 함수의 실행과 함께 받도록 아래와 같이 구현할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c">#  두수를 빼는  함수 정의</span>
subtract_num<span class="o">()</span> <span class="o">{</span>
        <span class="nb">local </span><span class="nv">sub</span><span class="o">=</span>0
        <span class="nv">sub</span><span class="o">=</span><span class="k">$((</span> <span class="nv">$2</span> <span class="o">-</span> <span class="nv">$1</span> <span class="k">))</span>
        <span class="nb">echo</span> <span class="s2">"두 수의 차: </span><span class="nv">$sub</span><span class="s2">"</span>
<span class="o">}</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$# </span><span class="nt">-ne</span> 2 <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"사용방법: </span><span class="nv">$0</span><span class="s2"> 숫자1 숫자2"</span>
        <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># 함수 호출</span>
subtract_num <span class="nv">$1</span> <span class="nv">$2</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">if [ $# -ne 2 ]; then ... fi</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">[];</code> 내 조건이 참일 경우, <code class="language-plaintext highlighter-rouge">then ... fi</code> 내 명령어를 실행</li>
      <li><code class="language-plaintext highlighter-rouge">if</code>, <code class="language-plaintext highlighter-rouge">[];</code>, <code class="language-plaintext highlighter-rouge">then</code> 사이에는 띄어쓰기를 반드시 해야 함.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">$# -ne 2</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">$#</code> 은 script 에 전달된 positional parameter 의 갯수. 위 예제의 경우, <code class="language-plaintext highlighter-rouge">./example.sh 1 2</code> 와 같이 실행되는데, 이 때 <code class="language-plaintext highlighter-rouge">$#</code> 값은 2 이다.</li>
      <li><code class="language-plaintext highlighter-rouge">-ne</code> 은 “not equal”  의 약자로, 두 값이 서로 다른지를 비교</li>
      <li><code class="language-plaintext highlighter-rouge">2</code> 는 비교 대상의 값</li>
      <li>즉 해당 script 부분은 “입력된 positional parameter 갯수가 2개가 아니라면” 이라는 조건을 정의함.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">echo "..." exit 1</code>
    <ul>
      <li>해당 조건일 때, 메세지를 출력하고 에러 상태로 script 를 종료</li>
      <li><code class="language-plaintext highlighter-rouge">exit 0</code> 인 경우, 정상적으로 작업이 성공되고 종료됨을 의미, 0 이 아닌 경우는, 에러나 특정 조건으로 인한 종료를 의미</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>실행 결과</li>
</ul>

<p>매개변수를 입력하지 않은 경우</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@DESKTOP~<span class="nv">$ </span>./example.sh
사용방법: ./example.sh 숫자1 숫자2
</code></pre></div></div>

<p>매개변수 값을 함께 입력한 경우</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@DESKTOP:~<span class="nv">$ </span>./example.sh 3 3
두 수의 차: 0
</code></pre></div></div>

<h3 id="4-파일-입력--반복문을-이용-script">4. 파일 입력 &amp; 반복문을 이용 script</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c"># 'list' 파일을 읽어와 line 변수에 저장</span>
<span class="k">while </span><span class="nb">read</span> <span class="nt">-r</span> line<span class="p">;</span> <span class="k">do</span>
    <span class="c"># 공백으로 구분된 값을 배열로 변환</span>
    <span class="nv">IFS</span><span class="o">=</span><span class="s1">' '</span> <span class="nb">read</span> <span class="nt">-ra</span> ADDR <span class="o">&lt;&lt;&lt;</span> <span class="s2">"</span><span class="nv">$line</span><span class="s2">"</span>
    <span class="c"># 배열의 각 요소를 반복하여 출력</span>
    <span class="k">for </span>i <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">ADDR</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do
        </span><span class="nb">echo</span> <span class="nv">$i</span>
    <span class="k">done
done</span> &lt; <span class="s2">"list"</span>
</code></pre></div></div>

<p>list 파일</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 2 3 4 5
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">while read -r line: do ... done &lt; "list"</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">list</code> 파일로 부터 해당 내용을 줄별로 읽어와서 각 줄의 값을 <code class="language-plaintext highlighter-rouge">line</code> 변수의 값으로 생성한다.</li>
      <li><code class="language-plaintext highlighter-rouge">-r</code> 옵션은 <code class="language-plaintext highlighter-rouge">read</code> 명령어가 <code class="language-plaintext highlighter-rouge">\</code> 을 이스케이프 문자가 아닌 데이터 원본 그대로 무결성을 유지한채로 값을 가질 수 있도록 조건을 부여한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">IFS=' ' read -ra ADDR &lt;&lt;&lt; "$line"</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">IFS</code> 는 “Internal Field Separator” 의 약자, Bash 에서 단어 경계를 정의하는데 사용되는 환경 변수. 이 구분에서 <code class="language-plaintext highlighter-rouge">IFS</code> 는 공백문자 <code class="language-plaintext highlighter-rouge">' '</code> 로 설정되어 단어의 구분을 공백으로 사용하겠다는 의미.</li>
      <li><code class="language-plaintext highlighter-rouge">-ra</code> 에서 <code class="language-plaintext highlighter-rouge">a</code> 옵션은 입력된 data 를 배열로 변수 <code class="language-plaintext highlighter-rouge">ADDR</code> 에 저장함을 의미</li>
      <li><code class="language-plaintext highlighter-rouge">&lt;&lt;&lt;</code> 은 here string redirction 을 의미. <code class="language-plaintext highlighter-rouge">here string</code> 은 문자열 데이터를 명령어의 표준입력으로 직접 전달할 수 있게 해준다. <code class="language-plaintext highlighter-rouge">명령어 &lt;&lt;&lt; "문자열"</code> 과 같은 형태로, redirection 을 뒤에 오는 문자열 값을 바로 가져와서 사용할 수 있게 해준다. 예를 들어,
        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@DESKTOP:~<span class="nv">$ </span><span class="nb">grep</span> <span class="s2">"찾는"</span> <span class="o">&lt;&lt;&lt;</span> <span class="s2">"여기에는 찾는 단어가 있을까요?"</span>
여기에는 찾는 단어가 있을까요?
</code></pre></div>        </div>
        <p>와 같이, 외부 파일 등에서 가져오는 것이 아니라 뒤에 명시된 문자열 값을 바로 redirection 하여 가져와 사용하게 된다.</p>
      </li>
      <li>따라서 해당 구문을 정리하면,<br />
(1). line 변수 값을 문자열로 생성한다.<br />
(2). (1) 번 값을 redirection 하여 가져오고,<br /> 
(3). <code class="language-plaintext highlighter-rouge">\</code> 를 별도 처리하지 않고, <br />
(4). 띄어쓰기(‘ ‘) 로 구분하여 생성된 배열 값을<br /> 
(5). 배열 변수 <code class="language-plaintext highlighter-rouge">ADDR</code> 의 값으로 생성한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">for i in "${ADDR[@]}"; do ... done</code>
    <ul>
      <li>반복문 <code class="language-plaintext highlighter-rouge">for</code> 는 배열 변수 ADDR 의 원소를 순회하면서 원소값 을 대입하여 <code class="language-plaintext highlighter-rouge">do ... done</code> 내 script 를 수행함.</li>
      <li><code class="language-plaintext highlighter-rouge">ADDR[@]</code> 는 각 원소를 의미</li>
      <li><code class="language-plaintext highlighter-rouge">""</code> 감싸 해당 원소값을 문자열로 변환, 혹시 문자열 내 다른 문자열을 포함한 경우 (ex. “값은 ${ADDR[@]}”) 다른 문자열과  배열 변수 값 부분을 명확히 구분하기 위해 <code class="language-plaintext highlighter-rouge">${}</code> 로 감싸줌.</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>실행 결과</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@DESKTOP:~<span class="nv">$ </span>./example.sh
1
2
3
4
5
</code></pre></div></div>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="shell scirpt" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 01]]></summary></entry><entry><title type="html">Phoenix Live Generator</title><link href="http://localhost:4000/phonix-generator.html" rel="alternate" type="text/html" title="Phoenix Live Generator" /><published>2024-01-26T08:32:20+09:00</published><updated>2024-01-26T08:32:20+09:00</updated><id>http://localhost:4000/phonix-generator</id><content type="html" xml:base="http://localhost:4000/phonix-generator.html"><![CDATA[<p>(아래 내용은 <a href="https://pragprog.com/titles/liveview/programming-phoenix-liveview/">programming-phoenix-liveview_B10.0 - chapter 3 Generators: Contexts and Schemas</a> 를 정리한 것임을 밝힙니다.)</p>

<h3 id="phoenix-live-generator-란">Phoenix Live Generator 란?</h3>

<p>Phoenix Live Generator 는 주어진 resource 에 대한 기본적인 CRUD code 생성을 도와주는 utility 로 다음 작업에 대한 설정을 자동을 생성해준다.</p>

<ul>
  <li>backend  : schema, context</li>
  <li>frontend : routs, LiveView, templates</li>
</ul>

<p>다만 위에서 표현한 ‘code 생성’ 의 의미는 elixir 에서는 조금 다른 의미를 포함하고 있다. 이는 Generator 가 자체적으로 새로운 code 을 생성 해준다기보다, 이미 정의된 macro 를 사용하여 ‘code 를 생성하는 code’ 를 실행시킴으로써, 최종적으로 사용자가 정의한 code 를 얻을 수 있게 되는 것을 의미한다.</p>

<p>결과적으로 Generator 를 사용하여, 작성자의 반복적 작업을 줄여 줌으로써, 작성자는 각 부분의 logic 및 공통적이지 않은 부분의 작업에 집중할 수 있도록 도와준다.</p>

<h3 id="phoenix-live-generator-기본-구조">Phoenix Live Generator 기본 구조</h3>

<p>간단한 예제로 상품에 대한 정보를 DB 에 저장하고, 상품 리스트를 화면에 보여주는 view 를 가진 application 을 개발한다고 가정해보면, 해당 application 의 구조를 아래와 같이 그려볼 수 있다.</p>

<center><img src="assets\img\posts\2024-01-26-product_diagram.png" width="300" /></center>

<ul>
  <li>frontend: web 에서 <code class="language-plaintext highlighter-rouge">/product</code> GET 요청이 있을 때, 상품 리스트를 보여주는 tempalte 이 rendering 됨.</li>
  <li>backend : phoenix application 에서 live view 는 전체적으로 context 에 관리되며, core part 인 schema 를 감싸고 있다. 즉, context 는 frontend 및 DB 와 상호작용을 담당한다.</li>
</ul>

<h3 id="phoenix-live-generator-의-실행">Phoenix Live Generator 의 실행</h3>

<p>기본 원리와 개념 이해를 위해, 아래 command 를 실행하여, Generator 를 실행시킨다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mix phx.gen.live Catalog Product products name:string <span class="se">\</span>
description:string unit_price:float sku:integer:unique
</code></pre></div></div>

<p>그러면 자동으로 관련 migration, schema 를 포함한 context, template 파일들이 생성되며, command 속성값들의 의미는 다음과 같다.</p>

<ul>
  <li>Catalog : boundary layer 인 context</li>
  <li>Product : applcation core 인 schema</li>
  <li>prodcuts: DB table</li>
  <li>name:string description:string unit_price:float sku:integer:unique : schema fields &amp; DB table colums</li>
</ul>

<h3 id="generated-core-의-이해">Generated Core 의 이해</h3>

<p>Generated Core (ex. Product) 는,</p>

<ul>
  <li>항상 동일한 입력에 대해 동일한 출력을 제공하는 순수함수이여야 한다.</li>
  <li>database 를 관리하며 상호작용 한다. 즉 database table 생성, data 관리/유지 작업, transaction 과 query 준비 작업을 담당한다.</li>
</ul>

<p>이와 관련된 파일들을 살펴보면 다음과 같다.</p>

<h4 id="the-product-migration">The Product Migration</h4>

<p>database table 을 정의한 migration 파일을 <code class="language-plaintext highlighter-rouge">pento/priv/repo/migrations/20230728120332_create_products.exs</code>와 같이 생성되어 진다. 해당 code 를 살펴보면 아래와 같이 command 에서 명시한 table 이름, column 명, data type 이 생성되어 있다.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">Pento</span><span class="o">.</span><span class="no">Repo</span><span class="o">.</span><span class="no">Migrations</span><span class="o">.</span><span class="no">CreateProducts</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Migration</span>

  <span class="k">def</span> <span class="n">change</span> <span class="k">do</span>
    <span class="n">create</span> <span class="n">table</span><span class="p">(</span><span class="ss">:products</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">add</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:string</span>
      <span class="n">add</span> <span class="ss">:description</span><span class="p">,</span> <span class="ss">:string</span>
      <span class="n">add</span> <span class="ss">:unit_price</span><span class="p">,</span> <span class="ss">:float</span>
      <span class="n">add</span> <span class="ss">:sku</span><span class="p">,</span> <span class="ss">:integer</span>

      <span class="n">timestamps</span><span class="p">()</span>
    <span class="k">end</span>

    <span class="n">create</span> <span class="n">unique_index</span><span class="p">(</span><span class="ss">:products</span><span class="p">,</span> <span class="p">[</span><span class="ss">:sku</span><span class="p">])</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>그리고 아래 command 실행을 통해 DB 에 해당 table 이 생성됨을 확인할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mix ecto.migrate
</code></pre></div></div>

<h4 id="the-product-schema">The Product Schema</h4>

<p>아래 <code class="language-plaintext highlighter-rouge">lib/pento/catalog/product.ex</code> 생성된 파일 <code class="language-plaintext highlighter-rouge">schema</code> macro 구현부를 통해 Elixir 구조체와 databalse <code class="language-plaintext highlighter-rouge">products</code> table record 간 변환할 수 있게 해준다.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">Pento</span><span class="o">.</span><span class="no">Catalog</span><span class="o">.</span><span class="no">Product</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Schema</span>
  <span class="kn">import</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Changeset</span>
  
  <span class="n">schema</span> <span class="s2">"products"</span> <span class="k">do</span>
    <span class="n">field</span> <span class="ss">:description</span><span class="p">,</span> <span class="ss">:string</span>
    <span class="n">field</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:string</span>
    <span class="n">field</span> <span class="ss">:sku</span><span class="p">,</span> <span class="ss">:integer</span>
    <span class="n">field</span> <span class="ss">:unit_price</span><span class="p">,</span> <span class="ss">:float</span>
  <span class="n">timestamps</span><span class="p">()</span>
<span class="k">end</span>
</code></pre></div></div>

<p>관련 작업을 수행해주는 함수의 경우, macro 에 의해 자동 생성되며, 그 목록은 아래와 같다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; <span class="nb">alias </span>Pento.Catalog.Product
iex&gt; exports Product
__changeset__/0 __schema__/1 __schema__/2 __struct__/0
__struct__/1 changeset/2

</code></pre></div></div>

<p>이중 <code class="language-plaintext highlighter-rouge">schema</code> 함수가 elixir 구조체를 생성해서 database table record 와 엮는 작업을 담당한다.</p>

<p>해당 구조체 생성은 <code class="language-plaintext highlighter-rouge">struct/1</code> 로 생성하며, 이를 CLI 상태에서 실행하여, 직접 그 결과를 확인할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; Product.__struct__<span class="o">(</span>name: <span class="s2">"Exploding Ninja Cows"</span><span class="o">)</span>
%Pento.Catalog.Product<span class="o">{</span>
  __meta__: <span class="c">#Ecto.Schema.Metadata&lt;:built, "products"&gt;,</span>
  description: nil,
  <span class="nb">id</span>: nil,
  inserted_at: nil,
  name: <span class="s2">"Exploding Ninja Cows"</span>,
  sku: nil,
  unit_price: nil,
  updated_at: nil
<span class="o">}</span>
</code></pre></div></div>

<p>여기에서 <code class="language-plaintext highlighter-rouge">id</code>, <code class="language-plaintext highlighter-rouge">inserted_at</code>, <code class="language-plaintext highlighter-rouge">updated_at</code> field 의 경우, 자동 생성되는 field 로 record 관리에 필요한 data (ex. <code class="language-plaintext highlighter-rouge">id</code> 의 경우, 각 record 고유값으로 식별자 역할) 들을 저장한다.</p>

<p><code class="language-plaintext highlighter-rouge">changeest</code> 의 경우, 기존에 정리된 내용 참고. (<a href="https://y2gon2.github.io/changeset.html">changeset/2 in Ecto Library</a>)</p>

<h3 id="generated-boundary-의-이해">Generated Boundary 의 이해</h3>

<p>boundary 영역에 대한 code 을 Context 라고 하며, 외부에서 입력된 data 를 sanitizing, validating 해서 변환된 data 를 cord 영역으로 넘겨주는 작업을 담당하며 이를 정리하면 아래와 같다.</p>

<ul>
  <li>Access External Services : 외부 서비스에 대한 단일 접근 지점을 제공. application 에서 필요한 외부 data 나 기능을 통합하고, 이러한 서비스들과 상호 작용을 중앙에서 관리하게 해줌.</li>
  <li>Abstract Away Tedious Details : 반복적이거나 복잡한 작업등ㄹ을 숨김(추상화) 함으로써, 개발자가 보다 중요한 logic 에 집중할 수 있도록 함. 예를 들어, data formating 이나 네트워크 통신과 같은 작업을 사전에 처리</li>
  <li>Handle uncertainty : {:ok, result} 또는 {:error, message} 와 같은 형태로 그 결과를 반환함으로써, 성공 또는 실패를 명확하게 함. 이를 통해, 오류 처리 및 예외 상황을 보다 효율적으로 처리할 수 있음.</li>
  <li>Present a single, common API : 하나의 database table 관련 service 들에 대해 단일 접근점을 제공하여 application 내 다양한 기능들을 일관된 방식으로 사용할 수 있게 해주며, 이를 통해 application 의 사용성과 유지보수서을 향상시킴.</li>
</ul>

<h4 id="외부-service-로부터의-접근의-예">외부 service 로부터의 접근의 예</h4>

<p>database 의 접근은 applciation 입장에서 외부 service 에 대한 접근에 해당한다. 관련 Repo 작업은 <code class="language-plaintext highlighter-rouge">Ecto</code> library 함수를 사용하게 되며, 따라서 <code class="language-plaintext highlighter-rouge">Ecto</code> code 도 core 와 boundary 부분으로 나누어지게 된다.</p>

<ul>
  <li>Ecto core : query build &amp; transaction 준비 작업 (외부 환경에 영향 없이 입력값과 내부 logic 에만 영향을 받아 결과가 항상 확정적이고 예측가능, ex. <code class="language-plaintext highlighter-rouge">changeset</code>)</li>
  <li>Ecto boundary : <code class="language-plaintext highlighter-rouge">Ecto.Repo</code> 작업의 경우, 외부 상황 (ex. DB server 연결 상태)에 따라 그 결과가 바뀔 수 있으므로, boundary 에 해당</li>
</ul>]]></content><author><name>Yong gon Yun</name></author><category term="phoenix" /><category term="generator" /><summary type="html"><![CDATA[Phoenix Live Generator 는 주어진 resource 에 대한 기본적인 CRUD code 생성을 도와주는 utility 이다. 이에 대해 알아보자.]]></summary></entry><entry><title type="html">(App 개발 03) Account context - users table 에 nickname 항목 추가</title><link href="http://localhost:4000/users-column-add.html" rel="alternate" type="text/html" title="(App 개발 03) Account context - users table 에 nickname 항목 추가" /><published>2024-01-25T10:32:20+09:00</published><updated>2024-01-25T10:32:20+09:00</updated><id>http://localhost:4000/users-column-add</id><content type="html" xml:base="http://localhost:4000/users-column-add.html"><![CDATA[<p>Phoenix LiveView Authrization 설정을 위해 lon in 기능을 활성화에 필요한 계정 생성 작업이 필요하다. 이 때, <code class="language-plaintext highlighter-rouge">mix phx.gen.auth Accounts User users</code> command 를 통해 사용자 email, password 정보를 저장하고 이를 사용하여 authrization, session 괸리를 위한 service code, template, token 저장 table 까지 모두 알아서 생성해 준다.</p>

<p>매우 편리한 기능이지만, 해당 command 로 추가 정보를 저장/관리하는 기능을 함께 생성할 수는 없음을 확인하였다. 대신 추가 migration 생성 및 필요한 요소를 관련 code 에 직접 추가하여 사용 가능하였다.</p>

<p>현재 작업하고 있는 application 에서 사용자 정보를 노출 시킬 때, email 보다 nickname 으로 보여지는 것이 좋다고 판단되어 이를 추가하고 실제 application 에 반영하는 작업을 정리해 보았다.</p>

<h3 id="1-migration-생성-및-실행">1. migration 생성 및 실행</h3>

<p>다음의 command 를 실행하여 migration script 파일을 생성</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mix ecto.gen.migration add_nickname_to_users
</code></pre></div></div>

<p>이를 실행하면 <code class="language-plaintext highlighter-rouge">priv/repo/migrations/(생성일시)_add_nickname__to_users.exs</code> 파일이 생성된다. 해당 파일에서 <code class="language-plaintext highlighter-rouge">nickname</code> column 을 추가할 code 를 작성한다.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">MyPjt1</span><span class="o">.</span><span class="no">Repo</span><span class="o">.</span><span class="no">Migrations</span><span class="o">.</span><span class="no">AddNicknameToUsers</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Migration</span>

  <span class="k">def</span> <span class="n">change</span> <span class="k">do</span>
    <span class="n">alter</span> <span class="n">table</span><span class="p">(</span><span class="ss">:users</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">add</span> <span class="ss">:nickname</span><span class="p">,</span> <span class="ss">:string</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>해당 파일을 아래의 command 로 실행하고, database 에 변경 사항이 반영되었는지 확인한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mix ecto.migrate
</code></pre></div></div>

<h3 id="2-user-module-에서-schema-및-changeset2-수정">2. <code class="language-plaintext highlighter-rouge">User</code> module 에서 schema 및 <code class="language-plaintext highlighter-rouge">changeset/2</code> 수정</h3>

<p>아래와 같이 <code class="language-plaintext highlighter-rouge">Usher</code> module 에서 <code class="language-plaintext highlighter-rouge">schema</code> 에 field 를 추가시켜 준다.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">schema</span> <span class="s2">"users"</span> <span class="k">do</span>
    <span class="n">field</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:string</span>
    <span class="n">field</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">:string</span><span class="p">,</span> <span class="ss">virtual:</span> <span class="no">true</span><span class="p">,</span> <span class="ss">redact:</span> <span class="no">true</span>
    <span class="n">field</span> <span class="ss">:hashed_password</span><span class="p">,</span> <span class="ss">:string</span><span class="p">,</span> <span class="ss">redact:</span> <span class="no">true</span>
    <span class="n">field</span> <span class="ss">:confirmed_at</span><span class="p">,</span> <span class="ss">:naive_datetime</span>
    <span class="n">field</span> <span class="ss">:nickname</span><span class="p">,</span> <span class="ss">:string</span>  <span class="c1"># field 추가</span>

    <span class="n">timestamps</span><span class="p">(</span><span class="ss">type:</span> <span class="ss">:utc_datetime</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>그러나, field 를 추가하고, 계정 등록 module (<code class="language-plaintext highlighter-rouge">user_registration_live.ex</code>) 에서 nickname 입력을 구현하여도 실제로 저장이 되지 않는다. 그 이유는 nickname 정보까지 모두 입력 후 저장 버튼을 누를 때, 입력 값의 유효성 검증이 우선 진행되며, 검증을 통과된 경우, db 에 저장 및 authorization 작업이 진행되게 된다.</p>

<p>그런데, 관련 유효성 검증 작업, 즉 <code class="language-plaintext highlighter-rouge">changeset/2</code> code 를 확인하면</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">registration_changeset</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">opts</span> <span class="p">\\</span> <span class="p">[])</span> <span class="k">do</span>
    <span class="n">user</span>
    <span class="o">|&gt;</span> <span class="n">cast</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="p">[</span><span class="ss">:email</span><span class="p">,</span> <span class="ss">:password</span><span class="p">])</span>
    <span class="o">|&gt;</span> <span class="n">validate_email</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">validate_password</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>여기에서 <code class="language-plaintext highlighter-rouge">cast(attrs, [:email, :password])</code> 함수는 매개변수로 입력된 key 들 (<code class="language-plaintext highlighter-rouge">:email, :password</code>) 에 대한 value 값이 변경되었을 때, 해당 항목에 대한 <code class="language-plaintext highlighter-rouge">changeset</code> 을 반환하는 함수이다. 즉 해당 항목에 <code class="language-plaintext highlighter-rouge">:nickname</code> 을 추가해 주어야 함께 <code class="language-plaintext highlighter-rouge">changeset</code> 으로 변환되어, 유효성을 검증하고, 다음 작업을 진행할 수 있게 된다. (<code class="language-plaintext highlighter-rouge">:nickname</code>에 대한 vaildation 은 필요하지 않아서 추가하지 않았음.)</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">registration_changeset</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">opts</span> <span class="p">\\</span> <span class="p">[])</span> <span class="k">do</span>
    <span class="n">user</span>
    <span class="o">|&gt;</span> <span class="n">cast</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="p">[</span><span class="ss">:email</span><span class="p">,</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">:nickname</span><span class="p">])</span> <span class="c1"># :nickname 추가</span>
    <span class="o">|&gt;</span> <span class="n">validate_email</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">validate_password</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre></div></div>

<h3 id="3-계정-생성-시-nickname-추가-화면-구현">3. 계정 생성 시 nickname 추가 화면 구현</h3>

<p><code class="language-plaintext highlighter-rouge">user_registration_live.ex</code> <code class="language-plaintext highlighter-rouge">render/2</code> 내 아래와 같이 nickname 항목을 추가하면 최종적으로 계정 생성시 nickname 정보까지 입력해야 조건을 만들어 줄 수 있다.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">...</span>
  <span class="o">&lt;.</span><span class="n">simple_form</span> <span class="o">...</span> <span class="o">&gt;</span>
    <span class="o">...</span>
    <span class="o">&lt;.</span><span class="n">input</span> <span class="n">field</span><span class="o">=</span><span class="p">{</span><span class="nv">@form</span><span class="p">[</span><span class="ss">:email</span><span class="p">]}</span> <span class="n">type</span><span class="o">=</span><span class="s2">"email"</span> <span class="n">label</span><span class="o">=</span><span class="s2">"Email"</span> <span class="n">required</span> <span class="o">/&gt;</span>
    <span class="o">&lt;.</span><span class="n">input</span> <span class="n">field</span><span class="o">=</span><span class="p">{</span><span class="nv">@form</span><span class="p">[</span><span class="ss">:password</span><span class="p">]}</span> <span class="n">type</span><span class="o">=</span><span class="s2">"password"</span> <span class="n">label</span><span class="o">=</span><span class="s2">"Password"</span> <span class="n">required</span> <span class="o">/&gt;</span>
    <span class="o">&lt;.</span><span class="n">input</span> <span class="n">field</span><span class="o">=</span><span class="p">{</span><span class="nv">@form</span><span class="p">[</span><span class="ss">:nickname</span><span class="p">]}</span> <span class="n">label</span><span class="o">=</span><span class="s2">"Nickname"</span> <span class="n">required</span> <span class="o">/&gt;</span>
    <span class="o">...</span>
  <span class="o">&lt;/.</span><span class="n">simple_form</span><span class="o">&gt;</span>
<span class="o">...</span>
</code></pre></div></div>
<center><img src="assets\img\posts\nickname_form.png" width="500" /></center>
<p><br /></p>
<center><strong>users table</strong></center>
<center><img src="assets\img\posts\nickname_db.png" width="700" /></center>
<p><br /></p>]]></content><author><name>Yong gon Yun</name></author><category term="phoenix" /><category term="liveview" /><category term="migration" /><category term="table_항목_추가" /><category term="schema" /><category term="changeset/2" /><category term="applciation_개발1" /><summary type="html"><![CDATA[계정 정보에서 nickname 정보가 필요함에 따라, 이를 기존에 생성한 users table 에 추가하고, 계정 생성 시, nickname 을 입력하도록 함.]]></summary></entry></feed>