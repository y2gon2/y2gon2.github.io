<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-03-22T11:48:55+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Gon’s Tech Jurnal</title><subtitle>The Record of Backend Development</subtitle><author><name>Yong gon Yun</name></author><entry><title type="html">IPC 실습 04 - Shared Memeory</title><link href="http://localhost:4000/IPC04.html" rel="alternate" type="text/html" title="IPC 실습 04 - Shared Memeory" /><published>2024-03-22T10:32:20+09:00</published><updated>2024-03-22T10:32:20+09:00</updated><id>http://localhost:4000/IPC04</id><content type="html" xml:base="http://localhost:4000/IPC04.html"><![CDATA[<style>
    summary::-webkit-details-marker {
        display: none;
    }
    summary {
        list-style: none;
    }
</style>

<details><summary></summary>
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
</details>

<h3 id="1-공유메모리-란">1. 공유메모리 란?</h3>

<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) (https://comento.kr/)</p>

<p>데이터 공유를 목적으로 물리적인 메모리의 동일한 영영을 각 프로세스가 매핑</p>
<ul>
  <li>일반적인 메모리 접근과 동일한 방식으로 사용 가능</li>
  <li>별동의 시스템콜이나 함수 없이 직접 데이터 접근이 가능하므로 작업 속도가 빠름.</li>
  <li>여러 프로세스가 동시에 같은 영역에 작업하여 데이터의 일관성이 깨지는 것을 방지하기 위한 기법 필요 (e.g. semaphore)</li>
</ul>

<h3 id="2-주요-함수">2. 주요 함수</h3>

<h4 id="void-mmapvoid-start-size_t-length-int-prot-int-flags-int-fd-off_t-offset">void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);</h4>

<p>파일이나 장치의 내용을 메모리에 매핑하여, 이를통해 프로세스는 파일이나 장치를 마치 메모리 배열인것저럼 접근할 수 있게 해주는 함수.</p>

<ul>
  <li>start : 매핑 시작 메모리 주소. NULL 로 설정시, 커널이 자동으로 설정.</li>
  <li>length: 매핑할 메로리 크기(bytes)</li>
  <li>prot  : 매핑된 메모리 영역의 보호 수준
    <ul>
      <li>PROT_READ : 읽기 가능</li>
      <li>PROT_WRITE: 쓰기 가능</li>
      <li>PROT_EXEC : 실행 가능</li>
      <li>PROT_NONE : 접근 금지</li>
    </ul>
  </li>
  <li>flag  : 매핑의 특성을 제어
    <ul>
      <li>MAP_SHARED    : 매핑된 메모리 영역에 대한 변경사항이 파일이 직접 반영되며, 변경사항은 다른 모든 매핑을 통해서도 볼 수 있음.</li>
      <li>MAP_PRIVATE   : 매핑된 메모리 영영에 대한 변경사항이 복사본에만 적용되며, 원본 파일은 변경되지 않음. 변경사항은 해당 프로세스에서만 볼 수 있음.</li>
      <li>MAP_FIXED     : start 에 지정된 주소에 매핑을 강제.</li>
    </ul>
  </li>
  <li>fd    : 매핑할 파일의 파일 디스크립터. <code class="language-plaintext highlighter-rouge">open</code> 함수등을 통해 얻을 수 있음.</li>
  <li>offset: 파일 내에서 매핑을 시작할 offset. 이값은 시스템의 메모리 관리 기본단위 (페이지 - 일반적으로 4KB) 의 배수로 표기</li>
</ul>

<h4 id="int-shm_openconst-char-name-int-flags-mode_t-mode">int shm_open(const char *name, int flags, mode_t mode);</h4>

<p>POSIX (Portable Operating System Interface) 기반 시스템에서 공유 메모리 객체를 생성하거나 열기 위해 사용되는 함수. 이 함수는 공유 메모리를 사용하여 프로세스 간 통신(IPC)에 활용될 수 있는 메커니즘을 제공, 해당 함수로 생성된 객체는 파일처럼 관리되며, 이를 통해 프로세스들이 메모리 공간을 공유할 수 있다. 해당 객체는 ‘/dev/shm’ 밑에 생성, 재부팅시 사라짐.</p>

<ul>
  <li>name  : 공유 메모리 객체 이름. ‘/’ 로 시작하는 경로 형식을 사용</li>
  <li>flags :
    <ul>
      <li>O_RDONLY  : 읽기 전용</li>
      <li>O_RDWR    : 읽기 및 쓰기</li>
      <li>O_CREAT   : (존재하지 않을 경우) 객체 생성</li>
      <li>O_EXCL    : (O_CREATE 와 함께 사용하여), 동일 경로의 객체가 이미 존재한다면 shm_open은 -1을 반환하고, errno를 EEXIST로 설정</li>
    </ul>
  </li>
  <li>
    <p>mode  : 생성한 공유메모리 객체에 대한 접근 권한 지정 (e.g.  0644는 소유자는 읽기와 쓰기 권한 부여)</p>
  </li>
  <li>반환값: 파일 디스크립터</li>
</ul>

<h4 id="int-ftruncateint-fd-off_t-length">int ftruncate(int fd, off_t length)</h4>

<p>파일 크기를 변경하는데 사용하며, 특히 공유 메모리 객체의 크기를 조정할 때 사용됨.</p>

<ul>
  <li>fd    : 크기를 변경하고자 하는 파일의 파일 디스크립터</li>
  <li>length: 파일의 새로운 크기를 바이트 단위로 지정</li>
</ul>

<h3 id="3-code">3. code</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="c1"> // mmap, munmap, PROT_READ, PROT_WRITE, MAP_SHARED, MAP_FAILED 등을 정의</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="c1"> // shm_open, shm_unlink 함수 사용 시 필요한 mode 매크로(S_IRUSR, S_IWUSR 등)를 정의</span><span class="cp">
</span>
<span class="c1">//  POSIX 호환 시스템에서 정의된, 오류를 보고하는 데 사용되는 전역 변수 </span>
<span class="c1">// 해당 코드에서 'errno' 변수에 함수 실행 오류 반환 값을 받아 처리하기 위해 사용</span>
<span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="c1"> </span><span class="cp">
</span>
<span class="cp">#define SHM_NAME "/comento_mem"
#define SHM_SIZE 4096
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span>  <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">needs_init</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fd</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

    <span class="c1">// 파일 실행 '-d' 옵션 시 기존 공유 메모리 삭제</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"-d"</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Delete the shared memory</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">shm_unlink</span><span class="p">(</span><span class="n">SHM_NAME</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> 

    <span class="c1">// '-l' : 생성된 객체를 리스트로 확인 </span>
    <span class="c1">// ls 명령어로 "/dev/shm" 내 파일 목록을 가져오는 것으로 구현</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"-l"</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">ls_argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">"/bin/ls"</span><span class="p">,</span> <span class="s">"/dev/shm"</span><span class="p">,</span> <span class="nb">NULL</span>
        <span class="p">};</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"List the shared memory:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">execve</span><span class="p">(</span><span class="n">ls_argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ls_argv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Failed to run ls command"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
    <span class="p">}</span> 

    <span class="c1">// 위 옵션 &amp;&amp; 옵션 없는 상태를 제외하고 예외 처리</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Usage : %s &lt;-d&gt; &lt;-l&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 옵션이 없는 상태 - 공유 메모리 객체 사용 모드 설정</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">shm_open</span><span class="p">(</span><span class="n">SHM_NAME</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">,</span> <span class="mo">0600</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 'ENOENT' : "Error NO ENTry" 파일, 디렉토리 또는 지정된 객체가 존지 하지 않을 때 반환되는 오류코드</span>
        <span class="c1">// 'shm_open' 함수 실행 오류 코드를 errno 전역 변수에 할당.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Create new shared memory</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

            <span class="c1">// 기존에 객체가 없는 경우 새로 생성하고 사용 모드 설정</span>
            <span class="n">fd</span> <span class="o">=</span> <span class="n">shm_open</span><span class="p">(</span><span class="n">SHM_NAME</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_RDWR</span><span class="p">,</span> <span class="mo">0600</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Set the size of shared memory</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">ftruncate</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">SHM_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Failed to ftruncate</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">needs_init</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Failed to shm_open</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 메모리 매핑 설정</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Mapping the shared memeory</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">SHM_SIZE</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Failed to mmap</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 공유 메모리 객체가 새로 생성한 상태가 아니라면, 해당 메모리에 기존에 저장된 내용을 출력</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">needs_init</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"before: %.4095s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span> <span class="c1">// 최대 4095 개 문자 출력</span>
    <span class="p">}</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%4095s"</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>

    <span class="n">munmap</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">SHM_SIZE</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="4-공유-메모리-사용">4. 공유 메모리 사용</h3>

<p>위 소스 파일을 컴파일 하여 사용</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>gcc <span class="nt">-o</span> mmap mmap.c
</code></pre></div></div>

<p>우선, 사용하기전 공유 메모리 객체 저장 디렉토리를 확인하면, 아무것도 없는 것을 확인할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-lah</span> /dev/shm
total 0
drwxrwxrwt  2 root root   40 Mar 22 11:40 <span class="nb">.</span>
drwxr-xr-x 16 root root 3.5K Mar 22 11:27 ..
</code></pre></div></div>

<p>객체 생성 파일을 실행하고, 다시 ls 명령어 또는 <code class="language-plaintext highlighter-rouge">mmap -l</code> 옵션을 사용하여 모두 객체가 생성되었음을 확인할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>./mmap
Create new shared memory
Set the size of shared memory
Mapping the shared memeory
First!!!!!!!!!
user@DESKTOP:~<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-lah</span> /dev/shm
total 4.0K
drwxrwxrwt  2 root root   60 Mar 22 11:38 <span class="nb">.</span>
drwxr-xr-x 16 root root 3.5K Mar 22 11:27 ..
<span class="nt">-rw-------</span>  1 gon  gon  4.0K Mar 22 11:38 comento_mem
user@DESKTOP:~<span class="nv">$ </span> ./mmap <span class="nt">-l</span>
List the shared memory:
comento_mem
</code></pre></div></div>

<p>만약 다시 객체를 생성하고자 하면 기존 저장된 내용을 확인할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span> ./mmap
Mapping the shared memeory
before: First!!!!!!!!!
Second!!!!!!!
</code></pre></div></div>

<p>마지막으로 해당 객체를 제거 및 확인</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>./mmap <span class="nt">-d</span>
Delete the shared memory
user@DESKTOP:~<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-lah</span> /dev/shm
total 0
drwxrwxrwt  2 root root   40 Mar 22 11:40 <span class="nb">.</span>
drwxr-xr-x 16 root root 3.5K Mar 22 11:27 ..
</code></pre></div></div>

<p>그러나, 실제 공유 메모리의 경우, 여러 프로세스가 접근하여 읽기, 쓰기를 수행할 수 있기 때문에 위와 같이 작성하면 데이터의 일관성을 보장할 수 없다. 따라서 일관성을 보장하기 위한 추가 작업 (e.g. semaphore 구현 등) 이 필요하다.</p>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="IPC" /><category term="inter-process communication" /><category term="shared memory" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 18]]></summary></entry><entry><title type="html">IPC 실습 03 - Unix socket</title><link href="http://localhost:4000/IPC03.html" rel="alternate" type="text/html" title="IPC 실습 03 - Unix socket" /><published>2024-03-20T10:32:20+09:00</published><updated>2024-03-20T10:32:20+09:00</updated><id>http://localhost:4000/IPC03</id><content type="html" xml:base="http://localhost:4000/IPC03.html"><![CDATA[<style>
    summary::-webkit-details-marker {
        display: none;
    }
    summary {
        list-style: none;
    }
</style>

<details><summary></summary>
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
</details>

<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) (https://comento.kr/)</p>

<h3 id="1-unix-socket">1. Unix Socket</h3>

<p>웹서버 서버-클라이언트 구조와 같이, 다수의 프로세스간 양방향 통신을 가능하게 함.</p>

<ul>
  <li>serever</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/un.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#define SOCKET_NAME "/tmp/echo_socket"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">socketaddr_un</span> <span class="n">addr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">recv_bytes</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

    <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_UNIX</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">sockfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[Server] Failed to create socket</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
    <span class="n">addr</span><span class="p">.</span><span class="n">sun_family</span> <span class="o">=</span> <span class="n">AF_UNIX</span><span class="p">;</span>
    <span class="n">snprintf</span><span class="p">(</span><span class="n">addr</span><span class="p">.</span><span class="n">sun_path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">.</span><span class="n">sun_path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">SOCKET_NAME</span><span class="p">);</span>

    <span class="n">unlink</span><span class="p">(</span><span class="n">addr</span><span class="p">.</span><span class="n">sun_path</span><span class="p">);</span> <span class="c1">// remove the socket file if exists</span>
    <span class="k">if</span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[Server] Failed to bind</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[Server] Failed to listen</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">connfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">connfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[Server] Failed to accept</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[Server] Client connected!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">recv_bytes</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
                <span class="k">if</span><span class="p">(</span><span class="n">recv_bytes</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"[Server] Recv : %.*s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">recv_bytes</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
                <span class="n">write</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">recv_bytes</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"[Server] Client disconnected!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">3</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>client</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/un.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="cp">#define SOCKET_NAME "/tmp/echo_socket"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">socketfd</span><span class="p">,</span> <span class="n">recv_bytes</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="n">addr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

    <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_UNIX</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">sockfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[Client] Failed to create socket</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
    <span class="n">addr</span><span class="p">.</span><span class="n">sun_family</span> <span class="o">=</span> <span class="n">AF_UNIX</span><span class="p">;</span>
    <span class="n">snprintf</span><span class="p">(</span><span class="n">addr</span><span class="p">.</span><span class="n">sun_path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">.</span><span class="n">sun_path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">SOCKET_NAME</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="n">strcut</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"[Client] Failed to connect</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"'q' for exit&gt;"</span><span class="p">);</span>

        <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

        <span class="n">scanf</span><span class="p">(</span><span class="s">"%255s"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"q"</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">write</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
        <span class="n">recv_bytes</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
        <span class="k">if</span><span class="p">(</span><span class="n">recv_bytes</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"[Client] Server shutdown!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"[Client] Recv: %.*s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">recv_bytes</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[Client] Exit!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="IPC" /><category term="inter-process communication" /><category term="unix socket" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 17]]></summary></entry><entry><title type="html">IPC 실습 02 - pipe</title><link href="http://localhost:4000/IPC02.html" rel="alternate" type="text/html" title="IPC 실습 02 - pipe" /><published>2024-03-19T10:32:20+09:00</published><updated>2024-03-19T10:32:20+09:00</updated><id>http://localhost:4000/IPC02</id><content type="html" xml:base="http://localhost:4000/IPC02.html"><![CDATA[<style>
    summary::-webkit-details-marker {
        display: none;
    }
    summary {
        list-style: none;
    }
</style>

<details><summary></summary>
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
</details>

<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) (https://comento.kr/)</p>

<h3 id="1-pipe-구현을-통한-부모-프로세서와-자식-프로세서-ipc">1. pipe 구현을 통한 부모 프로세서와 자식 프로세서 IPC</h3>

<p>pipe 개념도</p>

<center>
  <img src="assets\img\posts\2024-03-19-IPC0201.png" width="500" />
</center>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pipe_from_parent_to_child</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">pipe_from_child_to_parent</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

    <span class="n">pipe</span><span class="p">(</span><span class="n">pipe_from_parent_to_child</span><span class="p">);</span>
    <span class="n">pipe</span><span class="p">(</span><span class="n">pipe_from_child_to_parent</span><span class="p">);</span>

    <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 사용하지 않는 fd 는 닫아줌.</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipe_from_child_to_parent</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipe_from_parent_to_child</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="s">"I'm child~!!"</span><span class="p">;</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"[Child] send mes: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
        <span class="n">write</span><span class="p">(</span><span class="n">pipe_from_child_to_parent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">msg</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

        <span class="n">read</span><span class="p">(</span><span class="n">pipe_from_parent_to_child</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[Child] recv msg: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

        <span class="n">close</span><span class="p">(</span><span class="n">pipe_from_child_to_parent</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipe_from_parent_to_child</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 사용하지 않는 fd 는 닫아줌.</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipe_from_child_to_parent</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipe_from_parent_to_child</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="s">"I'm parent~!!"</span><span class="p">;</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"[Parent] send mes: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
        <span class="n">write</span><span class="p">(</span><span class="n">pipe_from_parent_to_child</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">msg</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

        <span class="n">read</span><span class="p">(</span><span class="n">pipe_from_child_to_parent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[Parent] recv msg: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

        <span class="n">close</span><span class="p">(</span><span class="n">pipe_from_child_to_parent</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipe_from_parent_to_child</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>실행</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span> vim pipe.c
user@DESKTOP:~<span class="nv">$ </span> gcc <span class="nt">-o</span> pipe pipe.c
user@DESKTOP:~<span class="nv">$ </span> ./pipe
<span class="o">[</span>Parent] send mes: I<span class="s1">'m parent~!!
[Child] send mes: I'</span>m child~!!
<span class="o">[</span>Child] recv msg: I<span class="s1">'m parent~!!
[Parent] recv msg: I'</span>m child~!!
</code></pre></div></div>

<h3 id="2-파이프-명령어-구현">2. 파이프 명령어 구현</h3>

<p>리눅스에서 사요하는 파이프 기호 <code class="language-plaintext highlighter-rouge">|</code> 도 동일한 pipe IPC 를 사용한 기능이다. 따라서, 예를 들면 <code class="language-plaintext highlighter-rouge">cat /etc/passwd | wc -l</code> 을 pipe IPC 를 사용하여 프로그램으로 구현해볼 수 있다.</p>

<center>
  <img src="assets\img\posts\2024-03-19-IPC0202.png" width="600" />
</center>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span>
<span class="cm">/* cat /etc/passwd | wc -l */</span>

<span class="k">extern</span> <span class="kt">char</span><span class="o">**</span> <span class="n">environ</span><span class="p">;</span>

<span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">front_argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">"/bin/cat"</span><span class="p">,</span>
    <span class="s">"/etc/passwd"</span><span class="p">,</span>
    <span class="nb">NULL</span>
<span class="p">};</span>

<span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">back_argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">"/bin/wc"</span><span class="p">,</span>
    <span class="s">"-l"</span><span class="p">,</span>
    <span class="nb">NULL</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

    <span class="n">pipe</span><span class="p">(</span><span class="n">pipefd</span><span class="p">);</span>

    <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// 읽기 fd 사용 X</span>
        <span class="n">dup2</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">STDOUT_FILENO</span><span class="p">);</span> <span class="c1">// 쓰기 fd 를 표준출력 -&gt; 모든 표준출력은 쓰기 fd 로 전송됨</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>  <span class="c1">// 표준 출력 복제 후 닫음.</span>
        <span class="n">execve</span><span class="p">(</span><span class="n">front_argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">front_argv</span><span class="p">,</span> <span class="n">environ</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// 읽기 fd 사용 X</span>
        <span class="n">dup2</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">STDIN_FILENO</span><span class="p">);</span> <span class="c1">// 일기 fd 를 표준출력 -&gt; 읽기 fd 에서 읽ㅇ느 값을 표준입력으로 사용</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// 표준 입력 복제 후 닫음.</span>
        <span class="n">execve</span><span class="p">(</span><span class="n">back_argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">back_argv</span><span class="p">,</span> <span class="n">environ</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> 

    <span class="c1">// 부모프로세스에서의 fd 는 별개로 닫아야 함.</span>
    <span class="n">close</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// 읽기 fd 가 닫히면 2번째 프로세스의 표준 입력도</span>
    <span class="n">close</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// 닫히면서 2번째 프로세스도 종료됨.</span>

    <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>결과 확인</p>

<p>아래와 같이 해당 파일을 실행한 결과와  <code class="language-plaintext highlighter-rouge">cat /etc/passwd | wc -l</code> 의 실행 결과가 동일함을 확인할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>gcc <span class="nt">-o</span> pipe2 pipe2.c
user@DESKTOP:~<span class="nv">$ </span>./pipe2
27
user@DESKTOP:~<span class="nv">$ </span><span class="nb">cat</span> /etc/passwd | <span class="nb">wc</span> <span class="nt">-l</span>
27
</code></pre></div></div>

<h3 id="3-네임드-파이프">3. 네임드 파이프</h3>

<p>부모 자식간이 아닌 프로세스간 FIFO 파일의 경로를 알 수 있다면 통신이 가능하며, 이는 <code class="language-plaintext highlighter-rouge">mkfifo(fifo_file, mode)</code> 를 사용하여 수행 가능하다.</p>

<p>따라서, 앞에서 구현한 <code class="language-plaintext highlighter-rouge">cat /etc/passwd | wc -l</code> 를 독립적으로 수행하는 두개의 프로세스를 구현하고 이를 연결하여 사용가능하다. 해당 사항을 shell script 로 구현하면</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">mkfifo</span> <span class="nt">-m</span> 0600 fifo
<span class="nb">wc</span> <span class="nt">-l</span> &lt; fifo &amp;
<span class="nb">cat</span> /etc/passwd <span class="o">&gt;</span> fifo
<span class="nb">rm </span>fifo
</code></pre></div></div>

<p>실행결과</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">chmod</span> +x pipe3.sh
user@DESKTOP:~<span class="nv">$ </span>./pipe3.sh
27
user@DESKTOP:~<span class="nv">$ </span><span class="nb">cat</span> /etc/passwd | <span class="nb">wc</span> <span class="nt">-l</span>
27
</code></pre></div></div>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="IPC" /><category term="inter-process communication" /><category term="pipe" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 16]]></summary></entry><entry><title type="html">IPC 실습 01 - fork / execve</title><link href="http://localhost:4000/IPC01.html" rel="alternate" type="text/html" title="IPC 실습 01 - fork / execve" /><published>2024-03-18T10:32:20+09:00</published><updated>2024-03-18T10:32:20+09:00</updated><id>http://localhost:4000/IPC01</id><content type="html" xml:base="http://localhost:4000/IPC01.html"><![CDATA[<style>
    summary::-webkit-details-marker {
        display: none;
    }
    summary {
        list-style: none;
    }
</style>

<details><summary></summary>
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
</details>

<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) (https://comento.kr/)</p>

<h3 id="fork-를-사용한-자식-프로세스-생성-및-종료">fork 를 사용한 자식 프로세스 생성 및 종료</h3>

<p>아래와 같이 소스코드를 작성하여 자식 프로세스의 생애 주기 (생성 - 작업 - 좀비(작업완료) - 정리) 를 확인할 수 있는 코드를 작성한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">**</span><span class="n">environ</span><span class="p">;</span> <span class="c1">// 환경변수를 나타내는 전역 변수</span>

<span class="kt">char</span> <span class="n">ppid_str</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">ps_argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">"/bin/ps"</span><span class="p">,</span>
    <span class="s">"-fx"</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">run_ps</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 현재 작업 중인 시스템 프로세스 리스트를 확인하기 위한 자식 프로세스 생성 -- (b)</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Process list &gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">execve</span><span class="p">(</span><span class="n">ps_argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ps_argv</span><span class="p">,</span> <span class="n">environ</span><span class="p">);</span> <span class="c1">// execve 시스템 콜 실행 -- (c)</span>
    <span class="p">}</span>

    <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="cm">/*no option*/</span><span class="p">);</span>  
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// fork 프로세스 생애 주기를 보기 위해 순차적 작업 구현 -- (a)</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// c. 생성된 자식 프로세스의 작업</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[Child] pid-%d ppid-%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">getppid</span><span class="p">());</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 부모프로세스 </span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[Child] exit</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// c-1. 자식 프로세스 작업 종료</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span> <span class="c1">// p. 부모 프로세스</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[Parent] pid-%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
        <span class="n">run_ps</span><span class="p">();</span> <span class="c1">// p-1 작업 수행 </span>

        <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 자식 프로세스 작업 완료 대기</span>
        <span class="n">run_ps</span><span class="p">();</span> <span class="c1">// p-2 자식 프로세스 작업 완료 후 전체 시스템 프로세스 상태 확인</span>

        <span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="cm">/*no option*/</span><span class="p">);</span> <span class="c1">// p-3 자식 프로세스 작업 완료 대기 및 좀비 프로세스 정리 후</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[Parent] child exit: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">WEXITSTATUS</span><span class="p">(</span><span class="n">status</span><span class="p">));</span> <span class="c1">// 자식 프로세스 종료 상태 확인</span>

        <span class="n">run_ps</span><span class="p">();</span> <span class="c1">// p-4 (자식 프로세스를 완전히 제거한 이후) 프로세스 실행 상태 확인</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[Parent] exit</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="a-fork-프로세스-생애-주기를-보기-위해-순차적-작업-구현">a. fork 프로세스 생애 주기를 보기 위해 순차적 작업 구현</h4>

<p><code class="language-plaintext highlighter-rouge">pid = fork();</code> 를 수행하면 동일한 내용을 가진 부모 프로세스와 자식 프로세스가 생성된다. 다른 점은 해당 시스템콜 수행후 반환값 <code class="language-plaintext highlighter-rouge">pid</code> 는 자식프로세스는 0, 부모 프로세스는 자식 프로세스 PID 값을 가지게 된다.</p>

<p>따라서 그다음 조건문에서 각각의 프로세스 작업이 달라지게 되며, 각각의 작업은 동시에 수행되므로, 작업의 우선 순위를 확정할 수 없다. 여기서는 그 작업을 시간 순서대로 실행시켜서 그 생애 주기를 정확하게 확인하기 위해 필요한 구간에 각 프로세스에 <code class="language-plaintext highlighter-rouge">sleep()</code> 조건을 주어서 구현하였다.</p>

<p>그 작업 과정을 시간 순서대로 정리하면 아래와 같다.</p>

<ul>
  <li>부모/ 자식 프로세스 각각 pid 출력 (우선순위 없음)</li>
  <li>부모 p-1 : 자식 프로세스가 아직 실행 중인 상태에서 시스템 프로세스 리스트를 출력하는 작업 수행</li>
  <li>자식 c-1 : 자식 프로세스 내부 작업을 종료. 해당 프로세스는 반환 값(3) 을 가진 좀비 상태로 전환됨.</li>
  <li>부모 p-2 : 시스템 프로세스 리스트를 출력하는 작업 수행. 여기서 아직 자식 프로세스가 좀비(z) 상태로 남아있음을 볼 수 있다.</li>
  <li>부모 p-3 : 좀비 상태의 자식 프로세스를 정리하고, 자식 프로세스 반환값(3)을 확인.</li>
  <li>부모 p-4 : 마지막으로  시스템 프로세스 리스트에서 자식 프로세스가 사라짐을 확인.</li>
</ul>

<p>위 내용을 실제로 실행하여 그 결과를 확인하면 아래와 같다</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>gcc <span class="nt">-o</span> fork fork.c
user@DESKTOP:~<span class="nv">$ </span>./fork
<span class="o">[</span>Parent] pid-7653
Process list <span class="o">&gt;</span>
<span class="o">[</span>Child] pid-7654 ppid-7653
    PID TTY      STAT   TIME COMMAND
    437 pts/1    S+     0:00 <span class="nt">-bash</span>
    372 pts/0    Ss     0:00 <span class="nt">-bash</span>
   7653 pts/0    S+     0:00  <span class="se">\_</span> ./fork
   7654 pts/0    S+     0:00      <span class="se">\_</span> ./fork
   7655 pts/0    R+     0:00      <span class="se">\_</span> /bin/ps <span class="nt">-fx</span>
    431 ?        Ss     0:00 /lib/systemd/systemd <span class="nt">--user</span>
    432 ?        S      0:00  <span class="se">\_</span> <span class="o">(</span>sd-pam<span class="o">)</span>
<span class="o">[</span>Child] <span class="nb">exit
</span>Process list <span class="o">&gt;</span>
    PID TTY      STAT   TIME COMMAND
    437 pts/1    S+     0:00 <span class="nt">-bash</span>
    372 pts/0    Ss     0:00 <span class="nt">-bash</span>
   7653 pts/0    S+     0:00  <span class="se">\_</span> ./fork
   7654 pts/0    Z+     0:00      <span class="se">\_</span> <span class="o">[</span>fork] &lt;defunct&gt;
   7664 pts/0    R+     0:00      <span class="se">\_</span> /bin/ps <span class="nt">-fx</span>
    431 ?        Ss     0:00 /lib/systemd/systemd <span class="nt">--user</span>
    432 ?        S      0:00  <span class="se">\_</span> <span class="o">(</span>sd-pam<span class="o">)</span>
<span class="o">[</span>Parent] child <span class="nb">exit</span>: 3
Process list <span class="o">&gt;</span>
    PID TTY      STAT   TIME COMMAND
    437 pts/1    S+     0:00 <span class="nt">-bash</span>
    372 pts/0    Ss     0:00 <span class="nt">-bash</span>
   7653 pts/0    S+     0:00  <span class="se">\_</span> ./fork
   7665 pts/0    R+     0:00      <span class="se">\_</span> /bin/ps <span class="nt">-fx</span>
    431 ?        Ss     0:00 /lib/systemd/systemd <span class="nt">--user</span>
    432 ?        S      0:00  <span class="se">\_</span> <span class="o">(</span>sd-pam<span class="o">)</span>
<span class="o">[</span>Parent] <span class="nb">exit</span>
</code></pre></div></div>

<p>해당 출력중 아래에 해당하는 항목을 보면, 자식 프로세스 작업을 완료한 이후</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   7654 pts/0    Z+     0:00      <span class="se">\_</span> <span class="o">[</span>fork] &lt;defunct&gt;
</code></pre></div></div>

<p>state  는 좀비(z) 이며 <defunct> 처리된 것을 볼 수 있다.</defunct></p>

<h4 id="b-현재-작업-중인-시스템-프로세스-리스트를-확인하기-위한-자식-프로세스-생성">b. 현재 작업 중인 시스템 프로세스 리스트를 확인하기 위한 자식 프로세스 생성</h4>

<p><code class="language-plaintext highlighter-rouge">run_ps()</code> 는 현재 실행 중인 시스템 프로세스 목록을 출력하기 위한 명령어 <code class="language-plaintext highlighter-rouge">ps</code> 을 해당 명령어 파일로 실행 시키는 함수 이다.</p>

<p>해당 함수 내에서 실제로 ps 명령어를 실행하는 작업은 <code class="language-plaintext highlighter-rouge">fork</code> 하여 자식 프로세스가 작업하도록 구성되어 있으며, 해당 프로세스는 아래와 같이 출력됨을 확인 할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    7655 pts/0    R+     0:00      <span class="se">\_</span> /bin/ps <span class="nt">-fx</span>
</code></pre></div></div>

<h4 id="c-execve-시스템-콜-실행">c. execve 시스템 콜 실행</h4>

<p>` execve(ps_argv[0], ps_argv, environ)<code class="language-plaintext highlighter-rouge"> 시스템 콜이 자식 프로세스가 </code>ps` 명령어를 실행 시키는 부분이다.</p>

<p>해당 함수의 매개 변수를 보면 다음가 같다.</p>

<p>execve(filename, argv, env)</p>

<ul>
  <li>filename : 현재 프로세스에서 실행 시킬 파일</li>
  <li>argv : 실행 프로그램에 전달할 인자 배열. 배열 첫번째는 일반적으로 실행파일의 이름, 중간 인자들은 해당 프로그램 실행시 설정 옵션, 파라미터 들, 마지막은 NULL 로 종료를 의미한다.</li>
  <li>env(환경변수) : 실행 프로그램에게 전달되는 환경 변수 배열이며, 각 환경 변수는 “KEY=value” 형태의 문자열이며, 마지막 값은 NULL 이어야 한다. 다만, 환경변수는 프로세스가 실행될 때, 자체적으로 설정되며, 해당 변수를 <code class="language-plaintext highlighter-rouge">extern char **environ;</code> 선언으로 포인터로 지정해서 사용하게 된다.</li>
</ul>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="IPC" /><category term="inter-process communication" /><category term="fork" /><category term="execve" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 15]]></summary></entry><entry><title type="html">Device Driver 개발 3 (파일 특수 제어 (ioctl) 구현)</title><link href="http://localhost:4000/device_driver3.html" rel="alternate" type="text/html" title="Device Driver 개발 3 (파일 특수 제어 (ioctl) 구현)" /><published>2024-03-02T10:32:20+09:00</published><updated>2024-03-02T10:32:20+09:00</updated><id>http://localhost:4000/device_driver3</id><content type="html" xml:base="http://localhost:4000/device_driver3.html"><![CDATA[<style>
    summary::-webkit-details-marker {
        display: none;
    }
    summary {
        list-style: none;
    }
</style>

<details><summary></summary>
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
</details>

<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) (https://comento.kr/)</p>

<h3 id="1-파일-특수-제어-ioctl-이란">1. 파일 특수 제어 (ioctl) 이란?</h3>

<p>ioctl은 리눅스에서 주로 사용되는 시스템 콜 중 하나로, “Input/Output Control”의 약자이다. 단순 읽기/쓰기 외 디바이스 드라이버에 특정 명령을 전달하거나, 드라이버의 상태를 변경하거나, 내부 데이터를 얻기 위해 사용된다. 일반적인 파일 입출력 시스템 콜과는 달리, ioctl을 통해 디바이스 특화 명령을 수행할 수 있기 때문에, 다양한 종류의 하드웨어 디바이스와 상호작용하는 데 매우 유용하다.</p>

<p>unlocked_ioctl 함수 포인터 프로토타입 : <br />
<strong>long (*unlocked_ioctl)(struct file *file, unsigned int cmd, unsigned long arg);</strong></p>

<ul>
  <li>
    <p>struct file *file : <br />
현재 열린 파일(디바이스)을 나타내는 file 구조체에 대한 포인터. 이 구조체는 파일에 대한 중요한 정보를 담고 있으며, ioctl 호출 시 해당 디바이스 파일에 대한 참조를 제공.</p>
  </li>
  <li>
    <p>unsigned int cmd : <br />
디바이스 드라이버에 전달된 명령. user space에서 ioctl 함수를 호출할 때 지정한 명령 코드가 이 인자로 전달된다. 드라이버는 이 코드를 사용하여 어떤 작업을 수행할지 결정한다. 명령 코드는 보통 드라이버의 헤더 파일에 상수로 정의되어 있다.</p>

    <p>cmd 의 경우 일반적을 _IOR과 _IOW 매크로를 사용해서 정의 한다.</p>

    <ul>
      <li>_IO(type, nr): arg 없이 단순한 명령 매크로. type은 (디바이스 고유의) 명령 유형, nr 은 명령의 고유 번호를 의미</li>
      <li>_IOW(type, nr, size): arg 를 사용해서 user space 에 size 만큼의 데이터를 kernel 에 넘김.</li>
      <li>_IOR(type, nr, size): arg 를 사용해서 kernel 내에서 읽고, 해당 data 를 size 크기 만큼 가져옴.</li>
    </ul>

    <p>이를 사용하여 파일 읽기/쓰기와는 다른 디바이스의 상태, 구성, 또는 내부 정보 등을 읽거나 수정할 수 있다.</p>
  </li>
  <li>
    <p>unsigned long arg : <br />
명령에 대한 추가 데이터를 포함할 수 있는 사용자 공간의 포인터 또는 값. 명령의 성격에 따라 이 값은 주소 값일 수도 있고, 직접적인 데이터 값일 수도 있다. 드라이버는 이 값을 통해 필요한 추가 정보를 얻거나 사용자 공간으로 데이터를 전달할 수 있다.</p>
  </li>
</ul>

<p>unlocked_ioctl 함수는 성공 시 0 또는 양의 정수를, 실패 시 음의 에러 코드를 반환한다. 이 반환 값은 시스템 콜을 호출한 사용자 공간 프로세스에게 전달된다.</p>

<p>(unlocked_ioctl 대신 ioctl 함수 포인터를 사용하는 이유 중 하나는, unlocked_ioctl이 빅 커널 락(BKL, Big Kernel Lock)을 사용하지 않기 때문이다. 이는 더 나은 성능과 동시성을 제공하며, 현대의 멀티코어 시스템에서 중요한 특징이다. 따라서, 새로운 드라이버를 작성할 때는 unlocked_ioctl을 사용하는 것이 권장된다.)</p>

<h3 id="2-파일-특수-제어-ioctl-구현">2. 파일 특수 제어 (ioctl) 구현</h3>

<p>기존의 main.c 파일에 ioctl 관련 구현 내용을 추가해 준다. 해당 코드는 buffer 내용을 지우는 (clear) 하는 작업을 정의하였다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define COMENTO_MAGIC 'c'  // type ( ioctl 명령을 유일하게 식별하기 위한 문자)
#define COMENTO_IOCTL_CLEAR _IO(COMENTO_MAGIC, 0) // nr: 0 함수 내부 switch 문의 구분 번호
</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">comento_device_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">COMENTO_IOCTL_CLEAR</span><span class="p">:</span>
            <span class="n">memset</span><span class="p">(</span><span class="n">comento_device_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">COMENTO_BUF_SIZE</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="nl">default:</span>
            <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"%s failed - %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span> <span class="c1">// 정의되지 않은 값이 입력된 경우, "Invalid Argument" 오류 반환</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//...</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">comento_device_fops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">comento_device_ioctl</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>한편, <a href="https://y2gon2.github.io/device_driver2.html">이전 post - 파일 읽기/ 쓰기</a> 에서는 파일 읽기/쓰기 기능만 사용되므로, 기존의 읽기/쓰기 함수를 사용하여 구현하였다. 그러나 ioctl 은 사용자 정의 명령을 통해 특정 디바이스 드라이버와 상호작용해야 하므로, 이를 별도로 구현해 주어야 한다. 이와 관련하여 해당 내용은 다음과 같다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/ioctl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/limits.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="cp">#define COMENTO_DEVICE_NAME "comento" // 디바이스 파일명 
#define COMENTO_MAGIC 'c'
</span>
<span class="c1">// 디바이스에 대한 ioctl 명령을 정의, _IO 매크로를 사용하여 COMENTO_IOCTL_CLEAR 명령을 생성</span>
<span class="c1">// 해당 정의는 앞에 커널 모듈의 소스코드에서 정의한 것과 일치해야 한다.</span>
<span class="cp">#define COMENTO_IOCTL_CLEAR _IO(COMENTO_MAGIC, 0) 
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// open 함수를 사용하여 /dev/comento-device 디바이스 파일을 읽기/쓰기 모드(O_RDWR)로 염</span>
    <span class="c1">// 파일 디스크립터는 fd 변수에 저장</span>
    <span class="c1">// 파일 열기에 실패한 경우, 오류 메시지를 출력하고 프로그램을 종료</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/"</span> <span class="n">COMENTO_DEVICE_NAME</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to open device</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// ioctl(fd, COMENTO_DEVICE_IOCTL_CLEAR, 0) 해당 호출을 통해 </span>
    <span class="c1">// 시스템 콜을 통해 커널 공간으로 전달되고, 커널은 등록된 디바이스 드라이버의 ioctl 처리 함수 </span>
    <span class="c1">// 'comento_device_ioctl' - case COMENTO_DEVICE_IOCTL_CLEAR 이 실행되게 된다. </span>
    <span class="c1">// 파일 디스크립터는 fd 변수에 저장되며, 파일 열기에 실패한 경우, </span>
    <span class="c1">// 오류 메시지를 출력하고 프로그램을 종료합니다.</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">COMENTO_IOCTL_CLEAR</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to do ioctl command</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="3-구현-작업">3. 구현 작업</h3>

<p>main.c 을 열어 위 소스 코드 추가</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span>vim drivers/comento/main.c
</code></pre></div></div>

<p>소스 코드 빌드</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 <span class="nv">CROSS_COMPILE</span><span class="o">=</span>/home/gon/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu- make
  CALL    scripts/checksyscalls.sh
  CC <span class="o">[</span>M]  drivers/comento/main.o
  LD <span class="o">[</span>M]  drivers/comento/comento.o
  MODPOST Module.symvers
  LD <span class="o">[</span>M]  drivers/comento/comento.ko
</code></pre></div></div>

<p>빌드된 커널 모듈을 이미지내 삽입</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo </span>mount <span class="nt">-o</span> loop ../buildroot/output/images/rootfs.ext4 /mnt
user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo cp </span>drivers/comento/comento.ko /mnt/usr/lib/modules/.
</code></pre></div></div>

<p>사용자 프로그램 생성 (위 작성 코드 내용 사용)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">cd</span> ..
user@DESKTOP:~<span class="nv">$ </span>vim ioctl.c
</code></pre></div></div>

<p>toolchain 을 사용하여 사용자 프로그램 빌드</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-gcc <span class="nt">-o</span> ioctl ioctl.c
</code></pre></div></div>

<p>사용자 프로그램 이미지 내 추가</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">sudo cp </span>ioctl /mnt/usr/bin
user@DESKTOP:~<span class="nv">$ </span><span class="nb">sync
</span>user@DESKTOP:~<span class="nv">$ </span><span class="nb">sudo </span>umount /mnt
</code></pre></div></div>

<p>QEMU 실행</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>qemu-system-aarch64 <span class="nt">-kernel</span> linux/arch/arm64/boot/Image <span class="nt">-drive</span> <span class="nv">format</span><span class="o">=</span>raw,file<span class="o">=</span>buildroot/output/images/rootfs.ext4,if<span class="o">=</span>virtio <span class="nt">-append</span> <span class="s2">"root=/dev/vda console=ttyAMA0 nokaslr"</span> <span class="nt">-nographic</span> <span class="nt">-M</span> virt <span class="nt">-cpu</span> cortex-a72 <span class="nt">-m</span> 2G <span class="nt">-smp</span> 2
</code></pre></div></div>

<h3 id="4-ioclt-사용">4. ioclt 사용</h3>

<p>모듈 삽입 및 드라이버 노드 파일 생성</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># insmod /usr/lib/modules/comento.ko
# cd /dev/
# mkmod /dev/comento c 177 34
# ls -lah comento
crw-r--r--    1 root     root      177,  34 Mar  2 07:12 comento
</code></pre></div></div>

<p>node file buffer 문자열 넣기 및 확인</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># echo "hello~~!!" &gt; /dev/comento
# cat /dev/comento
hello~~!!
</code></pre></div></div>

<p>사용자 프로그램(ioctl) 을 실행하여 buffer 초기화 (clear) 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># ioctl
# cat /dev/comento
(출력 내용 없음)
</code></pre></div></div>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="device driver" /><category term="device node" /><category term="ioctl" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 13]]></summary></entry><entry><title type="html">udev 와 연동하기</title><link href="http://localhost:4000/udev1.html" rel="alternate" type="text/html" title="udev 와 연동하기" /><published>2024-03-02T10:32:20+09:00</published><updated>2024-03-02T10:32:20+09:00</updated><id>http://localhost:4000/udev1</id><content type="html" xml:base="http://localhost:4000/udev1.html"><![CDATA[<style>
    summary::-webkit-details-marker {
        display: none;
    }
    summary {
        list-style: none;
    }
</style>

<details><summary></summary>
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
</details>

<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) (https://comento.kr/)</p>

<h3 id="1-udev-란">1. udev 란?</h3>

<p>리눅스 시스템에서 장치 관리를 담당하는 사용자 공간의 데몬. 이는 커널에서 장치 이벤트를 수신하고, 이를 기반으로 장치 파일을 동적으로 생성하거나 삭제하며, 장치에 대한 규칙을 처리하는 역할을 한다. udev의 주요 목적은 시스템이 실행 중일 때 장치를 관리하고, 장치 간의 일관된 명명 규칙을 유지하며, 사용자가 정의한 규칙에 따라 장치에 대한 추가적인 설정을 자동으로 적용하는 것이다.</p>

<p>주요 기능</p>

<ol>
  <li>
    <p>동적 장치 관리: udev는 USB 드라이브나 네트워크 어댑터 같은 하드웨어 장치가 시스템에 추가되거나 제거될 때, 해당 변화를 감지하고 반응한다. 이를 통해, 시스템은 실행 중에도 장치의 추가 및 제거를 실시간으로 처리할 수 있다. 특히 해당 경우는, 미리 앞에서 학습한 방법(major 번호를 미리 입력)으로 처리할 수 없다. (ex. USB 인식)</p>
  </li>
  <li>
    <p>장치 파일 생성 및 삭제: 장치가 시스템에 연결될 때, udev는 /dev 디렉토리에 해당 장치를 대표하는 장치 파일(또는 노드)을 생성합니다. 장치가 제거되면, 해당 파일도 삭제됩니다. 이 과정은 자동으로 수행되어 사용자나 시스템 관리자가 수동으로 장치 파일을 관리할 필요가 없습니다.</p>
  </li>
  <li>
    <p>규칙 기반 장치 관리: udev는 /etc/udev/rules.d와 같은 디렉토리에 저장된 규칙 파일을 사용하여 장치에 대한 세부적인 관리를 수행합니다. 이 규칙들은 장치의 명명, 권한 설정, 장치에 대한 사용자 정의 액션 실행 등을 정의할 수 있습니다.</p>
  </li>
  <li>
    <p>장치 정보 제공: udev는 연결된 장치에 대한 상세한 메타데이터를 제공합니다. 이 정보는 시스템이 장치를 정확히 식별하고, 적절한 드라이버를 로드하며, 사용자 정의 규칙을 적용하는 데 사용됩니다.</p>
  </li>
  <li>
    <p>사용자 정의 액션: 사용자는 udev 규칙을 통해 특정 장치에 대해 특정 이벤트가 발생했을 때 실행할 명령이나 스크립트를 지정할 수 있습니다. 이를 통해 장치가 시스템에 연결될 때 자동으로 필요한 설정을 적용하거나, 필요한 서비스를 시작할 수 있습니다.</p>
  </li>
</ol>

<p>장치 인식 process</p>

<p>새로운 디바이스가 인식되면,</p>

<ol>
  <li>커널이 uevent 를 발생시켜서 udev 데몬에게 이를 알림</li>
  <li>udev 데몬은 /sys 를 확인하여 디바이스에 대한 정보를 알아냄
    <ul>
      <li>커널이 /sys/devices 와 /sys/class 에 새로운 디바이스에 대한 디렉토리를 생성</li>
      <li>디렉토리 내의 dev 파일을 읽으면 주번호와 부번호를 알 수 있음.</li>
    </ul>
  </li>
  <li>udev 데몬은 알아낸 정보를 바탕으로 새로운 디바이스 노드를 /dev 에 생성</li>
</ol>

<h3 id="2-device-class">2. device class</h3>

<p>리눅스 커널의 디바이스 모델에서 “디바이스 클래스(Device Class)”는 시스템 내의 디바이스들을 분류하는 방법 중 하나. 유사한 기능이나 목적을 가진 디바이스들을 그룹화하여 관리</p>

<p>예를 들면,</p>
<ul>
  <li>input 클래스 : 키보드, 마우스 등의 입력 장치를 포함</li>
  <li>net 클래스 : 네트워크 인터페이스 카드(NICs)와 같은 네트워킹 장치를 포함</li>
</ul>

<p>디바이스 클래스 기능</p>

<ol>
  <li>
    <p>통합된 관리: 디바이스 클래스는 특정 유형의 디바이스들(예: 입력 디바이스, 네트워크 인터페이스, 오디오 장치 등)을 묶어서 일관된 방식으로 시스템 내에서 작동할 수 있도록 관리.</p>
  </li>
  <li>
    <p>자동 디바이스 파일 생성: /dev 디렉토리에 있는 디바이스 파일들은 사용자 공간의 애플리케이션이 커널의 디바이스 드라이버와 통신하는 인터페이스를 제공한다. 클래스 시스템을 사용하면, 새로운 디바이스가 시스템에 추가될 때 자동으로 해당 디바이스 파일이 생성된다.</p>
  </li>
  <li>
    <p>시스템의 가시성 및 접근성 향상: /sys/class 내에는 각 디바이스 클래스에 대한 디렉토리가 있으며 (ex. input, mem, pci_bus, net, tty ..), 이는 디바이스에 대한 메타데이터와 상태 정보를 제공한다. 이 정보를 통해 사용자나 애플리케이션은 디바이스의 현재 상태를 쉽게 파악할 수 있다.</p>
  </li>
  <li>
    <p>표준화된 인터페이스 제공: 디바이스 클래스는 개발자들에게 표준화된 프로그래밍 인터페이스를 제공한다. 이를 통해 개발자는 특정 클래스에 속하는 모든 디바이스들과 일관된 방식으로 상호작용할 수 있게 된다.</p>
  </li>
</ol>

<h3 id="3-디바이스-생성을-udev-에게-알리기">3. 디바이스 생성을 udev 에게 알리기</h3>

<ol>
  <li>class_create(owner, name): /sys/class 에 새로운 디바이스 클래스 생성
    <ul>
      <li>owner : 어떤 모듈에 속해 있는가를 나타냄 (자체 모듈인 경우 <code class="language-plaintext highlighter-rouge">THIS_MODULE</code> 로 지정)</li>
    </ul>
  </li>
  <li>device_create(class, parent, dev_no, data, name): 새로운 디바이스 생성 (/dev)
    <ul>
      <li>parent : 부모 디바이스 (일반적으로 버스 디바이스) 를 나타내며 NULL 로 지정 가능</li>
      <li>dev_no : <code class="language-plaintext highlighter-rouge">MKDEV(major, minor)</code> 매크로를 사용하여 주번호, 부번호 명시. (MKDEV 매크로는 주/부번호를 하나의 디바이스 번호로 결합항 디바이스 파일 고유 식별자 역할을 함.)</li>
      <li>data   : 디바이스와 관련된 데이터를 지정</li>
      <li>name   : 디바이스의 이름을 지정. printf 함수에서 사용하는 것과 유사하게, 문자열과 숫자를 조합하여 디바이스 이름을 생성할 수 있다. (ex. <code class="language-plaintext highlighter-rouge">"%s%d", DEVICE_NAME, minor</code>) <br /><br /></li>
    </ul>

    <p>-&gt; /sys/devices/ 에 새로운 디렉토리와 dev 파일 생성</p>
  </li>
</ol>

<h3 id="4-드라이브-노드-소스코드-작성">4. 드라이브 노드 소스코드 작성</h3>

<p>기존 /linux/drivers/comento/main.c 파일의 <code class="language-plaintext highlighter-rouge">init</code> 함수 내용을 수정한다.</p>

<p>아래 첫번째 코드는 udev 를 사용하는 해당 함수의 정식적 구조를 따라 작성된 것이며, 그 아래 코드는 해당 포스트 실습에서 사용한 간략화된 코드 이다.</p>

<ul>
  <li>일반적 구조 구현 코드
```c
#include &lt;linux/device.h&gt;
#include &lt;linux/fs.h&gt;</li>
</ul>

<p>#define COMENTO_DEVICE_NAME “comento-device”
#define COMENTO_CLASS_NAME “comento”</p>

<p>static struct file_operations comento_device_fops;</p>

<p>static int comento_device_major;
static struct class *comento_class;
static struct device *comento_device;</p>

<p>static int __init comento_module_init(void) {
    int minor = 0;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>comento_device_major = register_chardev(
    0, 
    COMENTO_DEVICE_NAME, 
    &amp;comento_device_fops
    );

if(comento_device_major &lt; 0) {
    printk(KENR_ERR "%s: Failed to get major number", COMENTO_DEVICE_NAME);
    ret = comento_device_major;
    goto err_register_chrdev;
}

comento_class = class_create(THIS_MODULE, COMENTO_CLASS_NAME);

// 반환값이 error 인지 확인 
if(IS_ERR(comento_class)) {
    printk(KERN_ERR "%s: Failed to create class", COMENTO_DEVICE_NAME);
    ret = PTR_ERR(comento_class);
    goto err_class;
    // goto 문의 사용은 일반적으로 anti-pattern 이지만, 
    // 예외적으로 어떤 자원의 획득과 해제 관련(해당의 경우) 자주 사용됨. 
}

comento_device = device_create(
    comento_class, 
    NULL, 
    MKDEV(comento_device_major, minor), 
    NULL,
    "%s%d",
    COMENTO_DEVICE_NAME,
    minor
    );

if (IS_ERR(comento_device[minor])) {
    ret = PTR_ERR(comento_device[minor]);
    goto err_device;
}

// error 발생시 class 해제  device 등록 해제 
err_device: class_destroy(comento_class);
err_class: unregister_chrdev(comento_device_major, COMENTO_DEVICE_NAME);
err_register_chrdev: 

return ret; }
</code></pre></div></div>

<p>module_init(comento_module_init);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
* 실습 구현 코드
```c
...
#include &lt;linux/spinlock.h&gt;

// 기존 device name, major number 설정값 삭제
// #define COMENTO_DEVICE_NAME "comento-device"
// #define COMENTO_MAJOR_NUMBER 177
#define COMENTO_BUF_SIZE 16
...

// 현재 코드에서 구현하지 않았지만 일반적으로 exit 할 때, 
// class / device 모두 destroy 처리해준다. 
// 이 때 goto 문 이용하기도 하므로 이런 이유로 전역 변수로 선언해준다. 
static struct class* class;
static struct device* device;

static int __init comento_module_init(void)
{
    printk(KERN_DEBUG "%s\n", __func__);

    // udev 를 통해서 major 번호를 자동 부여받을 것이브로 0 (자동 지정) 으로 설정
    int major = register_chrdev(0, "comento", &amp;fops); 
    int minor = 17; // 임의의 숫자 부여

    // THIS_MODULE : 이 모듈이 클래스의 주인 (owner)임을 명시. (최신 코드에서는 명시하지 않음?)
    // owner의 의미 : 이 모듈이 사라졌을 때, class destroy 를 따라하지 않는다고 하더라도
    //               해당 클래스는 알아서 사라지게 된다. 이유는 owner 인 `THIS_MODULE` 이 사라졌기 때문이다.
    //               그래도 일반적으로 exit 할 때, 해당 클래스를 destroy 해준다.
    class = class_create("comento");

    // 부모 디바이스, data 는 NULL
    // name : printf 함수에서 사용하는 것과 유사하게, 문자열과 숫자를 조합하여 디바이스 이름을 생성
    device = device_create(class, NULL, MKDEV(major, minor), NULL, "%s%d", "comento", minor);

    return 0; // 자동 지정 이므로 0 으로 설정
}
...
</code></pre></div></div>

<p>빌드 &amp; ko 파일 rootfs 이미지 내 추가, QEMU 실행</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 <span class="nv">CROSS_COMPILE</span><span class="o">=</span>/home/gon/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu- make
ch64-none-linux-gnu/bin/aarch64-none-linux-gnu- make
  CALL    scripts/checksyscalls.sh
  CC <span class="o">[</span>M]  drivers/comento/main.o
  LD <span class="o">[</span>M]  drivers/comento/comento.o
  MODPOST Module.symvers
  LD <span class="o">[</span>M]  drivers/comento/comento.ko
user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo </span>mount <span class="nt">-o</span> loop buildroot/output/images/rootfs.ext4 /mnt
user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo cp </span>drivers/comento/comento.ko /mnt/usr/lib/modules/.
user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sync 
</span>user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo </span>umount /mnt
user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">cd</span> ..
user@DESKTOP:~<span class="nv">$ </span>qemu-system-aarch64 <span class="nt">-kernel</span> linux/arch/arm64/boot/Image <span class="nt">-drive</span> <span class="nv">format</span><span class="o">=</span>raw,file<span class="o">=</span>buildroot/output/images/rootfs.ext4,if<span class="o">=</span>virtio <span class="nt">-append</span> <span class="s2">"root=/dev/vda console=ttyAMA0 nokaslr"</span> <span class="nt">-nographic</span> <span class="nt">-M</span> virt <span class="nt">-cpu</span> cortex-a72 <span class="nt">-m</span> 2G <span class="nt">-smp</span> 2
</code></pre></div></div>

<h3 id="5-커널-모듈-삽입-및-실행">5. 커널 모듈 삽입 및 실행</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># cd /sys/class
# ls
ata_device    drm           misc          scsi_device   tty
ata_link      graphics      net           scsi_disk     vc
ata_port      hwmon         pci_bus       scsi_generic  virtio-ports
bdi           i2c-adapter   power_supply  scsi_host     vtconsole
block         input         pps           thermal       wakeup
bsg           iommu         ptp           tpm
devlink       mem           rtc           tpmrm
</code></pre></div></div>

<p>위와 같이  /sys/class 에 들어가면 기존 class 디렉토리들이 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># insmod /usr/lib/modules/comento.ko
# ls
ata_device    devlink       mem           rtc           tpmrm
ata_link      drm           misc          scsi_device   tty
ata_port      graphics      net           scsi_disk     vc
bdi           hwmon         pci_bus       scsi_generic  virtio-ports
block         i2c-adapter   power_supply  scsi_host     vtconsole
bsg           input         pps           thermal       wakeup
comento       iommu         ptp           tpm
# cd comento
# ls -lah
total 0
drwxr-xr-x    2 root     root           0 Mar  3 08:48 .
drwxr-xr-x   36 root     root           0 Mar  3 08:46 ..
lrwxrwxrwx    1 root     root           0 Mar  3 08:53 comento17 -&gt; ../../devices/virtual/comento/comento17
</code></pre></div></div>

<p>comento 커널 모듈을 삽입해주면 comento 디렉토리가 추가된것을 확인할 수 있으며, 해당 디렉토리 안에 코드에서 명명한 대로 comento17 (minor 번호 추가) 디바이스가 생성된 것을 볼 수 있다. 해당 파일을 symbolic link 실제 파일은 /sys/devices/virtual/coment/comento17 에 존재함을 알 수 있다 해당 경로로 다시 가보면,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># cd /sys/devices/virtual/comento/comento17
# ls -lah
total 0
drwxr-xr-x    3 root     root           0 Mar  3 08:53 .
drwxr-xr-x    3 root     root           0 Mar  3 08:53 ..
-r--r--r--    1 root     root        4.0K Mar  3 08:59 dev
drwxr-xr-x    2 root     root           0 Mar  3 08:59 power
lrwxrwxrwx    1 root     root           0 Mar  3 08:59 subsystem -&gt; ../../../../class/comento
-rw-r--r--    1 root     root        4.0K Mar  3 08:59 uevent
</code></pre></div></div>

<p>여기에 dev 파일이 존재한다. 그 내용을 출력해보면</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># cat dev
248:17
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">주번호:부번호</code> 를 볼 수 있다. 주번호 값은 udev 데몬 가 할당한 임의의 번호임도 확인 된다. 
주번호, 부번호는  /dev/coment 내 존재하는 드라이버 노드 정보로도 확인 가능하다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># ls -lah /dev/comento*
crw-------    1 root     root      248,  17 Mar  3 08:48 /dev/comento17
</code></pre></div></div>

<p>앞에서 확인한 내용과 udev 를 사용하여 어떻게 디바이스 파일이 생성되는지 과정을 정리하면 아래와 같다.</p>

<ol>
  <li>
    <p>커널 모듈을 삽입 (insmod): 해당 모듈을 커널에 로드</p>
  </li>
  <li>
    <p>uevent 발생: 시스템에 새로운 하드웨어가 추가되었거나, 새로운 드라이버가 로드되었음을 알림</p>
  </li>
  <li>
    <p>udev class 생성 (/sys/class/): 커널 모듈(또는 드라이버) 내에서 class_create() 함수를 호출하여 디바이스 클래스를 생성하고, 이 정보는 /sys/class/에 반영</p>
  </li>
  <li>
    <p>udev는 앞에서 생성한 정보를 바탕으로 작업을 수행</p>
  </li>
  <li>
    <p>주번호 및 디바이스 생성 (/sys/device/): 커널에 의해 주번호가 생성되며, 커널 모듈이나 드라이버는 디바이스 파일에 대한 메이저 번호와 마이너 번호를 할당받아 사용. /sys/devices/는 실제 장치와 그 속성을 반영하는 커널의 디바이스 트리를 나타내며, 여기서 디바이스는 커널이나 모듈에 의해 등록됨.</p>
  </li>
  <li>
    <p>드라이버 생성 (/dev/): /dev/ 디렉토리에 디바이스 파일이 생성됨. 이 과정은 udev에 의해 자동으로 처리되며, /dev/ 내의 디바이스 파일은 사용자 공간에서 해당 디바이스에 접근하기 위한 인터페이스를 제공. udev 규칙에 따라 디바이스 파일의 이름, 권한 등이 설정.</p>
  </li>
</ol>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="device driver" /><category term="udev" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 14]]></summary></entry><entry><title type="html">Device Driver 개발 2 (파일 읽기/ 쓰기)</title><link href="http://localhost:4000/device_driver2.html" rel="alternate" type="text/html" title="Device Driver 개발 2 (파일 읽기/ 쓰기)" /><published>2024-03-01T10:32:20+09:00</published><updated>2024-03-01T10:32:20+09:00</updated><id>http://localhost:4000/device_driver2</id><content type="html" xml:base="http://localhost:4000/device_driver2.html"><![CDATA[<style>
    summary::-webkit-details-marker {
        display: none;
    }
    summary {
        list-style: none;
    }
</style>

<details><summary></summary>
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
</details>

<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) (https://comento.kr/)</p>

<h3 id="1-파일-읽기-쓰기-구현">1. 파일 읽기/ 쓰기 구현</h3>

<p>1.1 ssize_t type</p>

<p>리눅스 드라이버에서 <code class="language-plaintext highlighter-rouge">ssize_t</code> 타입은 일반적으로 데이터의 크기나 양을 나타내는 데 사용되며, 부호 있는 64비트(시스템에 따라 다를 수 있음) 정수를 의미한다. <code class="language-plaintext highlighter-rouge">ssize_t</code>는 시스템 호출이나 함수들이 실패할 경우 음수 값을 반환할 수 있게 하며, 성공적인 경우에는 양의 값을 반환한다. 이는 주로 파일이나 소켓의 읽기 및 쓰기 연산에서 반환 타입으로 사용된다.</p>

<p>리눅스 커널 모듈에서 파일 또는 장치 드라이버의 읽기 및 쓰기 연산을 구현할 때, read와 write 시스템 호출에 대응하는 함수 포인터를 file_operations 구조체에 설정하고 <code class="language-plaintext highlighter-rouge">ssize_t</code> 를 반환 타입으로 설정한다.</p>

<ul>
  <li>ssize_t(*read)(file, buf, len, ppos) : 파일 읽기 함수 callback</li>
  <li>
    <p>ssize_t(*write)(file, buf, len, ppos) : 파일 쓰기 함수  callback</p>
  </li>
  <li>
    <p>file (<code class="language-plaintext highlighter-rouge">struct file *</code>) : 읽기/쓰기 연산을 수행할 파일에 대한 포인터. struct file은 열린 파일의 상태를 나타내며, 파일의 현재 위치(offset) 같은 정보를 포함한다. 이 구조체를 통해 커널은 어떤 파일에 대한 작업을 수행하고 있는지 알 수 있다.</p>
  </li>
  <li>
    <p>buf (<code class="language-plaintext highlighter-rouge">char __user *</code>) : user space 의 버퍼 주소를 가리키는 포인터. 커널은 데이터를 읽어 user mode process 가 접근한 memory 에 전달할 때, <code class="language-plaintext highlighter-rouge">__user</code>  포인터가 가리키는 위치부터 버퍼 공간을 확보.</p>
  </li>
  <li>
    <p>len (<code class="language-plaintext highlighter-rouge">size_t</code>) : 버퍼의 크기. ‘__user’ 포인터 위치로부터 해당 크기만큼의 buffer 를 user space 에 확보하여 data 을 옮기 수 있게 한다.</p>
  </li>
  <li>ppos (<code class="language-plaintext highlighter-rouge">loff_t *</code>) : 파일 내의 현재 위치(offset)를 나타내는 포인터. loff_t 타입은 대용량 파일 지원을 위해 사용되며, 파일의 어느 부분에서 데이터를 읽을지 결정한다. 함수 호출이 성공하면, 이 위치는 읽은 바이트 수만큼 증가한다. 따라서 파일로부터 원하는 부분에 대한 data 를 읽기 위해서 이에 대한 ppos 의  수정/갱신이 필요하다.</li>
</ul>

<p>데이터의 이동이 kernel space 와 user space 간 이루짐으로 일반적인 <code class="language-plaintext highlighter-rouge">memcpy</code> 는 사용할 수 없으며, <code class="language-plaintext highlighter-rouge">copy_from_user</code> / <code class="language-plaintext highlighter-rouge">copy_to_user</code> 를 사용하여 데이터 복사를 진행해야 한다.</p>

<p>1.2 source 코드 작성 및 빌드</p>

<p>기존에 작성한 <a href="https://y2gon2.github.io/kernelmodule01.html">Kernel Module 만들기 1 참조</a> <code class="language-plaintext highlighter-rouge">main.c</code> 파일을 읽기/쓰기 함수를 추가한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span>vim drivers/comento/main.c
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/device.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/spinlock.h&gt;</span><span class="cp">
</span>
<span class="cp">#define COMENTO_DEVICE_NAME "comento-device"
#define COMENTO_MAJOR_NUMBER 177 
#define COMENTO_BUF_SIZE 16
</span>
<span class="k">static</span> <span class="nf">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">comento_device_rwlock</span><span class="p">);</span>  <span class="c1">// * rwlock 관련</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">comento_device_buf</span><span class="p">[</span><span class="n">COMENTO_BUF_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="p">};</span> 
<span class="c1">// 이 버퍼는 커널 모듈의 일부로서, 커널 모듈이 로드될 때 커널의 메모리 영역에 할당되고, </span>
<span class="c1">// 모듈이 언로드될 때 해제된다. </span>


<span class="c1">// char __user *buf : __user attribute (생략 가능하지만 가독성/명확성을 위해 사용)</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">comento_device_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">ssize_t</span> <span class="n">written_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">comento_device_rwlock</span><span class="p">);</span>  <span class="c1">// * rwlock : read 용 lock 얻기</span>
    
    <span class="c1">// 데이터를 읽거나 쓸 때, 요청된 작업이 디바이스 또는 버퍼의 실제 크기를 넘어서지 않도록 보장</span>
    <span class="c1">// 현재는 *ppos 16 을 넘어가면 실제로 읽지 못하는 상태임 (?)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">COMENTO_BUF_SIZE</span> <span class="o">&lt;=</span> <span class="n">len</span> <span class="o">+</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">COMENTO_BUF_SIZE</span> <span class="o">-</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 실제로 복사된 bytes = 사용자가 요청한 복사 길이 bytes - 실패하거나 복사되지 않은 bytes 수를 반환</span>
    <span class="c1">// copy_to_user(목적지 space, 출발지 pointer, 복사 요청 길이 ) : 출발지 pointer 의 경우 ppos(offset) 고려해야</span>
    <span class="n">written_bytes</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">comento_device_buf</span> <span class="o">+</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">written_bytes</span><span class="p">;</span> <span class="c1">// offset 값 갱신</span>

    <span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">comento_device_rwlock</span><span class="p">);</span>  <span class="c1">// * rwlock : read 완료 후 unlock</span>

    <span class="k">return</span> <span class="n">written_bytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// const char __user *buf : 쓰기의 경우 kernel 에서 user space data 를 읽기만 한다. </span>
<span class="c1">// kernel 이 해당 주소를 임의로 수정할 필요가 없으므로 const 로 고정시켜 안정성을 높인다.</span>
<span class="c1">// const 로 미 선언시 error 또는 warning 발생</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">comento_device_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">read_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">comento_device_rwlock</span><span class="p">);</span> <span class="c1">// * rwlock : write 용 lock 얻기</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">COMENTO_BUF_SIZE</span> <span class="o">&lt;=</span> <span class="n">len</span> <span class="o">+</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">COMENTO_BUF_SIZE</span> <span class="o">-</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// copy_from_user(목적지 space, 출발지 pointer, 복사 요청 길이 ) </span>
    <span class="n">read_bytes</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">comento_device_buf</span> <span class="o">+</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">read_bytes</span><span class="p">;</span> <span class="c1">// offset 값 갱신</span>
    
    <span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">comento_device_rwlock</span><span class="p">);</span>  <span class="c1">// * rwlock : write 완료 후 unlock</span>
    <span class="k">return</span> <span class="n">read_bytes</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">comento_device_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">iminor</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"%s - minor : %d/n"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">minor</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">file_operations</span> <span class="n">fops</span><span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">comento_device_open</span><span class="p">,</span> 
    <span class="c1">// .open 생략시 open 되었다고 가정하고 시스템에서 에러를 발생시키지 않음.</span>
    <span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">comento_device_read</span><span class="p">,</span>
    <span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">comento_device_write</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">comento_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">register_chrdev</span><span class="p">(</span><span class="mi">177</span><span class="p">,</span> <span class="s">"comento"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fops</span><span class="p">);</span> 
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">comento_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">unregister_chrdev</span><span class="p">(</span><span class="mi">177</span><span class="p">,</span> <span class="s">"comento"</span><span class="p">);</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">comento_module_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">comento_module_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">"Hello&lt;hello@comento.com&gt;"</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">"Example module"</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL v2"</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="2-파일-빌드-추가-qemu-실행">2. 파일 빌드, 추가, QEMU 실행</h3>

<p>파일 빌드 및 ko 파일 생성</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 <span class="nv">CROSS_COMPILE</span><span class="o">=</span>/home/gon/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu- make
  CALL    scripts/checksyscalls.sh
  CC <span class="o">[</span>M]  drivers/comento/main.o
  LD <span class="o">[</span>M]  drivers/comento/comento.o
  MODPOST Module.symvers
  LD <span class="o">[</span>M]  drivers/comento/comento.ko
</code></pre></div></div>

<p>ko 파일 rootfs 이미지에 복사</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo </span>mount <span class="nt">-o</span> loop ../buildroot/output/images/rootfs.ext4 /mnt
user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo cp </span>drivers/comento/comento.ko /mnt/usr/lib/modules/.
user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sync
</span>user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo </span>umount /mnt
</code></pre></div></div>

<p>QEMU 실행</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">cd</span> ..
user@DESKTOP:~<span class="nv">$ </span>qemu-system-aarch64 <span class="nt">-kernel</span> linux/arch/arm64/boot/Image <span class="nt">-drive</span> <span class="nv">format</span><span class="o">=</span>raw,file<span class="o">=</span>buildroot/output/images/rootfs.ext4,if<span class="o">=</span>virtio <span class="nt">-append</span> <span class="s2">"root=/dev/vda console=ttyAMA0 nokaslr"</span> <span class="nt">-nographic</span> <span class="nt">-M</span> virt <span class="nt">-cpu</span> cortex-a72 <span class="nt">-m</span> 2G <span class="nt">-smp</span> 2
</code></pre></div></div>

<h3 id="3-파일-읽기-쓰기-사용">3. 파일 읽기, 쓰기 사용</h3>

<p>드라이버 모듈 삽입 및 확인</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># insmod /usr/lib/modules/comento.ko
# dmesg
...
comento_module_init
# cd /dev
# ls -lah comento
crw-r--r--    1 root     root      177,  34 Mar  1 05:50 comento
</code></pre></div></div>

<p>dev 디렉토리 내 디바이스 노드 생성</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># mknod /dev/comento c 177 34
</code></pre></div></div>

<p>값 넣어보기</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># echo "wow" &gt; /dev/comento
# cat /dev/comento
wow
</code></pre></div></div>

<p>추가된 comento 디바이스 노드에 “wow” 문자열을 redirection 하고, 해당 디바이스 노드 내용을 출력하면  redirect 된 값이 그대로 출력됨을 확인할 수 있다.</p>

<p>이는 앞에서 구현한 소스코드 중 <code class="language-plaintext highlighter-rouge">comento_device_write</code> 함수가 실행되어, user space 에서 작성한 문자열이 <code class="language-plaintext highlighter-rouge">copy_from_user</code> 를 사용하여 kernel space memory (<code class="language-plaintext highlighter-rouge">comento_device_buf</code>)에 쓰기가 되었음을 의미한다.</p>

<p>cat 명령을 사용하면, 해당 디바이스 노드의 버퍼 공간 내용을 읽어 온다. 즉 앞에서 구현한 <code class="language-plaintext highlighter-rouge">comento_device_read</code> 함수를 실행하여 <code class="language-plaintext highlighter-rouge">copy_to_user</code> 로 <code class="language-plaintext highlighter-rouge">comento_device_buf</code> 에 저장된 문자열을 표준 출력으로 제공하게 되는 것이다.</p>

<h3 id="4-strace-를-사용한-읽기-과정-관찰">4. strace 를 사용한 읽기 과정 관찰</h3>

<p>strace 를 사용하기 위해 커널을 빠져 나온 이후, 임의 파일을 생성하고 이를 strace 를 사용하여 그 과정을 좀더 로그로 출력했을때, 그 일부 내용은 아래와 같다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">touch </span>empty
user@DESKTOP:~<span class="nv">$ </span>strace <span class="nb">cat </span>empty
...
openat<span class="o">(</span>AT_FDCWD, <span class="s2">"empty"</span>, O_RDONLY<span class="o">)</span>     <span class="o">=</span> 3
newfstatat<span class="o">(</span>3, <span class="s2">""</span>, <span class="o">{</span><span class="nv">st_mode</span><span class="o">=</span>S_IFREG|0644, <span class="nv">st_size</span><span class="o">=</span>0, ...<span class="o">}</span>, AT_EMPTY_PATH<span class="o">)</span> <span class="o">=</span> 0
fadvise64<span class="o">(</span>3, 0, 0, POSIX_FADV_SEQUENTIAL<span class="o">)</span> <span class="o">=</span> 0
mmap<span class="o">(</span>NULL, 139264, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="nt">-1</span>, 0<span class="o">)</span> <span class="o">=</span> 0x7f854e8ec000
<span class="nb">read</span><span class="o">(</span>3, <span class="s2">""</span>, 131072<span class="o">)</span>                     <span class="o">=</span> 0
munmap<span class="o">(</span>0x7f854e8ec000, 139264<span class="o">)</span>          <span class="o">=</span> 0
close<span class="o">(</span>3<span class="o">)</span>                                <span class="o">=</span> 0
close<span class="o">(</span>1<span class="o">)</span>                                <span class="o">=</span> 0
close<span class="o">(</span>2<span class="o">)</span>                                <span class="o">=</span> 0
exit_group<span class="o">(</span>0<span class="o">)</span>                           <span class="o">=</span> ?
+++ exited with 0 +++
</code></pre></div></div>

<p>openat(AT_FDCWD, “empty”, O_RDONLY) = 3<br /></p>
<ul>
  <li>openat: 파일이나 디렉토리를 열기 위한 시스템 호출.</li>
  <li>AT_FDCWD: 현재 작업 디렉토리 (at file descriptor current working directory)</li>
  <li>“empty”: 열고자 하는 파일의 이름</li>
  <li>O_RDONLY: 읽기 전용 모드로 열라는 옵션</li>
  <li>3: openat 시스템 호출의 반환 값. 리눅스와 유닉스 시스템에서 파일은 파일 디스크립터를 통해 관리되며, 이 값은 성공적으로 파일을 열었을 때 시스템이 할당한 파일 디스크립터를 나타낸다. 여기서 3은 열린 파일을 나타내는 파일 디스크립터 번호이다. 일반적으로 0, 1, 2는 각각 표준 입력, 표준 출력, 표준 에러를 위해 예약되어 있으므로, 사용자가 열 수 있는 첫 번째 파일 디스크립터는 3부터 시작한다.</li>
</ul>

<p>read(3, “”, 131072)                     = 0<br /></p>
<ul>
  <li>앞에서 구현한 파일 읽기와 동일한 callback 이 발생함을 확인할 수 있다. 
  파일 디스크립터 3 에 대해 값 “” 을 131072 buffer size 를 가지고 read 함수가 callback 된다.</li>
</ul>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="device driver" /><category term="device node" /><category term="ssize_t()" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 12]]></summary></entry><entry><title type="html">Device Driver 개발 1</title><link href="http://localhost:4000/device_driver1.html" rel="alternate" type="text/html" title="Device Driver 개발 1" /><published>2024-02-29T10:32:20+09:00</published><updated>2024-02-29T10:32:20+09:00</updated><id>http://localhost:4000/device_driver1</id><content type="html" xml:base="http://localhost:4000/device_driver1.html"><![CDATA[<style>
    summary::-webkit-details-marker {
        display: none;
    }
    summary {
        list-style: none;
    }
</style>

<details><summary></summary>
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
</details>

<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) (https://comento.kr/)</p>

<h3 id="1-디바이스-드라이버-종류">1. 디바이스 드라이버 종류</h3>

<p>디바이스 드라이버는 플랫폼 별 (윈도우 드라이버, 리눅스 드라이버, 맥 OS 드라이버) 등 또는 OS 수준 별(커널 모드 드라이버, 사용자 모드 드라이버) 로 구분되기도 하며, 아래와 같이 하드웨어의 유형과 기능에 따라 장치별 드라이버로 구분되기도 한다.</p>

<ol>
  <li>
    <p>블록 장치 드라이버<br />
데이터를 블록이라는 고정된 크기의 단위로 저장하고 검색하는 저장 장치를 관리. 이러한 장치에는 하드 디스크 드라이브(HDD), 솔리드 스테이트 드라이브(SSD), USB 플래시 드라이브 등이 포함되며. 블록 장치 드라이버는 파일 시스템을 지원하여, 사용자와 시스템이 데이터를 효율적으로 저장하고 액세스할 수 있게 한다. (ex. 블록 장치 드라이버는 운영 체제가 디스크의 특정 블록을 읽거나 쓸 수 있도록 하며, 디스크 상의 데이터의 물리적 위치를 추상화.)</p>
  </li>
  <li>
    <p>문자 장치 드라이버<br />
데이터를 문자 단위로 처리하는 장치, 즉 한 번에 하나의 문자(또는 바이트)를 전송하는 장치를 관리한다. 이에는 키보드, 마우스, 시리얼 포트, 프린터 등이 포함된다. 문자 장치 드라이버는 사용자 입력을 처리하거나 문자 기반의 데이터를 장치로 전송하는 역할을 한다. (ex. 키보드 드라이버는 사용자가 누른 키의 신호를 받아 운영 체제가 이해할 수 있는 입력 데이터로 변환.)</p>
  </li>
  <li>
    <p>네트워크 드라이버<br />
네트워크 인터페이스 카드(NIC)나 기타 네트워킹 하드웨어 장치를 관리한다. 이 드라이버는 데이터 패킷을 네트워크를 통해 송수신하는 데 필요한 기능을 제공한다. 네트워크 드라이버는 네트워크 프로토콜(예: TCP/IP)과 상호 작용하여 데이터를 올바르게 포맷하고, 주소를 지정하며, 에러 검사를 수행한다. 네트워크 드라이버는 데이터의 안정적인 전송을 보장하기 위해 중요한 역할을 한다.</p>
  </li>
  <li>
    <p>버스 디바이스 드라이버<br />
컴퓨터 내의 다양한 하드웨어 장치를 연결하는 통신 경로인 버스를 관리한다. 대표적인 예로는 PCI(Peripheral Component Interconnect), USB(Universal Serial Bus), SATA(Serial ATA) 등이 있습니다. 버스 드라이버는 하드웨어 장치 간의 데이터 전송을 조정하고, 장치 간의 호환성을 보장한다. (ex. USB 버스 드라이버는 USB 장치가 컴퓨터에 연결될 때 필요한 전력 관리, 데이터 전송 속도 조정, 연결된 장치의 식별 및 구성을 담당.)</p>
  </li>
</ol>

<h3 id="2-디바이스-노드">2. 디바이스 노드</h3>

<p>디바이스 노드(Device Node)는 유닉스 및 유닉스 계열 운영 체제에서 하드웨어 장치를 파일 시스템 내의 파일로 표현하는 방법. 유닉스 계열 시스템은 ‘모든 것은 파일’이라는 철학을 따르는데, 이는 하드웨어 장치를 포함한 모든 자원을 파일처럼 취급한다는 의미이다. 디바이스 노드를 통해, 사용자와 응용 프로그램은 표준 파일 입출력(IO) 시스템 호출을 사용하여 하드웨어 장치와 통신할 수 있다.</p>

<h4 id="디바이스-노드의-종류-타입">디바이스 노드의 종류 (타입)</h4>

<ul>
  <li>
    <p>문자 디바이스(Character Device) : c <br /></p>
  </li>
  <li>
    <p>블록 디바이스(Block Device) : b <br /></p>

    <p>(네트워크 드라이버와 버스 디바이스 드라이버는 노출되지 않고 별도로 관리됨.)</p>
  </li>
</ul>

<h4 id="디바이스-노드의-특징-및-사용-방법">디바이스 노드의 특징 및 사용 방법</h4>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">mknod &lt;파일이름&gt; &lt;타입&gt; &lt;주번호&gt; &lt;부번호&gt;</code> : 디바이스 노드 파일 생성</p>
  </li>
  <li>
    <p>파일 시스템 내 위치 <br />
디바이스 노드는 주로 /dev 디렉토리에 위치한다. 예를 들어, /dev/sda는 첫 번째 SATA 하드 드라이브를, /dev/tty는 현재 터미널을 나타낸다.</p>
  </li>
  <li>
    <p>특수 파일 <br />
디바이스 노드는 특수 파일로 분류된다. 일반 파일과 달리, 실제 데이터를 디스크에 저장하는 대신, 커널의 하드웨어 장치 드라이버와 통신하는 인터페이스 역할을 한다.</p>
  </li>
  <li>
    <p>MAJOR/MINOR 번호 <br />
각 디바이스 노드는 MAJOR 번호와 MINOR 번호를 가진다.</p>

    <p>MAJOR 번호(0 ~ 511)는 장치 유형(예: 하드 디스크, 시리얼 포트)을 식별한다. 디바이스 드라이버마다 고유하며 커널이 자동으로 할당하기도 한다.</p>

    <p>MINOR 번호(0 ~ 1048576)는 해당 유형 내의 개별 장치를 구분한다. 즉 디바이스마다 고유하며 디바이스 드라이버가 할당을 관리한다.</p>

    <p>ex. USB 마우스를 여러개 꽂았을 경우 - 디바이스(minor 번호)는 여러개, 디바이스 드라이버(major 번호) 는 하나</p>
  </li>
  <li>
    <p>사용자와 그룹 권한 <br />
디바이스 노드는 파일과 마찬가지로 사용자와 그룹 권한을 가진다. 이를 통해 특정 사용자 또는 그룹만이 장치에 접근하거나 사용할 수 있는 권한을 제어할 수 있다.</p>
  </li>
</ul>

<h3 id="3-문자-디바이스-드라이버-등록-실습">3. 문자 디바이스 드라이버 등록 실습</h3>

<h4 id="31-문자-디바이스-드러이버-구현-시스템콜-파일-생성">3.1 문자 디바이스 드러이버 구현 시스템콜 파일 생성</h4>

<p>(이전 post 에서 구현한 <code class="language-plaintext highlighter-rouge">linux/drivers/coment/main.c</code> 파일을 사용하여 진행)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/drivers/comento<span class="nv">$ </span>vim main.c
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
</span>
<span class="c1">// (1)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">comento_device_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">iminor</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"%s - minor : %d/n"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">minor</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> 

<span class="c1">// (2)</span>
<span class="k">struct</span> <span class="n">file_operations</span> <span class="n">fops</span><span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">comento_device_open</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">comento_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">register_chrdev</span><span class="p">(</span><span class="mi">177</span><span class="p">,</span> <span class="s">"comento"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fops</span><span class="p">);</span> <span class="c1">// (3)</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">comento_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">unregister_chrdev</span><span class="p">(</span><span class="mi">177</span><span class="p">,</span> <span class="s">"comento"</span><span class="p">);</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">comento_module_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">comento_module_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">"Hello&lt;hello@comento.com&gt;"</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">"Example module"</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL v2"</span><span class="p">);</span>
</code></pre></div></div>

<p>(1) static int comento_device_open(struct inode *inode, struct file *file) {} <br />
리눅스 커널 내에서 디바이스 파일을 열려고 할 때 호출되는 함수. 이 함수는 file_operations 구조체 내에서 .open 포인터에 의해 참조되며, 사용자 공간에서 디바이스 파일(예: /dev/comento)에 대한 open 시스템 콜이 발생할 때 실행된다.
해당 함수는 디바이스 파일이 열릴 때 필요한 초기화나 상태 확인 등의 작업을 수행하기 위애 정의 된다. <br />
<code class="language-plaintext highlighter-rouge">struct file_operations</code> 의 주요 필드 callback 함수에 대한 정의를 살펴보면</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">struct</span> <span class="n">file_operations</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
    <span class="n">loff_t</span> <span class="p">(</span><span class="o">*</span><span class="n">llseek</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">// 다른 필드들...</span>
  <span class="p">};</span>
</code></pre></div></div>
<p>이와 같이 open 필드의 경우, inode 포인터와 file 포인터를 인자로 취하는 함수이여야 한다.</p>

<ul>
  <li>inode <br />
inode는 유닉스 및 유닉스 계열 시스템에서 파일 시스템의 파일이나 디렉터리에 대한 메타데이터를 저장하는 데이터 구조 (구조체 타입) 각 파일이나 디렉터리는 고유한 inode를 가지며, 이 inode에는 파일의 소유자, 파일 모드(권한), 파일 크기, 파일이 저장된 디스크 상의 위치, 생성 및 수정 날짜 등의 정보가 포함된다. <br /> 
디바이스 드라이버의 컨텍스트에서 inode 구조체는 디바이스 파일의 메타데이터에 접근하는 데 사용된다. 특히, 디바이스 파일을 나타내는 inode에서 Major 번호와 Minor 번호를 추출하여, 해당 디바이스 파일이 어떤 디바이스를 참조하는지 식별할 수 있다.<br /></li>
</ul>

<p>(2) file_operations <br />
리눅스 커널 내에서 파일 작업을 위한 callback 함수를 정의하는데 사용되느 구조체. 커널 모듈이나 디바이스 드라이버가 파일 시스템의 파일이나 디바이스 파일에 대한 다양한 작업(예: 열기, 읽기, 쓰기 등)을 수행할 수 있도록 하는 인터페이스를 제공한다. 각 필드는 특정 파일 작업을 위한 함수 포인터를 가리키며, 해당 작업이 호출될 때 실행될 함수를 지정한다. <br /><br /></p>
<ul>
  <li>.open   : 파일이나 디바이스를 열 때 호출됨</li>
  <li>.read   : 파일이나 디바이스에서 데이터를 읽을 때 호출됨</li>
  <li>.write  : 파일이나 디바이스에 데이터를 쓸 때 호출됨</li>
  <li>.release: 파일이나 디바이스가 닫힐 때 호출됨 (종종 close 작업으로 참조됨).</li>
  <li>.llseek : 파일 내에서 읽기/쓰기 위치를 변경할 때 호출됨</li>
  <li>.ioctl  : 장치에 특정 명령을 보낼 때 사용됨 (장치 제어).<br /><br /></li>
</ul>

<p>(3) register_chrdev(major, name, fops)  <br /> 
새로운 문자 디바이스 드라이버 등록에 사용되는 API</p>
<ul>
  <li>major : 주번호로 사용할 번호를 지정, (0으로 지정시 커널이 자동 할당)</li>
  <li>name : 디바이스의 이름</li>
  <li>fops : 디바이스 드라이버가 구현할 file_operations</li>
  <li>등록이 성공했다면 0 또는 할당받은 major 번호를 반환, 실패시 음수 반환</li>
</ul>

<p><br />
이제 아래와 같이 수정한 소스 파일을 빌드하여 ko dynamic linker 파일 생성한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 <span class="nv">CROSS_COMPILE</span><span class="o">=</span>/home/gon/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu- make
  CALL    scripts/checksyscalls.sh
  CC <span class="o">[</span>M]  drivers/comento/main.o
  LD <span class="o">[</span>M]  drivers/comento/comento.o
  MODPOST Module.symvers
  LD <span class="o">[</span>M]  drivers/comento/comento.ko
</code></pre></div></div>

<p>rootfs 에 마운트 해당 파일을 마우트 이미지에 삽입</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/<span class="nv">$ </span><span class="nb">sudo </span>mount <span class="nt">-o</span> loop ../buildroot/output/images/rootfs.ext4 /mnt
user@DESKTOP:~/linux/<span class="nv">$ </span><span class="nb">sudo cp </span>drivers/comento/comento.ko /mnt/usr/lib/modules/.
user@DESKTOP:~/linux/<span class="nv">$ </span><span class="nb">sync
</span>user@DESKTOP:~/linux/<span class="nv">$ </span><span class="nb">sudo </span>umount /mnt
</code></pre></div></div>

<p>QEMU 로 커널 실행</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/<span class="nv">$ </span><span class="nb">cd</span> ..
user@DESKTOP:~<span class="nv">$ </span>qemu-system-aarch64 <span class="nt">-kernel</span> linux/arch/arm64/boot/Image <span class="nt">-drive</span> <span class="nv">format</span><span class="o">=</span>raw,file<span class="o">=</span>buildroot/output/images/rootfs.ext4,if<span class="o">=</span>virtio <span class="nt">-append</span> <span class="s2">"root=/dev/vda console=ttyAMA0 nokaslr"</span> <span class="nt">-nographic</span> <span class="nt">-M</span> virt <span class="nt">-cpu</span> cortex-a72 <span class="nt">-m</span> 2G <span class="nt">-smp</span> 2
</code></pre></div></div>

<h4 id="32-디바이스-노드-만들기">3.2 디바이스 노드 만들기</h4>

<p>mknod 명령어로 디바이스 노드를 생성한다. 순서대로 c (문자 디바이스), 177 (기존에 지정한 major 번호) 32 (임의의 minor 번호) 를 입력한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># cd /dev/
# mknod /dev/comento c 177 43
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># cat /dev/comento
cat: can't open '/dev/comento': No such device or address
</code></pre></div></div>

<p>명령어 수행 결과를 확인했을 때, 아직 디바이스 드라이버가 로드되지 않아 찾지 못한다고 나온다. 따라서 아래와 같이 해당 디바이스 드라이버를 등록 시키고 다시 확인해보면,</p>

<h4 id="33-모듈-로드">3.3 모듈 로드</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># insmod /usr/lib/modules/comento.ko
# cat /dev/comento
cat: read error: Invalid argument
</code></pre></div></div>

<p>해당 결과와 같이, 드라이버 노드는 찾은 것 같다. 다만 read 대한 구현이 없기 때문에 해당 에러가 발생하였다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># dmesg
...
comento_module_init
# ls -lah comento
crw-r--r--    1 root     root      177,  43 Feb 29 07:20 comento
</code></pre></div></div>

<p>dmesg 로 init 되었음이 확인 되었으며, (그런데 <code class="language-plaintext highlighter-rouge">comento_device_open</code> 함수 실행 메세지는 안나왔네 ;;) ls 명령어를 통해 <code class="language-plaintext highlighter-rouge">comento</code> 파일이 생성 및 major, minor 번호가 정상적으로 부여되었음을 볼 수 있다.</p>

<p>위 과정에서 모듈로드가 정상적으로 되어야 드라이버 노드가 정상적으로 작동함을 보여주기 위해  mknod 로 디바이스 노드를 생성한 이후 모듈을 로드 했지만, 논리적으로 절차를 생각하면, 우선 디바이스 노드의 binary 값을 매모리에 로드하는 것이 우선으로 시행되는 것이 맞다. 해당 insmod 명령어 수행시 어떤 작업이 수행되는지 정리하면 아래와 같다.</p>

<ol>
  <li>
    <p>메모리 로드
insmod 명령어는 디스크 상의 커널 모듈(.ko 파일)을 찾아 메모리로 로드. 이 파일에는 디바이스 드라이버의 실행 가능한 코드가 포함되어 있다.</p>
  </li>
  <li>
    <p>초기화 및 등록
드라이버 모듈이 메모리로 로드되면, 그 안에 정의된 초기화 함수가 실행된다. 이 초기화 과정에서 드라이버는 자신이 관리할 하드웨어 디바이스를 설정하고, 커널에 필요한 정보(예: 드라이버가 지원하는 연산, 메이저 번호 등)를 등록한다. 이로써 시스템은 해당 드라이버가 존재하고 사용 가능함을 알게 된다.</p>
  </li>
  <li>
    <p>시스템과의 통합
드라이버가 성공적으로 로드되고 초기화되면, 시스템의 다른 부분들은 해당 드라이버를 통해 연결된 하드웨어 디바이스와 통신할 수 있다. 예를 들어, 사용자 공간의 애플리케이션은 표준 파일 입출력 연산을 사용하여 디바이스 파일(/dev에 위치)을 통해 드라이버와 데이터를 주고받을 수 있다.</p>
  </li>
</ol>

<p>이후 mknod 명령어 요청시 로드된 모듈을 가지고 어떤 작업들이 진행되는 정리하면 아래와 같다.</p>

<ol>
  <li>
    <p>파일 유형 및 메이저/마이너 번호 지정
사용자는 mknod 명령어를 실행할 때 파일의 경로, 유형(문자 디바이스 또는 블록 디바이스), 메이저 번호, 그리고 마이너 번호를 지정. 이 정보는 생성될 디바이스 파일의 특성을 결정한다.
(예: mknod /dev/example c 240 0은 /dev 디렉토리에 example이라는 이름의 문자 디바이스 파일을 생성하며, 이 파일은 메이저 번호 240과 마이너 번호 0을 가진다.)</p>
  </li>
  <li>
    <p>디바이스 파일 생성
지정된 정보를 바탕으로 파일 시스템에 디바이스 파일을 생성. 이 파일은 실제 데이터를 저장하지 않고, 대신 특정 디바이스 드라이버와의 통신 경로 역할을 한다. 생성된 파일의 유형(문자 또는 블록), 메이저 번호, 마이너 번호는 커널이 디바이스 드라이버를 어떻게 찾아야 하는지를 결정하는 데 사용된다.</p>
  </li>
  <li>
    <p>파일 시스템에 메타데이터 등록
생성된 디바이스 파일에 대한 메타데이터가 파일 시스템에 등록. 이 메타데이터에는 파일의 유형, 권한, 소유자, 그룹, 메이저/마이너 번호 등이 포함될 수 있다. 이 정보는 파일 시스템을 통해 파일에 접근하려는 프로세스에 의해 참조된다.</p>
  </li>
  <li>
    <p>시스템과의 통합
디바이스 파일이 성공적으로 생성되면, 시스템의 다른 부분(예: 사용자 공간의 프로그램)은 이 파일을 통해 커널의 디바이스 드라이버와 통신할 수 있다. 파일에 대한 입출력 연산은 커널에 의해 해당 디바이스 드라이버의 적절한 함수로 라우팅된다.</p>
  </li>
</ol>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="device driver" /><category term="device node" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 11]]></summary></entry><entry><title type="html">Kernel Module 만들기</title><link href="http://localhost:4000/kernelmodule01.html" rel="alternate" type="text/html" title="Kernel Module 만들기" /><published>2024-02-28T10:32:20+09:00</published><updated>2024-02-28T10:32:20+09:00</updated><id>http://localhost:4000/kernelmodule01</id><content type="html" xml:base="http://localhost:4000/kernelmodule01.html"><![CDATA[<style>
    summary::-webkit-details-marker {
        display: none;
    }
    summary {
        list-style: none;
    }
</style>

<details><summary></summary>
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
</details>

<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) (https://comento.kr/)</p>

<h3 id="1-관련-설정-추가-및-source-code-생성">1. 관련 설정 추가 및 source code 생성</h3>

<p>1.1 드라이버 디렉토리 생성 및 Makefile 에 해당 디렉토리 추가</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">cd </span>linux/drivers
user@DESKTOP:~/linux/drivers<span class="nv">$ </span><span class="nb">mkdir </span>comento
user@DESKTOP:~/linux/drivers<span class="nv">$ </span>vim Makefile
</code></pre></div></div>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">...</span>
<span class="nv">obj-$(CONFIG_DRM_ACCEL)</span>         <span class="o">+=</span> accel/
<span class="nv">obj-$(CONFIG_CDX_BUS)</span>           <span class="o">+=</span> cdx/
<span class="nv">obj-$(CONFIG_DPLL)</span>              <span class="o">+=</span> dpll/

<span class="nv">obj-$(CONFIG_S390)</span>              <span class="o">+=</span> s390/
<span class="c"># 추가 내용
</span><span class="nv">oeeebj-y</span>                           <span class="o">+=</span> comento/ 
</code></pre></div></div>

<p>1.2 drivers Kconfig 에도 추가될 디렉토리 Kconfig 항목 추가</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/drivers<span class="nv">$ </span>vim Kconfig
</code></pre></div></div>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">...</span>
<span class="err">source</span> <span class="s2">"drivers/cdx/Kconfig"</span>

<span class="err">source</span> <span class="s2">"drivers/dpll/Kconfig"</span>

<span class="err">source</span> <span class="s2">"drivers/comento/Kconfig"</span>  <span class="c"># 추가 내용
</span>
<span class="err">endmenu</span>
</code></pre></div></div>

<p>1.3 해당 디렉토리에 Kconfig 파일 추가</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/drivers<span class="nv">$ </span><span class="nb">cd </span>comento
user@DESKTOP:~/linux/drivers/comento<span class="nv">$ </span>vim Kconfig 
</code></pre></div></div>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">menu</span> <span class="s2">"Comento Example Driver"</span>

<span class="err">config</span> <span class="err">COMENTO_EXAMPLE</span>
    <span class="err">tristate</span> <span class="s2">"Comento Example Dirver Module"</span>
    <span class="err">help</span>
        <span class="err">This</span> <span class="err">is</span> <span class="err">an</span> <span class="err">example</span>

<span class="err">endmenu</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">config COMENTO_EXAMPLE</code> : .config 파일에서는 CONFIG prefix 를 붙여 <code class="language-plaintext highlighter-rouge">CONFIG_COMENTO_EXAMPLE</code> 로 사용됨.</li>
</ul>

<p>1.4 해당 디렉토리 내 main.c 로 목적파일이 만들어 질 수 있도록 Makefile 추가</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/drivers/comento<span class="nv">$ </span>vim Makefile
</code></pre></div></div>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">obj-$(CONFIG_COMENTO_EXAMPLE)</span> <span class="o">+=</span> comento.o
<span class="nv">comento-objs</span> <span class="o">+=</span> main.o
</code></pre></div></div>

<p>1.5 linux kernel module 내용을 담은 소스 코드 <code class="language-plaintext highlighter-rouge">main.c</code> 작성</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/drivers/comento<span class="nv">$ </span>vim main.c
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span>  <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">comento_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>  <span class="n">__func__</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">comento_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>  <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">comento_module_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">comento_module_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">"Hello&lt;hello@comento.com&gt;"</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">"Example module"</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL v2"</span><span class="p">);</span>
</code></pre></div></div>
<h4 id="모듈-초기화-및-종료-함수">모듈 초기화 및 종료 함수</h4>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">__init</code> 함수 (comento_module_init): 모듈이 커널에 로드될 때 자동으로 실행됨. <code class="language-plaintext highlighter-rouge">__init</code> 매크로는 이 함수가 초기화 코드에만 사용되며, 초기화 후에는 메모리에서 해제될 수 있음을 커널에 알린다. 이 예에서, printk 함수를 사용하여 커널 로그에 메시지 (<code class="language-plaintext highlighter-rouge">__func__</code> 매크로는 현재 함수 이름의 문자열을 반환) 를 출력한다. <code class="language-plaintext highlighter-rouge">__init</code> 은 init 관련 함수임을 표시한 attribute 이다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">__exit</code> 함수 (comento_module_exit): 모듈이 커널에서 제거될 때 실행됨. <code class="language-plaintext highlighter-rouge">__exit</code> 매크로는 이 함수가 종료 코드에만 사용되며, 모듈이 커널에 계속 로드되어 있는 경우 메모리를 절약하기 위해 해제될 수 있음을 나타낸다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">module_init</code> 매크로
    <ul>
      <li>목적: 커널 모듈이 시스템에 로드될 때 실행될 초기화 함수를 지정</li>
      <li>동작: 지정된 초기화 함수는 모듈이 커널에 삽입될 때(insmod 명령어 사용 시) 자동으로 호출된다. 이 함수 내에서는 모듈이 제대로 작동하기 위해 필요한 리소스 할당, 상태 초기화, 디바이스 등록 등의 작업을 수행한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">module_exit</code> 매크로
    <ul>
      <li>목적: 커널 모듈이 시스템에서 제거될 때 실행될 종료 함수를 지정</li>
      <li>동작: 지정된 종료 함수는 모듈이 커널에서 제거될 때(rmmod 명령어 사용 시) 자동으로 호출된다. 이 함수 내에서는 모듈의 정상적인 종료를 위해 할당된 리소스의 해제, 등록된 디바이스의 등록 해제 등의 작업을 수행한다.</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">MODULE_AUTHOR</code>: 모듈의 작성자.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">MODULE_DESCRIPTION</code>: 모듈에 대한 간단한 설명.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">MODULE_LICENSE</code>: 모듈의 라이선스 유형. “GPL v2”는, 모듈이 GNU General Public License 버전 2에 따라 배포됨을 나타낸다. 이는 모듈이 GPL 호환 코드와 함께 사용되어야 함을 의미한다.</li>
</ul>

<p>1.6 menuconfig 실행하여 항목 추가되었음을 확인하고 설정 반영</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/drivers/comento<span class="nv">$ </span><span class="nb">cd</span> ..
user@DESKTOP:~/linux/drivers<span class="nv">$ </span><span class="nb">cd</span> ..
user@DESKTOP:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 make menuconfig
</code></pre></div></div>
<p>Device Driver 항목 맨 아래 다음과 같이 추가되었음을 확인할 수 있다.</p>

<center><img src="assets\img\posts\2024-02-28-kernelmodule011.png" width="600" /></center>
<p><br /></p>
<center><img src="assets\img\posts\2024-02-28-kernelmodule012.png" width="600" /></center>

<h3 id="2-kernel-build">2. kernel build</h3>

<p>2.1  kernel build</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 <span class="nv">CROSS_COMPILE</span><span class="o">=</span>/home/gon/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu- make 
  CALL    scripts/checksyscalls.sh
  CC <span class="o">[</span>M]  drivers/comento/main.o
  LD <span class="o">[</span>M]  drivers/comento/comento.o
  ...
  CC <span class="o">[</span>M]  drivers/comento/comento.mod.o
  LD <span class="o">[</span>M]  drivers/comento/comento.ko
  ...
</code></pre></div></div>

<p>해당 kernel 을 build 하면 위와 같이 사용자가 작성한 <code class="language-plaintext highlighter-rouge">drivers/comento/main.o</code> 가 gcc 에 의해 빌드되고, 해당 linker script 가 <code class="language-plaintext highlighter-rouge">comento-objs += main.o</code> 에 명시된 대로 <code class="language-plaintext highlighter-rouge">main.o</code> 를 모아서 <code class="language-plaintext highlighter-rouge">obj-$(CONFIG_COMENTO_EXAMPLE) += comento.o</code> 대로 <code class="language-plaintext highlighter-rouge">drivers/comento/comento.o</code> 을 생성한다.</p>

<p>그리고 <code class="language-plaintext highlighter-rouge">commento.o</code> 가 모듈관련 목적 파일 <code class="language-plaintext highlighter-rouge">drivers/comento/comento.mod.o</code> 과 함께 link 되서 linker 가 <code class="language-plaintext highlighter-rouge">drivers/comento/comento.ko</code> 를 만든다.</p>

<h3 id="3-buildroot-이미지에-해당-ko-파일-추가-및-qemu-에서-모듈-로드가-정상적으로-되었는지-확인">3. buildroot 이미지에 해당 ko 파일 추가 및 QEMU 에서 모듈 로드가 정상적으로 되었는지 확인</h3>

<p>3.1 buildroot 이미지에 해당 ko 파일 추가</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo </span>mount <span class="nt">-o</span> loop ../buildroot/output/images/rootfs.ext4 /mnt
user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo mkdir</span> /mnt/usr/lib/modules
user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo cp </span>drivers/comento/comento.ko /mnt/usr/lib/modules
user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sync
</span>user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo </span>umount /mnt
</code></pre></div></div>

<p>3.2 QEMU 실행</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">cd</span> ..
user@DESKTOP:~<span class="nv">$ </span>qemu-system-aarch64 <span class="nt">-kernel</span> linux/arch/arm64/boot/Image <span class="nt">-drive</span> <span class="nv">format</span><span class="o">=</span>raw,file<span class="o">=</span>buildroot/output/images/rootfs.ext4,if<span class="o">=</span>virtio <span class="nt">-append</span> <span class="s2">"root=/dev/vda console=ttyAMA0 nokaslr"</span> <span class="nt">-nographic</span> <span class="nt">-M</span> virt <span class="nt">-cpu</span> cortex-a72 <span class="nt">-m</span> 2G <span class="nt">-smp</span> 2
</code></pre></div></div>

<p>3.3 모듈 추가 확인</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># ls /usr/lib/modules
comento.ko
</code></pre></div></div>

<p>해당 커널에서 삽입한 경로에 보면 <code class="language-plaintext highlighter-rouge">comento.ko</code> 이 정상적으로 추가되어 있음을 볼 수 있다.</p>

<h3 id="4-moudule-load--unload">4. moudule load / unload</h3>

<p>4.1 load</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># insmod /usr/lib/moduels/comento.ko
# dmesg -c
comento_module_init
</code></pre></div></div>
<p>insmod 하여 모듈을 삽입하고 <code class="language-plaintext highlighter-rouge">dmesg</code> 를 하면, <code class="language-plaintext highlighter-rouge">main.c</code> 에 작성 했던 <code class="language-plaintext highlighter-rouge">comento_module_init()</code> 에서 작성한 대로 함수명 (<code class="language-plaintext highlighter-rouge">comento_module_init</code>) 을 출력하게 된다. 아래와 같이 <code class="language-plaintext highlighter-rouge">lsmod</code> 명령어로 현재 로드된 모듈들을 볼 수도 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># lsmod
Module                  Size  Used by
comento                12288  0
</code></pre></div></div>

<p>4.2 unload</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># rmmod comento.ko
# dmesg -c
comento_module_exit
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">rmmod</code> 를 통해 지정된 모듈을 제거 한다. 제거하면서 “comento_module_exit” 메세지가 출력되었음을 볼 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># lsmod
Module                  Size  Used by
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">lsmod</code> 로 보면 이제 로드된 모듈이 없음을 확인할 수 있다.</p>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="kernel module" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 10]]></summary></entry><entry><title type="html">GDB 를 사용 기초 및 systemcall GDB 적용</title><link href="http://localhost:4000/gdp01.html" rel="alternate" type="text/html" title="GDB 를 사용 기초 및 systemcall GDB 적용" /><published>2024-02-25T10:32:20+09:00</published><updated>2024-02-25T10:32:20+09:00</updated><id>http://localhost:4000/gdp01</id><content type="html" xml:base="http://localhost:4000/gdp01.html"><![CDATA[<style>
    summary::-webkit-details-marker {
        display: none;
    }
    summary {
        list-style: none;
    }
</style>

<details><summary></summary>
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
</details>

<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) (https://comento.kr/)</p>

<h3 id="gdb-기초">GDB 기초</h3>

<ol>
  <li>GDB 사용을 위한 라이브러리 설치</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>gdb-multiarch
</code></pre></div></div>

<ol>
  <li>GDB 로 관찰할 systemcall 작성</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>vi fact.c
</code></pre></div></div>

<ul>
  <li>test 용 code</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">*=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">ret</span> <span class="o">*=</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"result: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>gcc build</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>gcc <span class="nt">-g</span> fact.c <span class="nt">-o</span> fact 
<span class="c"># -g : 컴파일된 실행 파일에 디버깅 정보를 포함</span>
<span class="c"># GDB를 사용할 때 소스 코드의 라인 번호, 변수 이름 등의 상세한 정보에 접근 가능</span>
</code></pre></div></div>

<ol>
  <li>GDB 실행</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>gdb-multiarch fact
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;https://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from fact...
(gdb)
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) start 10          # --- (1)
Temporary breakpoint 1 at 0x11bd: file fact.c, line 14. # --- (2)
Starting program: /home/gon/fact 10     
[Thread debugging using libthread_db enabled]   --- (3)
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1". # --- (4)

Temporary breakpoint 1, main (argc=2, argv=0x7fffffffe108) at fact.c:14
14          int i = atoi(argv[1]);
</code></pre></div></div>
<p>(1) start 명령은 프로그램을 시작하고, 주어진 프로그램의 첫번째 인자(10)와 함께 메인 함수의 첫 번째 라인에서 일시적인 중단점을 설정.  이렇게 하면 프로그램이 실제로 실행되기 시작하며, 사용자가 프로그램의 초기 상태를 검사할 수 있게 된다.</p>

<p>(2) 현재 중단점 code 상 line 의 위치와 메모리 주소. 즉 main 함수 내 첫번째 줄.</p>

<p>(3) 멀티스레딩 프로그램을 디버깅하기 위해 libthread_db 라이브러리를 사용하고 있음을 표시</p>

<p>(4) 호스트 시스템의 libthread_db 라이브러리를 사용하고 있음을 표시. 이 라이브러리는 스레드와 관련된 정보를 제공하여 디버거가 스레드를 효율적으로 관리할 수 있게 돕는다.</p>

<h3 id="qeme-gdb-적용">QEME GDB 적용</h3>

<ol>
  <li>Debug mode 로 빌드되도록 Linux kernel 설정 변경</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">cd </span>linux
user@DESKTOP:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 make menuconfig 
</code></pre></div></div>

<ul>
  <li>kernel hacking -&gt;  Kernel debugging 선택</li>
  <li>kernel hacking -&gt;  Compile-time checks and compiler options -&gt; Debug information (Disable debug information) -&gt;  Rely on the toolchain’s implicit default DWARF version 선택</li>
</ul>

<ol>
  <li>re-build</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span> make <span class="nt">-j</span>&lt;cpu 수&gt;
</code></pre></div></div>

<ol>
  <li>QEMU 실행</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">cd</span> ..
user@DESKTOP:~<span class="nv">$ </span>qemu-system-aarch64 <span class="nt">-kernel</span> linux/arch/arm64/boot/Image <span class="nt">-drive</span> <span class="nv">format</span><span class="o">=</span>raw,file<span class="o">=</span>buildroot/output/images/rootfs.ext4,if<span class="o">=</span>virtio <span class="nt">-append</span> <span class="s2">"root=/dev/vda console=ttyAMA0 nokaslr"</span> <span class="nt">-nographic</span> <span class="nt">-M</span> virt <span class="nt">-cpu</span> cortex-a72 <span class="nt">-m</span> 2G <span class="nt">-smp</span> 2 <span class="nt">-s</span> <span class="nt">-S</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">-s</code> : gdb 가 붙을 수 있도록 1234 포트를 열어둠
<code class="language-plaintext highlighter-rouge">-S</code> : QEMU 가 시작하자마자 멈춰있는 상태로 만듬. (break-point 를 걸수 있는 시점을 마련하기 위함)</p>

<p>(실행시 <code class="language-plaintext highlighter-rouge">-S</code> 옵션으로 인해 멈춰있게 됨. 그래서 다른 cli 상에서 <code class="language-plaintext highlighter-rouge">gdb-multiarch</code>를 사용하여 <code class="language-plaintext highlighter-rouge">linux/vmlinux</code> 경로에 위치한 리눅스 커널 이미지를 디버깅 모드로 염)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>gdb-multiarch linux/vmlinux
For <span class="nb">help</span>, <span class="nb">type</span> <span class="s2">"help"</span><span class="nb">.</span>
Type <span class="s2">"apropos word"</span> to search <span class="k">for </span>commands related to <span class="s2">"word"</span>...
Reading symbols from kernel/vmlinux...
<span class="o">(</span>gdb<span class="o">)</span>
</code></pre></div></div>

<p>따라서 vmlinux 내 debugging 정보가 읽어지게 됨.</p>

<ul>
  <li>기존 buildroot 이미지에는 모든 정보가 담겨있는것이 아니라 kernel 을 실행할 수 있는 코드만 포함된 단순화된 파일이다. 따라서 해당 이미지 만으로 모든 디버깅 정보를 볼 수는 없는 환경이다. 그런데 <code class="language-plaintext highlighter-rouge">vmlinux</code> 파일의 경우, 커널의 디버깅 정보, 함수 및 변수 이름 정보, 코드 라인 정보 등이 모두 담긴 목적 파일이므로 <code class="language-plaintext highlighter-rouge">gdb-multiarch linux/vmlinux</code> 와 같이 해당 파일을 디버거 인자로 넘겨 주어야 한다.</li>
</ul>

<p>그리고 gdb prompt 창에 <code class="language-plaintext highlighter-rouge">target remote :1234</code> 를 입력하여 qemu 에서 열어둔 디버깅 포트 1234 에 접속한다. 연결된 이후, 원하는  break-point 를 걸 수 있다.  예를 들면,</p>

<p><code class="language-plaintext highlighter-rouge">(gdb) break start_kernel</code> 로 입력하면 리눅스 커널에서 제일 먼저 실행되는 c 함수에 중단점을 생성하고,</p>

<p><code class="language-plaintext highlighter-rouge">(gdb)__do_sys_&lt;시스템콜 함수 이름&gt;</code> 의 겅우 앞서 실습한 systemcall 을 디버깅 가능하다. 여기에서 <code class="language-plaintext highlighter-rouge">__do_sys_</code> 접두사는 SYSCALL_DEFINE 매크로가 자동 생성한 것이다.</p>

<ol>
  <li>QEMU 가 연 포트에 접근</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set </span>architecture aarch64
<span class="o">(</span>gdb<span class="o">)</span> target remote :1234
Remote debugging using :1234
warning: Selected architecture i386:x86-64 is not compatible with reported target architecture aarch64
warning: Architecture rejected target-supplied description
0x0000000000000000 <span class="k">in </span>fixed_percpu_data <span class="o">()</span>  <span class="c"># bootloader 의 첫 시작 주소</span>
</code></pre></div></div>

<ol>
  <li>break-point 걸기</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">start_kernel</code> 이라는 가장 처음에 시작되는 함수에 break-point 걸기</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break </span>start_kernel
Breakpoint 1 at 0xffffffff821889e0: file init/main.c, line 875.
</code></pre></div></div>

<p>우리가 추가한 systemcall 함수 break-point 걸기</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break </span>__do_sys_new_syscall
Breakpoint 2 at 0xffffffff811391c9: file kernel/new_syscall.c, line 6.
</code></pre></div></div>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="systemcall" /><category term="gdb-multiarch" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 09]]></summary></entry></feed>