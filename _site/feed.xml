<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-03-01T15:29:12+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Gon’s Tech Jurnal</title><subtitle>The Record of Backend Development</subtitle><author><name>Yong gon Yun</name></author><entry><title type="html">Device Driver 개발 2 (파일 읽기/ 쓰기)</title><link href="http://localhost:4000/device_driver2.html" rel="alternate" type="text/html" title="Device Driver 개발 2 (파일 읽기/ 쓰기)" /><published>2024-03-01T10:32:20+09:00</published><updated>2024-03-01T10:32:20+09:00</updated><id>http://localhost:4000/device_driver2</id><content type="html" xml:base="http://localhost:4000/device_driver2.html"><![CDATA[<style>
    summary::-webkit-details-marker {
        display: none;
    }
    summary {
        list-style: none;
    }
</style>

<details><summary></summary>
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
</details>

<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) - Rootfs 빌드 강의 내용 (https://comento.kr/)</p>

<h3 id="1-파일-읽기-쓰기-구현">1. 파일 읽기/ 쓰기 구현</h3>

<p>1.1 ssize_t type</p>

<p>리눅스 드라이버에서 <code class="language-plaintext highlighter-rouge">ssize_t</code> 타입은 일반적으로 데이터의 크기나 양을 나타내는 데 사용되며, 부호 있는 64비트(시스템에 따라 다를 수 있음) 정수를 의미한다. <code class="language-plaintext highlighter-rouge">ssize_t</code>는 시스템 호출이나 함수들이 실패할 경우 음수 값을 반환할 수 있게 하며, 성공적인 경우에는 양의 값을 반환한다. 이는 주로 파일이나 소켓의 읽기 및 쓰기 연산에서 반환 타입으로 사용된다.</p>

<p>리눅스 커널 모듈에서 파일 또는 장치 드라이버의 읽기 및 쓰기 연산을 구현할 때, read와 write 시스템 호출에 대응하는 함수 포인터를 file_operations 구조체에 설정하고 <code class="language-plaintext highlighter-rouge">ssize_t</code> 를 반환 타입으로 설정한다.</p>

<ul>
  <li>ssize_t(*read)(file, buf, len, ppos) : 파일 읽기 함수 callback</li>
  <li>
    <p>ssize_t(*write)(file, buf, len, ppos) : 파일 쓰기 함수  callback</p>
  </li>
  <li>
    <p>file (<code class="language-plaintext highlighter-rouge">struct file *</code>) : 읽기/쓰기 연산을 수행할 파일에 대한 포인터. struct file은 열린 파일의 상태를 나타내며, 파일의 현재 위치(offset) 같은 정보를 포함한다. 이 구조체를 통해 커널은 어떤 파일에 대한 작업을 수행하고 있는지 알 수 있다.</p>
  </li>
  <li>
    <p>buf (<code class="language-plaintext highlighter-rouge">char __user *</code>) : user space 의 버퍼 주소를 가리키는 포인터. 커널은 데이터를 읽어 user mode process 가 접근한 memory 에 전달할 때, <code class="language-plaintext highlighter-rouge">__user</code>  포인터가 가리키는 위치부터 버퍼 공간을 확보.</p>
  </li>
  <li>
    <p>len (<code class="language-plaintext highlighter-rouge">size_t</code>) : 버퍼의 크기. ‘__user’ 포인터 위치로부터 해당 크기만큼의 buffer 를 user space 에 확보하여 data 을 옮기 수 있게 한다.</p>
  </li>
  <li>ppos (<code class="language-plaintext highlighter-rouge">loff_t *</code>) : 파일 내의 현재 위치(offset)를 나타내는 포인터. loff_t 타입은 대용량 파일 지원을 위해 사용되며, 파일의 어느 부분에서 데이터를 읽을지 결정한다. 함수 호출이 성공하면, 이 위치는 읽은 바이트 수만큼 증가한다. 따라서 파일로부터 원하는 부분에 대한 data 를 읽기 위해서 이에 대한 ppos 의  수정/갱신이 필요하다.</li>
</ul>

<p>데이터의 이동이 kernel space 와 user space 간 이루짐으로 일반적인 <code class="language-plaintext highlighter-rouge">memcpy</code> 는 사용할 수 없으며, <code class="language-plaintext highlighter-rouge">copy_from_user</code> / <code class="language-plaintext highlighter-rouge">copy_to_user</code> 를 사용하여 데이터 복사를 진행해야 한다.</p>

<p>1.2 source 코드 작성 및 빌드</p>

<p>기존에 작성한 <a href="https://y2gon2.github.io/kernelmodule01.html">Kernel Module 만들기 1 참조</a> <code class="language-plaintext highlighter-rouge">main.c</code> 파일을 읽기/쓰기 함수를 추가한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span>vim drivers/comento/main.c
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/device.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/spinlock.h&gt;</span><span class="cp">
</span>
<span class="cp">#define COMENTO_DEVICE_NAME "comento-device"
#define COMENTO_MAJOR_NUMBER 177 
#define COMENTO_BUF_SIZE 16
</span>
<span class="k">static</span> <span class="nf">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">comento_device_rwlock</span><span class="p">);</span>  <span class="c1">// * rwlock 관련</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">comento_device_buf</span><span class="p">[</span><span class="n">COMENTO_BUF_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="p">};</span> 
<span class="c1">// 이 버퍼는 커널 모듈의 일부로서, 커널 모듈이 로드될 때 커널의 메모리 영역에 할당되고, </span>
<span class="c1">// 모듈이 언로드될 때 해제된다. </span>


<span class="c1">// char __user *buf : __user attribute (생략 가능하지만 가독성/명확성을 위해 사용)</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">comento_device_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">ssize_t</span> <span class="n">written_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">comento_device_rwlock</span><span class="p">);</span>  <span class="c1">// * rwlock : read 용 lock 얻기</span>
    
    <span class="c1">// 데이터를 읽거나 쓸 때, 요청된 작업이 디바이스 또는 버퍼의 실제 크기를 넘어서지 않도록 보장</span>
    <span class="c1">// 현재는 *ppos 16 을 넘어가면 실제로 읽지 못하는 상태임 (?)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">COMENTO_BUF_SIZE</span> <span class="o">&lt;=</span> <span class="n">len</span> <span class="o">+</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">COMENTO_BUF_SIZE</span> <span class="o">-</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 실제로 복사된 bytes = 사용자가 요청한 복사 길이 bytes - 실패하거나 복사되지 않은 bytes 수를 반환</span>
    <span class="c1">// copy_to_user(목적지 space, 출발지 pointer, 복사 요청 길이 ) : 출발지 pointer 의 경우 ppos(offset) 고려해야</span>
    <span class="n">written_bytes</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">comento_device_buf</span> <span class="o">+</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">written_bytes</span><span class="p">;</span> <span class="c1">// offset 값 갱신</span>

    <span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">comento_device_rwlock</span><span class="p">);</span>  <span class="c1">// * rwlock : read 완료 후 unlock</span>

    <span class="k">return</span> <span class="n">written_bytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// const char __user *buf : 쓰기의 경우 kernel 에서 user space data 를 읽기만 한다. </span>
<span class="c1">// kernel 이 해당 주소를 임의로 수정할 필요가 없으므로 const 로 고정시켜 안정성을 높인다.</span>
<span class="c1">// const 로 미 선언시 error 또는 warning 발생</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">comento_device_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">read_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">comento_device_rwlock</span><span class="p">);</span> <span class="c1">// * rwlock : write 용 lock 얻기</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">COMENTO_BUF_SIZE</span> <span class="o">&lt;=</span> <span class="n">len</span> <span class="o">+</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">COMENTO_BUF_SIZE</span> <span class="o">-</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// copy_from_user(목적지 space, 출발지 pointer, 복사 요청 길이 ) </span>
    <span class="n">read_bytes</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">comento_device_buf</span> <span class="o">+</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">read_bytes</span><span class="p">;</span> <span class="c1">// offset 값 갱신</span>
    
    <span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">comento_device_rwlock</span><span class="p">);</span>  <span class="c1">// * rwlock : write 완료 후 unlock</span>
    <span class="k">return</span> <span class="n">read_bytes</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">comento_device_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">iminor</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"%s - minor : %d/n"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">minor</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">file_operations</span> <span class="n">fops</span><span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">comento_device_open</span><span class="p">,</span> 
    <span class="c1">// .open 생략시 open 되었다고 가정하고 시스템에서 에러를 발생시키지 않음.</span>
    <span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">comento_device_read</span><span class="p">,</span>
    <span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">comento_device_write</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">comento_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">register_chrdev</span><span class="p">(</span><span class="mi">177</span><span class="p">,</span> <span class="s">"comento"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fops</span><span class="p">);</span> 
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">comento_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">unregister_chrdev</span><span class="p">(</span><span class="mi">177</span><span class="p">,</span> <span class="s">"comento"</span><span class="p">);</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">comento_module_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">comento_module_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">"Hello&lt;hello@comento.com&gt;"</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">"Example module"</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL v2"</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="2-파일-빌드-추가-qemu-실행">2. 파일 빌드, 추가, QEMU 실행</h3>

<p>파일 빌드 및 ko 파일 생성</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 <span class="nv">CROSS_COMPILE</span><span class="o">=</span>/home/gon/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu- make
  CALL    scripts/checksyscalls.sh
  CC <span class="o">[</span>M]  drivers/comento/main.o
  LD <span class="o">[</span>M]  drivers/comento/comento.o
  MODPOST Module.symvers
  LD <span class="o">[</span>M]  drivers/comento/comento.ko
</code></pre></div></div>

<p>ko 파일 rootfs 이미지에 복사</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo </span>mount <span class="nt">-o</span> loop ../buildroot/output/images/rootfs.ext4 /mnt
user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo cp </span>drivers/comento/comento.ko /mnt/usr/lib/modules/.
user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sync
</span>user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo </span>umount /mnt
</code></pre></div></div>

<p>QEMU 실행</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">cd</span> ..
user@DESKTOP:~<span class="nv">$ </span>qemu-system-aarch64 <span class="nt">-kernel</span> linux/arch/arm64/boot/Image <span class="nt">-drive</span> <span class="nv">format</span><span class="o">=</span>raw,file<span class="o">=</span>buildroot/output/images/rootfs.ext4,if<span class="o">=</span>virtio <span class="nt">-append</span> <span class="s2">"root=/dev/vda console=ttyAMA0 nokaslr"</span> <span class="nt">-nographic</span> <span class="nt">-M</span> virt <span class="nt">-cpu</span> cortex-a72 <span class="nt">-m</span> 2G <span class="nt">-smp</span> 2
</code></pre></div></div>

<h3 id="3-파일-읽기-쓰기-사용">3. 파일 읽기, 쓰기 사용</h3>

<p>드라이버 모듈 삽입 및 확인</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># insmod /usr/lib/modules/comento.ko
# dmesg
...
comento_module_init
# cd /dev
# ls -lah comento
crw-r--r--    1 root     root      177,  34 Mar  1 05:50 comento
</code></pre></div></div>

<p>dev 디렉토리 내 디바이스 노드 생성</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># mknod /dev/comento c 177 34
</code></pre></div></div>

<p>값 넣어보기</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># echo "wow" &gt; /dev/comento
# cat /dev/comento
wow
</code></pre></div></div>

<p>추가된 comento 디바이스 노드에 “wow” 문자열을 redirection 하고, 해당 디바이스 노드 내용을 출력하면  redirect 된 값이 그대로 출력됨을 확인할 수 있다.</p>

<p>이는 앞에서 구현한 소스코드 중 <code class="language-plaintext highlighter-rouge">comento_device_write</code> 함수가 실행되어, user space 에서 작성한 문자열이 <code class="language-plaintext highlighter-rouge">copy_from_user</code> 를 사용하여 kernel space memory (<code class="language-plaintext highlighter-rouge">comento_device_buf</code>)에 쓰기가 되었음을 의미한다.</p>

<p>cat 명령을 사용하면, 해당 디바이스 노드의 버퍼 공간 내용을 읽어 온다. 즉 앞에서 구현한 <code class="language-plaintext highlighter-rouge">comento_device_read</code> 함수를 실행하여 <code class="language-plaintext highlighter-rouge">copy_to_user</code> 로 <code class="language-plaintext highlighter-rouge">comento_device_buf</code> 에 저장된 문자열을 표준 출력으로 제공하게 되는 것이다.</p>

<h3 id="4-strace-를-사용한-읽기-과정-관찰">4. strace 를 사용한 읽기 과정 관찰</h3>

<p>strace 를 사용하기 위해 커널을 빠져 나온 이후, 임의 파일을 생성하고 이를 strace 를 사용하여 그 과정을 좀더 로그로 출력했을때, 그 일부 내용은 아래와 같다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">touch </span>empty
user@DESKTOP:~<span class="nv">$ </span>strace <span class="nb">cat </span>empty
...
openat<span class="o">(</span>AT_FDCWD, <span class="s2">"empty"</span>, O_RDONLY<span class="o">)</span>     <span class="o">=</span> 3
newfstatat<span class="o">(</span>3, <span class="s2">""</span>, <span class="o">{</span><span class="nv">st_mode</span><span class="o">=</span>S_IFREG|0644, <span class="nv">st_size</span><span class="o">=</span>0, ...<span class="o">}</span>, AT_EMPTY_PATH<span class="o">)</span> <span class="o">=</span> 0
fadvise64<span class="o">(</span>3, 0, 0, POSIX_FADV_SEQUENTIAL<span class="o">)</span> <span class="o">=</span> 0
mmap<span class="o">(</span>NULL, 139264, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="nt">-1</span>, 0<span class="o">)</span> <span class="o">=</span> 0x7f854e8ec000
<span class="nb">read</span><span class="o">(</span>3, <span class="s2">""</span>, 131072<span class="o">)</span>                     <span class="o">=</span> 0
munmap<span class="o">(</span>0x7f854e8ec000, 139264<span class="o">)</span>          <span class="o">=</span> 0
close<span class="o">(</span>3<span class="o">)</span>                                <span class="o">=</span> 0
close<span class="o">(</span>1<span class="o">)</span>                                <span class="o">=</span> 0
close<span class="o">(</span>2<span class="o">)</span>                                <span class="o">=</span> 0
exit_group<span class="o">(</span>0<span class="o">)</span>                           <span class="o">=</span> ?
+++ exited with 0 +++
</code></pre></div></div>

<p>openat(AT_FDCWD, “empty”, O_RDONLY) = 3<br /></p>
<ul>
  <li>openat: 파일이나 디렉토리를 열기 위한 시스템 호출.</li>
  <li>AT_FDCWD: 현재 작업 디렉토리 (at file descriptor current working directory)</li>
  <li>“empty”: 열고자 하는 파일의 이름</li>
  <li>O_RDONLY: 읽기 전용 모드로 열라는 옵션</li>
  <li>3: openat 시스템 호출의 반환 값. 리눅스와 유닉스 시스템에서 파일은 파일 디스크립터를 통해 관리되며, 이 값은 성공적으로 파일을 열었을 때 시스템이 할당한 파일 디스크립터를 나타낸다. 여기서 3은 열린 파일을 나타내는 파일 디스크립터 번호이다. 일반적으로 0, 1, 2는 각각 표준 입력, 표준 출력, 표준 에러를 위해 예약되어 있으므로, 사용자가 열 수 있는 첫 번째 파일 디스크립터는 3부터 시작한다.</li>
</ul>

<p>read(3, “”, 131072)                     = 0<br /></p>
<ul>
  <li>앞에서 구현한 파일 읽기와 동일한 callback 이 발생함을 확인할 수 있다. 
  파일 디스크립터 3 에 대해 값 “” 을 131072 buffer size 를 가지고 read 함수가 callback 된다.</li>
</ul>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="device driver" /><category term="device node" /><category term="ssize_t()" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 12]]></summary></entry><entry><title type="html">Device Driver 개발 1</title><link href="http://localhost:4000/device_driver1.html" rel="alternate" type="text/html" title="Device Driver 개발 1" /><published>2024-02-29T10:32:20+09:00</published><updated>2024-02-29T10:32:20+09:00</updated><id>http://localhost:4000/device_driver1</id><content type="html" xml:base="http://localhost:4000/device_driver1.html"><![CDATA[<style>
    summary::-webkit-details-marker {
        display: none;
    }
    summary {
        list-style: none;
    }
</style>

<details><summary></summary>
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
</details>

<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) - Rootfs 빌드 강의 내용 (https://comento.kr/)</p>

<h3 id="1-디바이스-드라이버-종류">1. 디바이스 드라이버 종류</h3>

<p>디바이스 드라이버는 플랫폼 별 (윈도우 드라이버, 리눅스 드라이버, 맥 OS 드라이버) 등 또는 OS 수준 별(커널 모드 드라이버, 사용자 모드 드라이버) 로 구분되기도 하며, 아래와 같이 하드웨어의 유형과 기능에 따라 장치별 드라이버로 구분되기도 한다.</p>

<ol>
  <li>
    <p>블록 장치 드라이버<br />
데이터를 블록이라는 고정된 크기의 단위로 저장하고 검색하는 저장 장치를 관리. 이러한 장치에는 하드 디스크 드라이브(HDD), 솔리드 스테이트 드라이브(SSD), USB 플래시 드라이브 등이 포함되며. 블록 장치 드라이버는 파일 시스템을 지원하여, 사용자와 시스템이 데이터를 효율적으로 저장하고 액세스할 수 있게 한다. (ex. 블록 장치 드라이버는 운영 체제가 디스크의 특정 블록을 읽거나 쓸 수 있도록 하며, 디스크 상의 데이터의 물리적 위치를 추상화.)</p>
  </li>
  <li>
    <p>문자 장치 드라이버<br />
데이터를 문자 단위로 처리하는 장치, 즉 한 번에 하나의 문자(또는 바이트)를 전송하는 장치를 관리한다. 이에는 키보드, 마우스, 시리얼 포트, 프린터 등이 포함된다. 문자 장치 드라이버는 사용자 입력을 처리하거나 문자 기반의 데이터를 장치로 전송하는 역할을 한다. (ex. 키보드 드라이버는 사용자가 누른 키의 신호를 받아 운영 체제가 이해할 수 있는 입력 데이터로 변환.)</p>
  </li>
  <li>
    <p>네트워크 드라이버<br />
네트워크 인터페이스 카드(NIC)나 기타 네트워킹 하드웨어 장치를 관리한다. 이 드라이버는 데이터 패킷을 네트워크를 통해 송수신하는 데 필요한 기능을 제공한다. 네트워크 드라이버는 네트워크 프로토콜(예: TCP/IP)과 상호 작용하여 데이터를 올바르게 포맷하고, 주소를 지정하며, 에러 검사를 수행한다. 네트워크 드라이버는 데이터의 안정적인 전송을 보장하기 위해 중요한 역할을 한다.</p>
  </li>
  <li>
    <p>버스 디바이스 드라이버<br />
컴퓨터 내의 다양한 하드웨어 장치를 연결하는 통신 경로인 버스를 관리한다. 대표적인 예로는 PCI(Peripheral Component Interconnect), USB(Universal Serial Bus), SATA(Serial ATA) 등이 있습니다. 버스 드라이버는 하드웨어 장치 간의 데이터 전송을 조정하고, 장치 간의 호환성을 보장한다. (ex. USB 버스 드라이버는 USB 장치가 컴퓨터에 연결될 때 필요한 전력 관리, 데이터 전송 속도 조정, 연결된 장치의 식별 및 구성을 담당.)</p>
  </li>
</ol>

<h3 id="2-디바이스-노드">2. 디바이스 노드</h3>

<p>디바이스 노드(Device Node)는 유닉스 및 유닉스 계열 운영 체제에서 하드웨어 장치를 파일 시스템 내의 파일로 표현하는 방법. 유닉스 계열 시스템은 ‘모든 것은 파일’이라는 철학을 따르는데, 이는 하드웨어 장치를 포함한 모든 자원을 파일처럼 취급한다는 의미이다. 디바이스 노드를 통해, 사용자와 응용 프로그램은 표준 파일 입출력(IO) 시스템 호출을 사용하여 하드웨어 장치와 통신할 수 있다.</p>

<h4 id="디바이스-노드의-종류-타입">디바이스 노드의 종류 (타입)</h4>

<ul>
  <li>
    <p>문자 디바이스(Character Device) : c <br /></p>
  </li>
  <li>
    <p>블록 디바이스(Block Device) : b <br /></p>

    <p>(네트워크 드라이버와 버스 디바이스 드라이버는 노출되지 않고 별도로 관리됨.)</p>
  </li>
</ul>

<h4 id="디바이스-노드의-특징-및-사용-방법">디바이스 노드의 특징 및 사용 방법</h4>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">mknod &lt;파일이름&gt; &lt;타입&gt; &lt;주번호&gt; &lt;부번호&gt;</code> : 디바이스 노드 파일 생성</p>
  </li>
  <li>
    <p>파일 시스템 내 위치 <br />
디바이스 노드는 주로 /dev 디렉토리에 위치한다. 예를 들어, /dev/sda는 첫 번째 SATA 하드 드라이브를, /dev/tty는 현재 터미널을 나타낸다.</p>
  </li>
  <li>
    <p>특수 파일 <br />
디바이스 노드는 특수 파일로 분류된다. 일반 파일과 달리, 실제 데이터를 디스크에 저장하는 대신, 커널의 하드웨어 장치 드라이버와 통신하는 인터페이스 역할을 한다.</p>
  </li>
  <li>
    <p>MAJOR/MINOR 번호 <br />
각 디바이스 노드는 MAJOR 번호와 MINOR 번호를 가진다.</p>

    <p>MAJOR 번호(0 ~ 511)는 장치 유형(예: 하드 디스크, 시리얼 포트)을 식별한다. 디바이스 드라이버마다 고유하며 커널이 자동으로 할당하기도 한다.</p>

    <p>MINOR 번호(0 ~ 1048576)는 해당 유형 내의 개별 장치를 구분한다. 즉 디바이스마다 고유하며 디바이스 드라이버가 할당을 관리한다.</p>

    <p>ex. USB 마우스를 여러개 꽂았을 경우 - 디바이스(minor 번호)는 여러개, 디바이스 드라이버(major 번호) 는 하나</p>
  </li>
  <li>
    <p>사용자와 그룹 권한 <br />
디바이스 노드는 파일과 마찬가지로 사용자와 그룹 권한을 가진다. 이를 통해 특정 사용자 또는 그룹만이 장치에 접근하거나 사용할 수 있는 권한을 제어할 수 있다.</p>
  </li>
</ul>

<h3 id="3-문자-디바이스-드라이버-등록-실습">3. 문자 디바이스 드라이버 등록 실습</h3>

<h4 id="31-문자-디바이스-드러이버-구현-시스템콜-파일-생성">3.1 문자 디바이스 드러이버 구현 시스템콜 파일 생성</h4>

<p>(이전 post 에서 구현한 <code class="language-plaintext highlighter-rouge">linux/drivers/coment/main.c</code> 파일을 사용하여 진행)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/drivers/comento<span class="nv">$ </span>vim main.c
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
</span>
<span class="c1">// (1)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">comento_device_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">iminor</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"%s - minor : %d/n"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">minor</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> 

<span class="c1">// (2)</span>
<span class="k">struct</span> <span class="n">file_operations</span> <span class="n">fops</span><span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">comento_device_open</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">comento_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">register_chrdev</span><span class="p">(</span><span class="mi">177</span><span class="p">,</span> <span class="s">"comento"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fops</span><span class="p">);</span> <span class="c1">// (3)</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">comento_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">unregister_chrdev</span><span class="p">(</span><span class="mi">177</span><span class="p">,</span> <span class="s">"comento"</span><span class="p">);</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">comento_module_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">comento_module_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">"Hello&lt;hello@comento.com&gt;"</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">"Example module"</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL v2"</span><span class="p">);</span>
</code></pre></div></div>

<p>(1) static int comento_device_open(struct inode *inode, struct file *file) {} <br />
리눅스 커널 내에서 디바이스 파일을 열려고 할 때 호출되는 함수. 이 함수는 file_operations 구조체 내에서 .open 포인터에 의해 참조되며, 사용자 공간에서 디바이스 파일(예: /dev/comento)에 대한 open 시스템 콜이 발생할 때 실행된다.
해당 함수는 디바이스 파일이 열릴 때 필요한 초기화나 상태 확인 등의 작업을 수행하기 위애 정의 된다. <br />
<code class="language-plaintext highlighter-rouge">struct file_operations</code> 의 주요 필드 callback 함수에 대한 정의를 살펴보면</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">struct</span> <span class="n">file_operations</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
    <span class="n">loff_t</span> <span class="p">(</span><span class="o">*</span><span class="n">llseek</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">// 다른 필드들...</span>
  <span class="p">};</span>
</code></pre></div></div>
<p>이와 같이 open 필드의 경우, inode 포인터와 file 포인터를 인자로 취하는 함수이여야 한다.</p>

<ul>
  <li>inode <br />
inode는 유닉스 및 유닉스 계열 시스템에서 파일 시스템의 파일이나 디렉터리에 대한 메타데이터를 저장하는 데이터 구조 (구조체 타입) 각 파일이나 디렉터리는 고유한 inode를 가지며, 이 inode에는 파일의 소유자, 파일 모드(권한), 파일 크기, 파일이 저장된 디스크 상의 위치, 생성 및 수정 날짜 등의 정보가 포함된다. <br /> 
디바이스 드라이버의 컨텍스트에서 inode 구조체는 디바이스 파일의 메타데이터에 접근하는 데 사용된다. 특히, 디바이스 파일을 나타내는 inode에서 Major 번호와 Minor 번호를 추출하여, 해당 디바이스 파일이 어떤 디바이스를 참조하는지 식별할 수 있다.<br /></li>
</ul>

<p>(2) file_operations <br />
리눅스 커널 내에서 파일 작업을 위한 callback 함수를 정의하는데 사용되느 구조체. 커널 모듈이나 디바이스 드라이버가 파일 시스템의 파일이나 디바이스 파일에 대한 다양한 작업(예: 열기, 읽기, 쓰기 등)을 수행할 수 있도록 하는 인터페이스를 제공한다. 각 필드는 특정 파일 작업을 위한 함수 포인터를 가리키며, 해당 작업이 호출될 때 실행될 함수를 지정한다. <br /><br /></p>
<ul>
  <li>.open   : 파일이나 디바이스를 열 때 호출됨</li>
  <li>.read   : 파일이나 디바이스에서 데이터를 읽을 때 호출됨</li>
  <li>.write  : 파일이나 디바이스에 데이터를 쓸 때 호출됨</li>
  <li>.release: 파일이나 디바이스가 닫힐 때 호출됨 (종종 close 작업으로 참조됨).</li>
  <li>.llseek : 파일 내에서 읽기/쓰기 위치를 변경할 때 호출됨</li>
  <li>.ioctl  : 장치에 특정 명령을 보낼 때 사용됨 (장치 제어).<br /><br /></li>
</ul>

<p>(3) register_chrdev(major, name, fops)  <br /> 
새로운 문자 디바이스 드라이버 등록에 사용되는 API</p>
<ul>
  <li>major : 주번호로 사용할 번호를 지정, (0으로 지정시 커널이 자동 할당)</li>
  <li>name : 디바이스의 이름</li>
  <li>fops : 디바이스 드라이버가 구현할 file_operations</li>
  <li>등록이 성공했다면 0 또는 할당받은 major 번호를 반환, 실패시 음수 반환</li>
</ul>

<p><br />
이제 아래와 같이 수정한 소스 파일을 빌드하여 ko dynamic linker 파일 생성한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 <span class="nv">CROSS_COMPILE</span><span class="o">=</span>/home/gon/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu- make
  CALL    scripts/checksyscalls.sh
  CC <span class="o">[</span>M]  drivers/comento/main.o
  LD <span class="o">[</span>M]  drivers/comento/comento.o
  MODPOST Module.symvers
  LD <span class="o">[</span>M]  drivers/comento/comento.ko
</code></pre></div></div>

<p>rootfs 에 마운트 해당 파일을 마우트 이미지에 삽입</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/<span class="nv">$ </span><span class="nb">sudo </span>mount <span class="nt">-o</span> loop ../buildroot/output/images/rootfs.ext4 /mnt
user@DESKTOP:~/linux/<span class="nv">$ </span><span class="nb">sudo cp </span>drivers/comento/comento.ko /mnt/usr/lib/modules/.
user@DESKTOP:~/linux/<span class="nv">$ </span><span class="nb">sync
</span>user@DESKTOP:~/linux/<span class="nv">$ </span><span class="nb">sudo </span>umount /mnt
</code></pre></div></div>

<p>QEMU 로 커널 실행</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/<span class="nv">$ </span><span class="nb">cd</span> ..
user@DESKTOP:~<span class="nv">$ </span>qemu-system-aarch64 <span class="nt">-kernel</span> linux/arch/arm64/boot/Image <span class="nt">-drive</span> <span class="nv">format</span><span class="o">=</span>raw,file<span class="o">=</span>buildroot/output/images/rootfs.ext4,if<span class="o">=</span>virtio <span class="nt">-append</span> <span class="s2">"root=/dev/vda console=ttyAMA0 nokaslr"</span> <span class="nt">-nographic</span> <span class="nt">-M</span> virt <span class="nt">-cpu</span> cortex-a72 <span class="nt">-m</span> 2G <span class="nt">-smp</span> 2
</code></pre></div></div>

<h4 id="32-디바이스-노드-만들기">3.2 디바이스 노드 만들기</h4>

<p>mknod 명령어로 디바이스 노드를 생성한다. 순서대로 c (문자 디바이스), 177 (기존에 지정한 major 번호) 32 (임의의 minor 번호) 를 입력한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># cd /dev/
# mknod /dev/comento c 177 43
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># cat /dev/comento
cat: can't open '/dev/comento': No such device or address
</code></pre></div></div>

<p>명령어 수행 결과를 확인했을 때, 아직 디바이스 드라이버가 로드되지 않아 찾지 못한다고 나온다. 따라서 아래와 같이 해당 디바이스 드라이버를 등록 시키고 다시 확인해보면,</p>

<h4 id="33-모듈-로드">3.3 모듈 로드</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># insmod /usr/lib/modules/comento.ko
# cat /dev/comento
cat: read error: Invalid argument
</code></pre></div></div>

<p>해당 결과와 같이, 드라이버 노드는 찾은 것 같다. 다만 read 대한 구현이 없기 때문에 해당 에러가 발생하였다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># dmesg
...
comento_module_init
# ls -lah comento
crw-r--r--    1 root     root      177,  43 Feb 29 07:20 comento
</code></pre></div></div>

<p>dmesg 로 init 되었음이 확인 되었으며, (그런데 <code class="language-plaintext highlighter-rouge">comento_device_open</code> 함수 실행 메세지는 안나왔네 ;;) ls 명령어를 통해 <code class="language-plaintext highlighter-rouge">comento</code> 파일이 생성 및 major, minor 번호가 정상적으로 부여되었음을 볼 수 있다.</p>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="device driver" /><category term="device node" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 11]]></summary></entry><entry><title type="html">Kernel Module 만들기</title><link href="http://localhost:4000/kernelmodule01.html" rel="alternate" type="text/html" title="Kernel Module 만들기" /><published>2024-02-28T10:32:20+09:00</published><updated>2024-02-28T10:32:20+09:00</updated><id>http://localhost:4000/kernelmodule01</id><content type="html" xml:base="http://localhost:4000/kernelmodule01.html"><![CDATA[<style>
    summary::-webkit-details-marker {
        display: none;
    }
    summary {
        list-style: none;
    }
</style>

<details><summary></summary>
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
</details>

<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) - Rootfs 빌드 강의 내용 (https://comento.kr/)</p>

<h3 id="1-관련-설정-추가-및-source-code-생성">1. 관련 설정 추가 및 source code 생성</h3>

<p>1.1 드라이버 디렉토리 생성 및 Makefile 에 해당 디렉토리 추가</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">cd </span>linux/drivers
user@DESKTOP:~/linux/drivers<span class="nv">$ </span><span class="nb">mkdir </span>comento
user@DESKTOP:~/linux/drivers<span class="nv">$ </span>vim Makefile
</code></pre></div></div>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">...</span>
<span class="nv">obj-$(CONFIG_DRM_ACCEL)</span>         <span class="o">+=</span> accel/
<span class="nv">obj-$(CONFIG_CDX_BUS)</span>           <span class="o">+=</span> cdx/
<span class="nv">obj-$(CONFIG_DPLL)</span>              <span class="o">+=</span> dpll/

<span class="nv">obj-$(CONFIG_S390)</span>              <span class="o">+=</span> s390/
<span class="c"># 추가 내용
</span><span class="nv">obj-y</span>                           <span class="o">+=</span> comento/ 
</code></pre></div></div>

<p>1.2 drivers Kconfig 에도 추가될 디렉토리 Kconfig 항목 추가</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/drivers<span class="nv">$ </span>vim Kconfig
</code></pre></div></div>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">...</span>
<span class="err">source</span> <span class="s2">"drivers/cdx/Kconfig"</span>

<span class="err">source</span> <span class="s2">"drivers/dpll/Kconfig"</span>

<span class="err">source</span> <span class="s2">"drivers/comento/Kconfig"</span>  <span class="c"># 추가 내용
</span>
<span class="err">endmenu</span>
</code></pre></div></div>

<p>1.3 해당 디렉토리에 Kconfig 파일 추가</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/drivers<span class="nv">$ </span><span class="nb">cd </span>comento
user@DESKTOP:~/linux/drivers/comento<span class="nv">$ </span>vim Kconfig 
</code></pre></div></div>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">menu</span> <span class="s2">"Comento Example Driver"</span>

<span class="err">config</span> <span class="err">COMENTO_EXAMPLE</span>
    <span class="err">tristate</span> <span class="s2">"Comento Example Dirver Module"</span>
    <span class="err">help</span>
        <span class="err">This</span> <span class="err">is</span> <span class="err">an</span> <span class="err">example</span>

<span class="err">endmenu</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">config COMENTO_EXAMPLE</code> : .config 파일에서는 CONFIG prefix 를 붙여 <code class="language-plaintext highlighter-rouge">CONFIG_COMENTO_EXAMPLE</code> 로 사용됨.</li>
</ul>

<p>1.4 해당 디렉토리 내 main.c 로 목적파일이 만들어 질 수 있도록 Makefile 추가</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/drivers/comento<span class="nv">$ </span>vim Makefile
</code></pre></div></div>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">obj-$(CONFIG_COMENTO_EXAMPLE)</span> <span class="o">+=</span> comento.o
<span class="nv">comento-objs</span> <span class="o">+=</span> main.o
</code></pre></div></div>

<p>1.5 linux kernel module 내용을 담은 소스 코드 <code class="language-plaintext highlighter-rouge">main.c</code> 작성</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/drivers/comento<span class="nv">$ </span>vim main.c
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span>  <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">comento_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>  <span class="n">__func__</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">comento_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>  <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">comento_module_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">comento_module_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">"Hello&lt;hello@comento.com&gt;"</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">"Example module"</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL v2"</span><span class="p">);</span>
</code></pre></div></div>
<h4 id="모듈-초기화-및-종료-함수">모듈 초기화 및 종료 함수</h4>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">__init</code> 함수 (comento_module_init): 모듈이 커널에 로드될 때 자동으로 실행됨. <code class="language-plaintext highlighter-rouge">__init</code> 매크로는 이 함수가 초기화 코드에만 사용되며, 초기화 후에는 메모리에서 해제될 수 있음을 커널에 알린다. 이 예에서, printk 함수를 사용하여 커널 로그에 메시지 (<code class="language-plaintext highlighter-rouge">__func__</code> 매크로는 현재 함수 이름의 문자열을 반환) 를 출력한다. <code class="language-plaintext highlighter-rouge">__init</code> 은 init 관련 함수임을 표시한 attribute 이다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">__exit</code> 함수 (comento_module_exit): 모듈이 커널에서 제거될 때 실행됨. <code class="language-plaintext highlighter-rouge">__exit</code> 매크로는 이 함수가 종료 코드에만 사용되며, 모듈이 커널에 계속 로드되어 있는 경우 메모리를 절약하기 위해 해제될 수 있음을 나타낸다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">module_init</code> 매크로
    <ul>
      <li>목적: 커널 모듈이 시스템에 로드될 때 실행될 초기화 함수를 지정</li>
      <li>동작: 지정된 초기화 함수는 모듈이 커널에 삽입될 때(insmod 명령어 사용 시) 자동으로 호출된다. 이 함수 내에서는 모듈이 제대로 작동하기 위해 필요한 리소스 할당, 상태 초기화, 디바이스 등록 등의 작업을 수행한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">module_exit</code> 매크로
    <ul>
      <li>목적: 커널 모듈이 시스템에서 제거될 때 실행될 종료 함수를 지정</li>
      <li>동작: 지정된 종료 함수는 모듈이 커널에서 제거될 때(rmmod 명령어 사용 시) 자동으로 호출된다. 이 함수 내에서는 모듈의 정상적인 종료를 위해 할당된 리소스의 해제, 등록된 디바이스의 등록 해제 등의 작업을 수행한다.</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">MODULE_AUTHOR</code>: 모듈의 작성자.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">MODULE_DESCRIPTION</code>: 모듈에 대한 간단한 설명.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">MODULE_LICENSE</code>: 모듈의 라이선스 유형. “GPL v2”는, 모듈이 GNU General Public License 버전 2에 따라 배포됨을 나타낸다. 이는 모듈이 GPL 호환 코드와 함께 사용되어야 함을 의미한다.</li>
</ul>

<p>1.6 menuconfig 실행하여 항목 추가되었음을 확인하고 설정 반영</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/drivers/comento<span class="nv">$ </span><span class="nb">cd</span> ..
user@DESKTOP:~/linux/drivers<span class="nv">$ </span><span class="nb">cd</span> ..
user@DESKTOP:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 make menuconfig
</code></pre></div></div>
<p>Device Driver 항목 맨 아래 다음과 같이 추가되었음을 확인할 수 있다.</p>

<center><img src="assets\img\posts\2024-02-28-kernelmodule011.png" width="600" /></center>
<p><br /></p>
<center><img src="assets\img\posts\2024-02-28-kernelmodule012.png" width="600" /></center>

<h3 id="2-kernel-build">2. kernel build</h3>

<p>2.1  kernel build</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 <span class="nv">CROSS_COMPILE</span><span class="o">=</span>/home/gon/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu- make 
  CALL    scripts/checksyscalls.sh
  CC <span class="o">[</span>M]  drivers/comento/main.o
  LD <span class="o">[</span>M]  drivers/comento/comento.o
  ...
  CC <span class="o">[</span>M]  drivers/comento/comento.mod.o
  LD <span class="o">[</span>M]  drivers/comento/comento.ko
  ...
</code></pre></div></div>

<p>해당 kernel 을 build 하면 위와 같이 사용자가 작성한 <code class="language-plaintext highlighter-rouge">drivers/comento/main.o</code> 가 gcc 에 의해 빌드되고, 해당 linker script 가 <code class="language-plaintext highlighter-rouge">comento-objs += main.o</code> 에 명시된 대로 <code class="language-plaintext highlighter-rouge">main.o</code> 를 모아서 <code class="language-plaintext highlighter-rouge">obj-$(CONFIG_COMENTO_EXAMPLE) += comento.o</code> 대로 <code class="language-plaintext highlighter-rouge">drivers/comento/comento.o</code> 을 생성한다.</p>

<p>그리고 <code class="language-plaintext highlighter-rouge">commento.o</code> 가 모듈관련 목적 파일 <code class="language-plaintext highlighter-rouge">drivers/comento/comento.mod.o</code> 과 함께 link 되서 linker 가 <code class="language-plaintext highlighter-rouge">drivers/comento/comento.ko</code> 를 만든다.</p>

<h3 id="3-buildroot-이미지에-해당-ko-파일-추가-및-qemu-에서-모듈-로드가-정상적으로-되었는지-확인">3. buildroot 이미지에 해당 ko 파일 추가 및 QEMU 에서 모듈 로드가 정상적으로 되었는지 확인</h3>

<p>3.1 buildroot 이미지에 해당 ko 파일 추가</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo </span>mount <span class="nt">-o</span> loop ../buildroot/output/images/rootfs.ext4 /mnt
user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo mkdir</span> /mnt/usr/lib/modules
user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo cp </span>drivers/comento/comento.ko /mnt/usr/lib/modules
user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sync
</span>user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">sudo </span>umount /mnt
</code></pre></div></div>

<p>3.2 QEMU 실행</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">cd</span> ..
user@DESKTOP:~<span class="nv">$ </span>qemu-system-aarch64 <span class="nt">-kernel</span> linux/arch/arm64/boot/Image <span class="nt">-drive</span> <span class="nv">format</span><span class="o">=</span>raw,file<span class="o">=</span>buildroot/output/images/rootfs.ext4,if<span class="o">=</span>virtio <span class="nt">-append</span> <span class="s2">"root=/dev/vda console=ttyAMA0 nokaslr"</span> <span class="nt">-nographic</span> <span class="nt">-M</span> virt <span class="nt">-cpu</span> cortex-a72 <span class="nt">-m</span> 2G <span class="nt">-smp</span> 2
</code></pre></div></div>

<p>3.3 모듈 추가 확인</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># ls /usr/lib/modules
comento.ko
</code></pre></div></div>

<p>해당 커널에서 삽입한 경로에 보면 <code class="language-plaintext highlighter-rouge">comento.ko</code> 이 정상적으로 추가되어 있음을 볼 수 있다.</p>

<h3 id="4-moudule-load--unload">4. moudule load / unload</h3>

<p>4.1 load</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># insmod /usr/lib/moduels/comento.ko
# dmesg -c
comento_module_init
</code></pre></div></div>
<p>insmod 하여 모듈을 삽입하고 <code class="language-plaintext highlighter-rouge">dmesg</code> 를 하면, <code class="language-plaintext highlighter-rouge">main.c</code> 에 작성 했던 <code class="language-plaintext highlighter-rouge">comento_module_init()</code> 에서 작성한 대로 함수명 (<code class="language-plaintext highlighter-rouge">comento_module_init</code>) 을 출력하게 된다. 아래와 같이 <code class="language-plaintext highlighter-rouge">lsmod</code> 명령어로 현재 로드된 모듈들을 볼 수도 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># lsmod
Module                  Size  Used by
comento                12288  0
</code></pre></div></div>

<p>4.2 unload</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># rmmod comento.ko
# dmesg -c
comento_module_exit
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">rmmod</code> 를 통해 지정된 모듈을 제거 한다. 제거하면서 “comento_module_exit” 메세지가 출력되었음을 볼 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># lsmod
Module                  Size  Used by
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">lsmod</code> 로 보면 이제 로드된 모듈이 없음을 확인할 수 있다.</p>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="kernel module" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 10]]></summary></entry><entry><title type="html">GDB 를 사용 기초 및 systemcall GDB 적용</title><link href="http://localhost:4000/gdp01.html" rel="alternate" type="text/html" title="GDB 를 사용 기초 및 systemcall GDB 적용" /><published>2024-02-25T10:32:20+09:00</published><updated>2024-02-25T10:32:20+09:00</updated><id>http://localhost:4000/gdp01</id><content type="html" xml:base="http://localhost:4000/gdp01.html"><![CDATA[<style>
    summary::-webkit-details-marker {
        display: none;
    }
    summary {
        list-style: none;
    }
</style>

<details><summary></summary>
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
</details>

<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) - Rootfs 빌드 강의 내용 (https://comento.kr/)</p>

<h3 id="gdb-기초">GDB 기초</h3>

<ol>
  <li>GDB 사용을 위한 라이브러리 설치</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>gdb-multiarch
</code></pre></div></div>

<ol>
  <li>GDB 로 관찰할 systemcall 작성</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>vi fact.c
</code></pre></div></div>

<ul>
  <li>test 용 code</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">*=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">ret</span> <span class="o">*=</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"result: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>gcc build</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>gcc <span class="nt">-g</span> fact.c <span class="nt">-o</span> fact 
<span class="c"># -g : 컴파일된 실행 파일에 디버깅 정보를 포함</span>
<span class="c"># GDB를 사용할 때 소스 코드의 라인 번호, 변수 이름 등의 상세한 정보에 접근 가능</span>
</code></pre></div></div>

<ol>
  <li>GDB 실행</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>gdb-multiarch fact
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;https://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from fact...
(gdb)
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) start 10          # --- (1)
Temporary breakpoint 1 at 0x11bd: file fact.c, line 14. # --- (2)
Starting program: /home/gon/fact 10     
[Thread debugging using libthread_db enabled]   --- (3)
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1". # --- (4)

Temporary breakpoint 1, main (argc=2, argv=0x7fffffffe108) at fact.c:14
14          int i = atoi(argv[1]);
</code></pre></div></div>
<p>(1) start 명령은 프로그램을 시작하고, 주어진 프로그램의 첫번째 인자(10)와 함께 메인 함수의 첫 번째 라인에서 일시적인 중단점을 설정.  이렇게 하면 프로그램이 실제로 실행되기 시작하며, 사용자가 프로그램의 초기 상태를 검사할 수 있게 된다.</p>

<p>(2) 현재 중단점 code 상 line 의 위치와 메모리 주소. 즉 main 함수 내 첫번째 줄.</p>

<p>(3) 멀티스레딩 프로그램을 디버깅하기 위해 libthread_db 라이브러리를 사용하고 있음을 표시</p>

<p>(4) 호스트 시스템의 libthread_db 라이브러리를 사용하고 있음을 표시. 이 라이브러리는 스레드와 관련된 정보를 제공하여 디버거가 스레드를 효율적으로 관리할 수 있게 돕는다.</p>

<h3 id="qeme-gdb-적용">QEME GDB 적용</h3>

<ol>
  <li>Debug mode 로 빌드되도록 Linux kernel 설정 변경</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">cd </span>linux
user@DESKTOP:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 make menuconfig 
</code></pre></div></div>

<ul>
  <li>kernel hacking -&gt;  Kernel debugging 선택</li>
  <li>kernel hacking -&gt;  Compile-time checks and compiler options -&gt; Debug information (Disable debug information) -&gt;  Rely on the toolchain’s implicit default DWARF version 선택</li>
</ul>

<ol>
  <li>re-build</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span> make <span class="nt">-j</span>&lt;cpu 수&gt;
</code></pre></div></div>

<ol>
  <li>QEMU 실행</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span><span class="nb">cd</span> ..
user@DESKTOP:~<span class="nv">$ </span>qemu-system-aarch64 <span class="nt">-kernel</span> linux/arch/arm64/boot/Image <span class="nt">-drive</span> <span class="nv">format</span><span class="o">=</span>raw,file<span class="o">=</span>buildroot/output/images/rootfs.ext4,if<span class="o">=</span>virtio <span class="nt">-append</span> <span class="s2">"root=/dev/vda console=ttyAMA0 nokaslr"</span> <span class="nt">-nographic</span> <span class="nt">-M</span> virt <span class="nt">-cpu</span> cortex-a72 <span class="nt">-m</span> 2G <span class="nt">-smp</span> 2 <span class="nt">-s</span> <span class="nt">-S</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">-s</code> : gdb 가 붙을 수 있도록 1234 포트를 열어둠
<code class="language-plaintext highlighter-rouge">-S</code> : QEMU 가 시작하자마자 멈춰있는 상태로 만듬. (break-point 를 걸수 있는 시점을 마련하기 위함)</p>

<p>(실행시 <code class="language-plaintext highlighter-rouge">-S</code> 옵션으로 인해 멈춰있게 됨. 그래서 다른 cli 상에서 <code class="language-plaintext highlighter-rouge">gdb-multiarch</code>를 사용하여 <code class="language-plaintext highlighter-rouge">linux/vmlinux</code> 경로에 위치한 리눅스 커널 이미지를 디버깅 모드로 염)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>gdb-multiarch linux/vmlinux
For <span class="nb">help</span>, <span class="nb">type</span> <span class="s2">"help"</span><span class="nb">.</span>
Type <span class="s2">"apropos word"</span> to search <span class="k">for </span>commands related to <span class="s2">"word"</span>...
Reading symbols from kernel/vmlinux...
<span class="o">(</span>gdb<span class="o">)</span>
</code></pre></div></div>

<p>따라서 vmlinux 내 debugging 정보가 읽어지게 됨.</p>

<ul>
  <li>기존 buildroot 이미지에는 모든 정보가 담겨있는것이 아니라 kernel 을 실행할 수 있는 코드만 포함된 단순화된 파일이다. 따라서 해당 이미지 만으로 모든 디버깅 정보를 볼 수는 없는 환경이다. 그런데 <code class="language-plaintext highlighter-rouge">vmlinux</code> 파일의 경우, 커널의 디버깅 정보, 함수 및 변수 이름 정보, 코드 라인 정보 등이 모두 담긴 목적 파일이므로 <code class="language-plaintext highlighter-rouge">gdb-multiarch linux/vmlinux</code> 와 같이 해당 파일을 디버거 인자로 넘겨 주어야 한다.</li>
</ul>

<p>그리고 gdb prompt 창에 <code class="language-plaintext highlighter-rouge">target remote :1234</code> 를 입력하여 qemu 에서 열어둔 디버깅 포트 1234 에 접속한다. 연결된 이후, 원하는  break-point 를 걸 수 있다.  예를 들면,</p>

<p><code class="language-plaintext highlighter-rouge">(gdb) break start_kernel</code> 로 입력하면 리눅스 커널에서 제일 먼저 실행되는 c 함수에 중단점을 생성하고,</p>

<p><code class="language-plaintext highlighter-rouge">(gdb)__do_sys_&lt;시스템콜 함수 이름&gt;</code> 의 겅우 앞서 실습한 systemcall 을 디버깅 가능하다. 여기에서 <code class="language-plaintext highlighter-rouge">__do_sys_</code> 접두사는 SYSCALL_DEFINE 매크로가 자동 생성한 것이다.</p>

<ol>
  <li>QEMU 가 연 포트에 접근</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set </span>architecture aarch64
<span class="o">(</span>gdb<span class="o">)</span> target remote :1234
Remote debugging using :1234
warning: Selected architecture i386:x86-64 is not compatible with reported target architecture aarch64
warning: Architecture rejected target-supplied description
0x0000000000000000 <span class="k">in </span>fixed_percpu_data <span class="o">()</span>  <span class="c"># bootloader 의 첫 시작 주소</span>
</code></pre></div></div>

<ol>
  <li>break-point 걸기</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">start_kernel</code> 이라는 가장 처음에 시작되는 함수에 break-point 걸기</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break </span>start_kernel
Breakpoint 1 at 0xffffffff821889e0: file init/main.c, line 875.
</code></pre></div></div>

<p>우리가 추가한 systemcall 함수 break-point 걸기</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break </span>__do_sys_new_syscall
Breakpoint 2 at 0xffffffff811391c9: file kernel/new_syscall.c, line 6.
</code></pre></div></div>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="systemcall" /><category term="gdb-multiarch" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 09]]></summary></entry><entry><title type="html">systemcall 기초 1</title><link href="http://localhost:4000/systemcall01.html" rel="alternate" type="text/html" title="systemcall 기초 1" /><published>2024-02-24T10:32:20+09:00</published><updated>2024-02-24T10:32:20+09:00</updated><id>http://localhost:4000/systemcall01</id><content type="html" xml:base="http://localhost:4000/systemcall01.html"><![CDATA[<style>
    summary::-webkit-details-marker {
        display: none;
    }
    summary {
        list-style: none;
    }
</style>

<details><summary></summary>
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
에러방지  에러방지 에러방지  에러방지 에러방지  에러방지 에러방지  에러방지
</details>

<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) - Rootfs 빌드 강의 내용 (https://comento.kr/)</p>

<h4 id="1-syscall_define-매크로">1. SYSCALL_DEFINE 매크로</h4>

<p>1.1 생성할 systemcall 이 추가될 linux 디렉토리 내 해당 source 추가</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">cd </span>linux/kernel
user@DESKTOP:~/linux/kernel<span class="nv">$ </span>vim new_syscall.c
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="c1"> // kenel 에서 사용할 soruce code 에 필요한 라이브러리</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/syscalls.h&gt;</span><span class="c1"> // SYSCALL_DEFINE 매크로를 사용하기 위한 라이브러리</span><span class="cp">
</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">new_syscall</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span> <span class="c1">// SYSCALL_DEFINE 매크로 + 1개 인자 (system call  이름, (첫번째)인자 타입, (첫번째)인자 이름)</span>
<span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"Hello World~!!!! %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span> <span class="c1">// syscall 호출 확인을 위해 log 출력 \n 로 종료해야 시스템이 해당 로그 message 가 종료 되었음을 인지함. (없으면 종료 상태가 결정되지 않아 원하는 시점에 출력 되지 않을 수 있음.)</span>
    <span class="k">return</span> <span class="n">code</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>1.2 Makefile 수정</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/kernel<span class="nv">$ </span>vi Makefile
</code></pre></div></div>

<p>해당 파일에 다음과 같이 반드시 실행되는 목적 파일들이 <code class="language-plaintext highlighter-rouge">obj-y</code> 로 나열되어 있다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">obj-y</span>     <span class="o">=</span> fork.o exec_domain.o panic.o <span class="se">\</span>
            cpu.o exit.o softirq.o resource.o <span class="se">\</span>
            sysctl.o capability.o ptrace.o user.o <span class="se">\</span>
            signal.o sys.o umh.o workqueue.o pid.o task_work.o <span class="se">\</span>
            extable.o params.o <span class="se">\</span>
            kthread.o sys_ni.o nsproxy.o <span class="se">\</span>
            notifier.o ksysfs.o cred.o reboot.o <span class="se">\</span>
            async.o range.o smpboot.o ucount.o regset.o ksyms_common.o
</code></pre></div></div>

<p>이 변수에 지정된 오브젝트 파일들은 커널 빌드 과정에서 항상 포함된다. 그 밖에,</p>

<p><code class="language-plaintext highlighter-rouge">obj-m</code>: 모듈로 빌드될 오브젝트 파일들을 지정한다. 이 변수에 지정된 항목들은 커널 모듈로 컴파일되며, 필요에 따라 동적으로 커널에 로드하거나 언로드할 수 있다.</p>

<p><code class="language-plaintext highlighter-rouge">obj-n</code>: 빌드에서 제외될 오브젝트 파일을 지정한다. 이는 해당 항목이 커널 빌드 과정에서 무시됨을 의미.</p>

<p><code class="language-plaintext highlighter-rouge">obj-$(CONFIG명)</code> 항목들의 경우, 관련 CONFIG 설정이 <code class="language-plaintext highlighter-rouge">y</code> 라면 실행되지만, 그렇지 않은 경우 실행되지 않는다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">obj-$(CONFIG_USERMODE_DRIVER)</span> <span class="o">+=</span> usermode_driver.o
<span class="nv">obj-$(CONFIG_MULTIUSER)</span> <span class="o">+=</span> groups.o
<span class="nv">obj-$(CONFIG_VHOST_TASK)</span> <span class="o">+=</span> vhost_task.o
</code></pre></div></div>

<p>해당 항목의 config 값 설정을 보려면 .config 파일에서 찾아 볼 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/kernel<span class="nv">$ </span>vim ../.config
</code></pre></div></div>

<p>해당 파일을 열어보면, <code class="language-plaintext highlighter-rouge">CONFIG_MULTIUSER=y</code> 만 존재한다.</p>

<p>이것은 곧, <code class="language-plaintext highlighter-rouge">CONFIG_MULTIUSER</code> 의 값은 y 로 <code class="language-plaintext highlighter-rouge">obj-y</code>로 설정, 빌드 및 실행에 적용되나, <code class="language-plaintext highlighter-rouge">CONFIG_USERMODE_DRIVER</code>, <code class="language-plaintext highlighter-rouge">CONFIG_VHOST_TASK</code> 는 존재하지 않으므로, <code class="language-plaintext highlighter-rouge">obj-</code> 상태이므로 kernel build 및 실행 시 영향이 없으므로 삭제하여도 동일한 상태임을 확인할 수 있다.</p>

<p>해당 상태는  menuconfig 화면에서도 확인 가능하다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux/kernel<span class="nv">$ </span><span class="nb">cd</span> ..
user@DESKTOP:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 make menuconfig
</code></pre></div></div>
<p>화면에서 <code class="language-plaintext highlighter-rouge">/</code> 를 눌러서 찾게 모드 사용 (vi 와 동일). <code class="language-plaintext highlighter-rouge">CONFIG_MULTIUSER</code> 검색 시.</p>

<center><img src="assets\img\posts\2024-02-24-systemcall011.png" width="600" /></center>

<p>해당 Symbol 설정이 <code class="language-plaintext highlighter-rouge">=y</code> 로 되어 있으나,</p>

<center><img src="assets\img\posts\2024-02-24-systemcall012.png" width="600" /></center>

<p><code class="language-plaintext highlighter-rouge">CONFIG_USERMODE_DRIVER</code> 의 경우 <code class="language-plaintext highlighter-rouge">=n</code> 임을 확인할 수 있다.</p>

<p>위와 같이, <code class="language-plaintext highlighter-rouge">obj-y</code> 를 사용하여 새로 작성한 ‘new_syscall<code class="language-plaintext highlighter-rouge"> 을 </code>Makefile` 에 추가해 준다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CFLAGS_stackleak.o</span> <span class="o">+=</span> <span class="p">$(</span>DISABLE_STACKLEAK_PLUGIN<span class="p">)</span>
<span class="nv">obj-$(CONFIG_GCC_PLUGIN_STACKLEAK)</span> <span class="o">+=</span> stackleak.o
<span class="nv">KASAN_SANITIZE_stackleak.o</span> <span class="o">:=</span> n
<span class="nv">KCSAN_SANITIZE_stackleak.o</span> <span class="o">:=</span> n
<span class="nv">KCOV_INSTRUMENT_stackleak.o</span> <span class="o">:=</span> n

<span class="nv">obj-$(CONFIG_SCF_TORTURE_TEST)</span> <span class="o">+=</span> scftorture.o

<span class="c"># obj- 추가 가장 마지막 항목으로 신규 systemcall 추가
</span><span class="nv">obj-y</span> <span class="o">+=</span> new_syscall.o

<span class="nl">$(obj)/configs.o</span><span class="o">:</span> <span class="nf">$(obj)/config_data.gz</span>

<span class="nv">targets</span> <span class="o">+=</span> config_data config_data.gz
<span class="nl">$(obj)/config_data.gz</span><span class="o">:</span> <span class="nf">$(obj)/config_data FORCE</span>
        <span class="nf">$(</span><span class="nb">call</span> if_changed,gzip<span class="p">)</span>

<span class="nv">filechk_cat</span> <span class="o">=</span> <span class="nb">cat</span> <span class="nv">$&lt;</span>
</code></pre></div></div>

<h4 id="2-커널에-새로운-소스-코드-추가">2. 커널에 새로운 소스 코드 추가</h4>

<p>2.1 systemcall 번호 할당</p>

<p><code class="language-plaintext highlighter-rouge">linux/include/uapi/asm-generic/unistd.h</code> 파일은 표준 시스템 호출 번호를 정의하는 파일이다. Linux 에서 systemcall 은 user 프로그램이 커널의 기능을 요청할 때 사용되는 메커니즘이다. 이러한 systemcall을 통해 파일 작업, 프로세스 관리, 통신 등의 작업을 수행할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span>vim include/uapi/asm-generic/unistd.h
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>

<span class="n">__SYSCALL</span><span class="p">(</span><span class="n">__NR_futex_wait</span><span class="p">,</span> <span class="n">sys_futex_wait</span><span class="p">)</span>
<span class="cp">#define __NR_futex_requeue 456
</span><span class="n">__SYSCALL</span><span class="p">(</span><span class="n">__NR_futex_requeue</span><span class="p">,</span> <span class="n">sys_futex_requeue</span><span class="p">)</span> <span class="c1">// (1)</span>

<span class="cp">#undef __NR_syscalls
#define __NR_syscalls 457 // 기존 마지막 syscall 번호
</span></code></pre></div></div>
<p>(1) <code class="language-plaintext highlighter-rouge">__NR_futex_requeue</code> : 정의된 시스템 호출의 고유 번호
    <code class="language-plaintext highlighter-rouge">sys_futex_requeue</code> : 정의된 시스템 호출에 대응하는 커널 함수의 이름</p>

<p>457 번 syscall 을 추가하고 마지막 번호를 458 로 변경한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>

<span class="n">__SYSCALL</span><span class="p">(</span><span class="n">__NR_futex_wait</span><span class="p">,</span> <span class="n">sys_futex_wait</span><span class="p">)</span>
<span class="cp">#define __NR_futex_requeue 456
</span><span class="n">__SYSCALL</span><span class="p">(</span><span class="n">__NR_futex_requeue</span><span class="p">,</span> <span class="n">sys_futex_requeue</span><span class="p">)</span>

<span class="cp">#define __NR_new_syscall 457
</span><span class="n">__SYSCALL</span><span class="p">(</span><span class="n">__NR_new_syscall</span><span class="p">,</span> <span class="n">sys_new_syscall</span><span class="p">)</span> <span class="c1">// SYSCALL_DEFINE macro 를 사용함</span>

<span class="cp">#undef __NR_syscalls
#define __NR_syscalls 458
</span></code></pre></div></div>

<p>여기서 사용한 SYSCALL_DEFINE macro 의 내용은  <code class="language-plaintext highlighter-rouge">syscall_wrapper.h</code> 에 포함되어 있으며 architecture 마다 다르므로 아래 경로 파일에서 확인 가능하다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ </span>vi <span class="nb">arch</span>/arm64/include/asm/syscall_wrapper.h
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define COMPAT_SYSCALL_DEFINEx(x, name, ...)                                            \
        asmlinkage long __arm64_compat_sys##name(const struct pt_regs *regs);           \
        ALLOW_ERROR_INJECTION(__arm64_compat_sys##name, ERRNO);                         \
        static long __se_compat_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));              \
        static inline long __do_compat_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));       \
        asmlinkage long __arm64_compat_sys##name(const struct pt_regs *regs)            \
        {                                                                               \
                return __se_compat_sys##name(SC_ARM64_REGS_TO_ARGS(x,__VA_ARGS__));     \
        }                                                                               \
        static long __se_compat_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))               \
        {                                                                               \
                return __do_compat_sys##name(__MAP(x,__SC_DELOUSE,__VA_ARGS__));        \
        }                                                                               \
        static inline long __do_compat_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))
</span></code></pre></div></div>

<h4 id="3-커널에-새로운-시스템콜-추가">3. 커널에 새로운 시스템콜 추가</h4>

<p>3.1 build 진행 (이미지 생성)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 <span class="nv">CROSS_COMPILE</span><span class="o">=</span>/home/gon/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu- make <span class="nt">-j16</span>
</code></pre></div></div>

<h4 id="4-새로운-시스템콜을-사용하는-응용프로그램-만들기">4. 새로운 시스템콜을 사용하는 응용프로그램 만들기</h4>

<p>4.1 응용 프로그램 추가</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>vi hello.c
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="c1"> // syscall 함수 포함</span><span class="cp">
</span>
<span class="cp">#define  __NR_new_syscall 457 // 커널 쪽 unistd.h 에는 추가하였으나, toolchaing 측 unistd.h 에는 추가히자 않았으며로 여기에서 명시해줌
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">syscall</span><span class="p">(</span><span class="n">__NR_new_syscall</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"ret : %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>4.2 응용 프로그램 빌드</p>

<p>여기서 빌드될 응용 프로그램은 앞에서 작업한 커널 이미지를 QEMU 를 통해 실행한 환경에서 사용할 것이므로 단순 <code class="language-plaintext highlighter-rouge">gcc</code> 아닌 해당 toolchain 을 사용하여 빌드해야 한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-gcc <span class="nt">-o</span> hello hello.c
</code></pre></div></div>

<p>제대로 빌드되었는지 생서된 실행파일의 정보를 확인한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>file hello
hello: ELF 64-bit LSB executable, ARM aarch64, version 1 <span class="o">(</span>SYSV<span class="o">)</span>, dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, <span class="k">for </span>GNU/Linux 3.7.0, with debug_info, not stripped
</code></pre></div></div>

<p>위와 같이 <code class="language-plaintext highlighter-rouge">ARM aarch64</code> 로 정상적으로 빌드되었음을 확인할 수 있다.</p>

<h4 id="5-새로운-시스템콜-실행하기">5. 새로운 시스템콜 실행하기</h4>

<p>5.1 빌드한 프로그램을 rootfs 이미지 내로 (<code class="language-plaintext highlighter-rouge">/usr/bin</code>) 에 복사하기</p>

<p>해당 작업은 mnt 디렉토리에 mount 하여 사용할 수 있다. 여깃 <code class="language-plaintext highlighter-rouge">/mnt</code> 는 일반적으로 임시적으로 mount 할 공간이 필요할 경우 사용되는 디렉토리이다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">sudo </span>mount <span class="nt">-o</span> loop buildroot/output/images/rootfs.ext4 /mnt
</code></pre></div></div>
<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">-o loop</code> : loop는 이 옵션의 인자로, 일반적인 파일 시스템이 아닌 파일(예: 이미지 파일)을 마운트할 때 사용되는 옵션. loop 장치를 사용하면, 파일을 마치 별도의 물리적 드라이브인 것처럼 마운트할 수 있다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">buildroot/output/images/rootfs.ext4</code> : 리눅스 루트 파일 시스템 중 ext4 파일 시스템 포맷을 사용하는 이미지</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">/mnt</code> : 이는 마운트 포인트를 지정</p>
  </li>
</ul>

<p>이러게 마우트된 파일 시스템에 앞에서 필드한 <code class="language-plaintext highlighter-rouge">hello</code> 를 복사한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">sudo cp </span>hello /mnt/usr/bin
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">sync</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">sync</code> 명령어는 리눅스 및 유닉스 계열 운영 시스템에서 사용되며, 메모리에 버퍼링된 파일 시스템의 쓰기 작업을 디스크에 강제로 동기화하는 역할을 한다. 시스템이 정상적으로 셧다운되기 전이나 중요한 파일 시스템 작업을 수행한 후 데이터의 손실을 방지하기 위해 사용된다.</p>

<p><code class="language-plaintext highlighter-rouge">sync</code> 명령어를 사용하면, 이러한 버퍼링된 모든 쓰기 작업이 완료되고 디스크에 안전하게 저장될 때까지 기다린다. 명령어는 별도의 출력 없이 실행되며, 명령이 완료되면 모든 변경 사항이 디스크에 반영된 상태가 된다.</p>

<p>이렇게 작업이 <code class="language-plaintext highlighter-rouge">hello</code> 실행 파일을 이미지에 추가시킨 후 마우트 해제한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span><span class="nb">sudo </span>umount /mnt
</code></pre></div></div>

<p>5.2 QEMU 실행하기</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@DESKTOP:~<span class="nv">$ </span>qemu-system-aarch64 <span class="nt">-kernel</span> linux/arch/arm64/boot/Image <span class="nt">-drive</span> <span class="nv">format</span><span class="o">=</span>raw,file<span class="o">=</span>buildroot/output/images/rootfs.ext4,if<span class="o">=</span>virtio <span class="nt">-append</span> <span class="s2">"root=/dev/vda console=ttyAMA0 nokaslr"</span> <span class="nt">-nographic</span> <span class="nt">-M</span> virt <span class="nt">-cpu</span> cortex-a72 <span class="nt">-m</span> 2G <span class="nt">-smp</span> 2
</code></pre></div></div>

<ol>
  <li>buildroot 내에서 추가한 systemcall 동작 확인</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># hello</span>
Hello World~!!!! 15
ret : 16
</code></pre></div></div>

<p>위와 같이, linux rootfs 에 추가한 <code class="language-plaintext highlighter-rouge">hello</code> 실행 파일을 바로 실행 시킬 수 있으며, 그 실행 과정에서 <code class="language-plaintext highlighter-rouge">new_syscall</code> 의 <code class="language-plaintext highlighter-rouge">printk(KERN_INFO "Hello World~!!!! %d\n", code); </code> 가 실행되어 <code class="language-plaintext highlighter-rouge">Hello World~!!!! 15</code> 가 출력 되고, 다시 <code class="language-plaintext highlighter-rouge">hello</code> 의 <code class="language-plaintext highlighter-rouge">printf("ret : %d\n", ret);</code> 실행으로 <code class="language-plaintext highlighter-rouge">ret : 16</code> 가 출력됨을 확인할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dmesg</span>
...
virtio_net virtio0 enp0s1: renamed from eth0
random: crng init <span class="k">done
</span>Hello World~!!!! 15
</code></pre></div></div>
<p>커널에서 프린트 되는 모든 로그 메세지 출력해보면, 해당 systemcall 이 실행되면서 출력된 로그값이 마지막에 존재하는 것을 확인할 수 있다.</p>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="systemcall" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 08]]></summary></entry><entry><title type="html">Buildroot 설치 및 Kernel build</title><link href="http://localhost:4000/buildroot-setting01.html" rel="alternate" type="text/html" title="Buildroot 설치 및 Kernel build" /><published>2024-02-22T10:32:20+09:00</published><updated>2024-02-22T10:32:20+09:00</updated><id>http://localhost:4000/buildroot-setting01</id><content type="html" xml:base="http://localhost:4000/buildroot-setting01.html"><![CDATA[<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) - Rootfs 빌드 강의 내용 (https://comento.kr/)</p>

<h3 id="1-buildroot--다운로드-및-설치">1. buildroot  다운로드 및 설치</h3>

<h3 id="11-buildroot--다운로드">1.1 buildroot  다운로드</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span>git clone git://git.buildroot.net/buildroot
</code></pre></div></div>

<h4 id="12-qemu-설정">1.2 qemu 설정</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span> <span class="nb">sudo </span>apt-get <span class="nb">install </span>libncurses-dev <span class="c"># 필수 라이브러리 설치</span>
root@:~<span class="nv">$ </span><span class="nb">cd </span>buildroot
root@:~/buildroot<span class="nv">$ </span><span class="nb">ls </span>configs  <span class="c"># config 종류 확인</span>
root@:~/buildroot<span class="nv">$ </span>make qemu_aarch64_virt_defconfig
root@:~/buildroot<span class="nv">$ </span>make menuconfig
</code></pre></div></div>

<center><img src="assets\img\posts\2024-02-22-buildroot-setting01.png" width="600" /></center>

<p>다음과 같이 설정을 진행</p>

<ul>
  <li>system configuration -&gt; init system -&gt; systemd 선택</li>
  <li>kernel -&gt; linux kernel  해제</li>
  <li>target packages -&gt; text editors -&gt; vim -&gt; target packages -&gt; libaries -&gt; Crypto -&gt; openssl support 선택 -&gt; openssl binary 도 선택</li>
  <li>Filesystem images -&gt; ext2/3/4 -&gt; ext4 -&gt; exact size -&gt; 128M</li>
  <li>host utilities -&gt; 모두 선택 해제 (해제 불가 항목은 그대로 둠) -&gt; 최종 exit -&gt; 저장</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/buildroot<span class="nv">$ </span><span class="nb">cat</span> /proc/cpuinfo | <span class="nb">grep </span>processor | <span class="nb">wc</span> <span class="nt">-l</span> <span class="c"># cpu 갯수 확인</span>
root@:~/buildroot<span class="nv">$ </span>make <span class="nt">-j</span>&lt;cpu 수&gt;
</code></pre></div></div>

<h4 id="13-에러-처리">1.3 에러 처리</h4>

<p>다만 해당 실행 시 에러가 발생하였는데 관련 내용은 다음과 같다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/buildroot<span class="nv">$ </span>make <span class="nt">-j</span>&lt;cpu 수&gt;
Your PATH contains spaces, TABs, and/or newline <span class="o">(</span><span class="se">\n</span><span class="o">)</span> characters.
This doesn<span class="s1">'t work. Fix you PATH.
make: *** [support/dependencies/dependencies.mk:27: dependencies] Error 1
</span></code></pre></div></div>

<p>이 에러 메시지는 Linux 시스템의 PATH 환경 변수에 공백, 탭(TABs), 또는 줄바꿈 문자(newline, \n)가 포함되어 있어서 발생한 것이다. make와 같은 빌드 시스템에서는 PATH 환경 변수를 사용하여 필요한 실행 파일들을 찾는다. 만약 PATH에 이러한 특수 문자가 포함되어 있다면, 빌드 프로세스가 제대로 실행 파일들을 찾지 못하게 되어 오류가 발생하게 된다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/buildroot<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$PATH</span>
</code></pre></div></div>

<p>이 명령어를 실행하면 PATH에 설정된 디렉토리들이 콜론(:)으로 구분되어 출력된다. 여기서 공백, 탭, 또는 줄바꿈 문자가 있는지 확인해보니 몇 군데 공백이 확인 되었다. 따라서, PATH에서 문제가 되는 문자를 아래와 같이 제거함.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/buildroot<span class="nv">$ </span><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="nv">$PATH</span> | <span class="nb">tr</span> <span class="nt">-d</span> <span class="s1">' \t\n'</span><span class="si">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">echo $PATH</code> 로 제거가 되었는지 확인한 이후, 다시 make 실행에 unzip 이 설치되어 있지 않다고 에러가 발생하여 이를 설치하였다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/buildroot<span class="nv">$ </span><span class="nb">sudo </span>apt-get update
root@:~/buildroot<span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>unzip
</code></pre></div></div>

<h4 id="14-buildroot-설치">1.4 buildroot 설치</h4>

<p>그리고 최종적으로 make 를 실행하여 설치함 (20 여분 소요)</p>

<p>해당 작업을 통해 Buildroot 는 위 설정에 따라 다음의 주요 작업을 진행, embedded system S/W stackt 을 빌드 한다.</p>

<ol>
  <li>
    <p>구성 검증: Buildroot는 .config 파일이나 다른 구성 파일에 정의된 설정을 검증한다. 이 설정은 make menuconfig, make xconfig 또는 make nconfig와 같은 명령어를 통해 사전에 사용자에 의해 정의 것들 이다..</p>
  </li>
  <li>
    <p>툴체인(Toolchain) 빌드 또는 다운로드: 툴체인은 컴파일러, 링커, 라이브러리 등 임베디드 소프트웨어를 컴파일하기 위해 필요한 도구들의 집합이다. Buildroot는 선택된 설정에 따라 적절한 툴체인을 빌드하거나 사전에 빌드된 툴체인을 다운로드한다. 다만 현재의 설정에서 toolchain 빌드는 따로 진행된다.</p>
  </li>
  <li>
    <p>리눅스 커널 빌드: 사용자가 지정한 버전의 리눅스 커널을 다운로드하고, 필요한 패치를 적용한 후 커널을 크로스 컴파일한다. 역시 현재의 설정에서 커널 빌드는 따로 진행된다.</p>
  </li>
  <li>
    <p>루트 파일 시스템(Root Filesystem) 구성: Buildroot는 사용자가 선택한 모든 소프트웨어 패키지를 다운로드하고, 이들을 크로스 컴파일하여 루트 파일 시스템을 구성. 이 과정에는 라이브러리, 시스템 유틸리티, 애플리케이션 등이 포함된다.</p>
  </li>
  <li>
    <p>부트로더(Bootloader) 빌드: 필요한 경우, 선택된 부트로더(예: U-Boot)를 빌드.</p>
  </li>
  <li>
    <p>이미지 생성: 모든 빌드 과정이 완료되면, Buildroot는 이들을 통합하여 임베디드 시스템을 위한 최종 이미지(예: SD 카드 이미지, NAND 플래시 이미지)를 생성한다. 이 이미지는 실제 하드웨어에서 직접 부팅할 수 있다. 3 번과 마찬가지로 현재 설정에서 해당 과정은 별도로 커널 빌드 때 진행된다.</p>
  </li>
</ol>

<h3 id="2-kernel-build-다운로드-및-이미지-생성">2. Kernel Build 다운로드 및 이미지 생성</h3>

<h4 id="21-kernel-download-httpskernelorg">2.1 kernel download (https://kernel.org/)</h4>

<center><img src="assets\img\posts\2024-02-22-buildroot-setting012.png" width="600" /></center>

<p>해당 사이트 git 주소 -&gt; “stable/linux” 검색 해서 나온 kernel/git/stable/linux.git 경로를 git clone 하여 다운 받음.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/buildroot<span class="nv">$ </span><span class="nb">cd</span> ..
root@:~<span class="nv">$ </span>git clone https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/
</code></pre></div></div>
<p>-&gt;  linux 디렉토리에 해당 repository 파일 다운로드 완료</p>

<h4 id="22-kernel-build-에-필요한-라이브러리-설치">2.2 kernel build 에 필요한 라이브러리 설치</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>bison flex libelf-dev libssl-dev
</code></pre></div></div>

<p>(각 라이브러리 들의 기능에 대한 이해는 부족한 상태임. 추가학습 필요)</p>

<ol>
  <li>Bison</li>
</ol>

<ul>
  <li>용도: bison은 GNU 프로젝트의 구문 분석기 생성기로, 커널 소스 코드 내의 구문을 분석하는 데 사용된다. 커널 빌드 과정에서는 특히 커널의 구성 설정 도구인 kconfig에 의해 사용됨.</li>
</ul>

<ol>
  <li>Flex</li>
</ol>

<ul>
  <li>용도: flex는 텍스트 스캔을 위한 패턴 매칭을 수행하는 렉서(lexer) 또는 스캐너(scanner) 생성기. lex의 GNU 버전으로, 텍스트 입력 스트림에서 패턴을 인식하고 처리하는 프로그램을 생성한다. bison과 함께 kconfig에 의해 사용되며, 커널의 설정 옵션을 해석하고 처리하는 데 필요.</li>
</ul>

<ol>
  <li>libelf-dev</li>
</ol>

<ul>
  <li>용도: libelf-dev는 ELF(Executable and Linkable Format) <a href="https://doitnow-man.tistory.com/entry/ELF-1-ELF-%EB%9E%80">(참고 자료 : ELF 란?)</a> 파일을 다루기 위한 개발 라이브러리. ELF 파일 포맷은 리눅스 시스템에서 실행 파일, 오브젝트 코드, 공유 라이브러리, 코어 덤프 등을 위해 사용. 커널 모듈과 같은 ELF 형식의 바이너리 파일을 생성하고 조작하는 데 사용되므로 커널 모듈을 빌드하고 분석하는 데 필수적.</li>
</ul>

<ol>
  <li>libssl-dev</li>
</ol>

<ul>
  <li>용도: libssl-dev는 OpenSSL 라이브러리의 개발 버전 패키지. OpenSSL은 네트워크 연결에 대한 암호화 통신을 제공하는 라이브러리로, SSL(Secure Sockets Layer)과 TLS(Transport Layer Security) 프로토콜을 구현한다. 커널에서는 예를 들어, 보안 통신이 필요한 네트워크 기능을 개발할 때 이 라이브러리가 사용될 수 있다.</li>
</ul>

<h4 id="23-buildroot-에-있는-config-복사-및-config-파일-생성">2.3 buildroot 에 있는 config 복사 및 .config 파일 생성</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/linux<span class="nv">$ </span><span class="nb">cp</span> ../buildroot/board/qemu/aarch64-virt/linux.config <span class="nb">arch</span>/arm64/configs/qemu_defconfig
root@:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 make qemu_defconfig <span class="c"># 반환값으로 .config 생성</span>
</code></pre></div></div>

<h4 id="24-kernel-build-를-위한-toolchain-download-httpsdeveloperarmcom">2.4 kernel build 를 위한 toolchain download (https://developer.arm.com/)</h4>

<p>-&gt; Tools and Software -&gt; Compilers and Libraries -&gt; Arm GNU toolchain -&gt; GNU Toolchain releases for A-profile processors -&gt; GNU-A Downloads (https://developer.arm.com/downloads/-/gnu-a) -&gt; AArch64 GNU/Linux target (aarch64-none-linux-gnu) (gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz) 다운로드</p>

<hr />

<p>(해당 작업을 wsl2 로 설치한 ubuntu 로 진행하는 경우 다운로드 파일은 windows file system) 내부로 들어오게 된다. 이것을 linux 로 복사하기 위해서는 다음과 같이 복사 및 압풀 해제를 진행한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/linux<span class="nv">$ </span><span class="nb">cd</span> ..
root@:~<span class="nv">$ </span><span class="nb">cp</span> /mnt/c/Users/&lt;사용자 이름&gt;/Downloads/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz <span class="nb">.</span>
</code></pre></div></div>

<p>또는</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span>wget https://developer.arm.com/-/media/Files/downloads/gnu-a/10.3-2021.07/binrel/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz

</code></pre></div></div>

<h4 id="25-toolchain-압축-풀기">2.5 toolchain 압축 풀기</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span> <span class="nb">tar </span>xvf gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz
</code></pre></div></div>

<h4 id="26-build-진행-이미지-생성">2.6 build 진행 (이미지 생성)</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span><span class="nb">cd </span>linux
root@:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 <span class="nv">CROSS_COMPILE</span><span class="o">=</span>/home/gon/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu- make <span class="nt">-j16</span>
</code></pre></div></div>
<center><img src="assets\img\posts\2024-02-22-buildroot-setting013.png" width="400" /></center>

<p>build 가 완료되면 위와 같이  vmlinux 를 생성하고 이것을 가지고 arch/arm64/boot/Image 가 생성된것을 확인할 수 있다.</p>

<h3 id="3-buildroot-이미지-실행">3. buildroot 이미지 실행</h3>

<h4 id="31-qemu-설치">3.1 QEMU 설치</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span><span class="nb">sudo </span>apt <span class="nb">install </span>qemu-system-arm
</code></pre></div></div>

<h4 id="32-이미지-실행">3.2 이미지 실행</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span>qemu-system-aarch64 <span class="se">\</span>
 <span class="nt">-kernel</span> linux/arch/arm64/boot/Image <span class="se">\</span>
 <span class="nt">-drive</span> <span class="nv">format</span><span class="o">=</span>raw,file<span class="o">=</span>buildroot/output/images/rootfs.ext4,if<span class="o">=</span>virtio <span class="se">\</span>
 <span class="nt">-append</span> <span class="s2">"root=/dev/vda console=ttyAMA0 nokaslr"</span> <span class="se">\</span>
 <span class="nt">-nographic</span> <span class="nt">-M</span> virt <span class="nt">-cpu</span> cortex-a72 <span class="se">\</span>
 <span class="nt">-m</span> 2G <span class="se">\</span>
 <span class="nt">-smp</span> 2
</code></pre></div></div>

<center><img src="assets\img\posts\2024-02-22-buildroot-setting014.png" width="600" /></center>

<h4 id="33-이미지-종료">3.3 이미지 종료</h4>

<p>터미널 창을 별도로 열어서 kill 명령어로 종료</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">kill</span> <span class="nt">-9</span> qemu-system-aarch64
</code></pre></div></div>

<p>또는 qemu 내에서 shutdown 명령어로 종료</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shutdown <span class="nt">-h</span> now
</code></pre></div></div>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="buildroot" /><category term="kernel build" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 06]]></summary></entry><entry><title type="html">Makefile 기본 문법 01</title><link href="http://localhost:4000/makfile01.html" rel="alternate" type="text/html" title="Makefile 기본 문법 01" /><published>2024-02-21T14:32:20+09:00</published><updated>2024-02-21T14:32:20+09:00</updated><id>http://localhost:4000/makfile01</id><content type="html" xml:base="http://localhost:4000/makfile01.html"><![CDATA[<h3 id="makefile-변수-macro-사용">Makefile 변수 (macro) 사용</h3>

<p>의존성 부분은 일반적으로 매크로로 선언하여 사용함.</p>

<p>매크로를 사용하여 값을 할당할 때, 여러가지 할당 방법이 존재</p>

<h4 id="-recursive-assignment"><code class="language-plaintext highlighter-rouge">=</code> (Recursive Assignment)</h4>
<p><code class="language-plaintext highlighter-rouge">=</code> 연산자는 재귀적 할당을 수행한다. 이는 매크로가 사용될 때마다 평가되어 확장된다. 매크로의 값이 다른 매크로를 참조하는 경우, 참조된 변수의 최종값에 따라 달라진다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">FOO</span> <span class="o">=</span> <span class="p">${</span>BAR<span class="p">}</span>
<span class="nv">BAR</span> <span class="o">=</span> bar_value

<span class="nl">all</span><span class="o">:</span>
        <span class="err">@echo</span> <span class="err">$(FOO)</span>
</code></pre></div></div>

<p>해당 Makefile 을 실행하면 <code class="language-plaintext highlighter-rouge">FOO</code> 매크로는 <code class="language-plaintext highlighter-rouge">BAR</code>의 값을 참조한다. 따라서 실행될 때, <code class="language-plaintext highlighter-rouge">BAR</code> 의 값은 <code class="language-plaintext highlighter-rouge">bar_value</code> 이므로  <code class="language-plaintext highlighter-rouge">bar_value</code> 가 출력된다.</p>

<h4 id="-simle-assignment"><code class="language-plaintext highlighter-rouge">:=</code> (Simle Assignment)</h4>
<p><code class="language-plaintext highlighter-rouge">:=</code> 연산자를 사용한 단순할당의 경우, 매크로에 값이 할당될 때 시점의 값으로 바로 평가, 확장된다. 따라서 이후 참조하고 있는 매크로의 값이 변경되더라도, 최초에 할당된 값을 유지한다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">BAR</span> <span class="o">=</span> bar_value
<span class="nv">FOO</span> <span class="o">:=</span> <span class="p">$(</span>BAR<span class="p">)</span>
<span class="nv">BAR</span> <span class="o">=</span> new_value

<span class="nl">all</span><span class="o">:</span>
        <span class="err">@echo</span> <span class="err">$(FOO)</span>
</code></pre></div></div>

<p>이 경우, <code class="language-plaintext highlighter-rouge">FOO</code> 는 <code class="language-plaintext highlighter-rouge">BAR</code> 의 현재값인 <code class="language-plaintext highlighter-rouge">bar_value</code> 로 초기화 되고, 이후 <code class="language-plaintext highlighter-rouge">BAR</code> 의 값이 변경되더라도 <code class="language-plaintext highlighter-rouge">FOO</code> 의 값은 변하지 않는다. 따라서 해당 Makefile 을 실행하면 출력값은 <code class="language-plaintext highlighter-rouge">bar_value</code> 가 된다.</p>

<h4 id="-append"><code class="language-plaintext highlighter-rouge">+=</code> (Append)</h4>

<p>기존 변수의 값에 값을 추가함. 만약 매크로가 정의되어 있지 않았었다면 해당 매크로를 생성한다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CFLAGS</span> <span class="o">:=</span> <span class="nt">-Wall</span>
<span class="nv">CFLAGS</span> <span class="o">+=</span> <span class="nt">-g</span>   <span class="c"># CFLAGS는 이제 "-Wall -g"</span>
</code></pre></div></div>

<h4 id="-conditional-assignment"><code class="language-plaintext highlighter-rouge">?=</code> (Conditional Assignment)</h4>

<p>매크로가 아직 값이 할당되어 있지 않을 경우에만 값을 할당. 이미 값이 있으면 할당하지 않음.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CC</span> <span class="o">?=</span> gcc <span class="c"># CC가 이전에 정의되지 않았다면 gcc를 사용</span>
</code></pre></div></div>

<h4 id="-target-name"><code class="language-plaintext highlighter-rouge">$@</code> (Target Name)</h4>

<p><code class="language-plaintext highlighter-rouge">$@</code> : 현재 target 의 이름을 명시</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">all</span><span class="o">:</span> <span class="nf">program</span>
<span class="nl">program</span><span class="o">:</span> <span class="nf">program.o</span>
        <span class="err">gcc</span> <span class="err">-o</span> <span class="err">$@</span> <span class="err">$^</span>
</code></pre></div></div>
<p>이 경우 <code class="language-plaintext highlighter-rouge">program: program.o</code> 에서  <code class="language-plaintext highlighter-rouge">program</code> 이 현재 target 이다.  따라서 <code class="language-plaintext highlighter-rouge">$@</code> 는 <code class="language-plaintext highlighter-rouge">program</code> 으로 대체 된다.</p>

<h4 id="-first-dependency"><code class="language-plaintext highlighter-rouge">$&lt;</code> (First Dependency)</h4>

<p><code class="language-plaintext highlighter-rouge">$&lt;</code> 는 규치의 첫 번째 의존성을 나타냄.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">program.o</span><span class="o">:</span> <span class="nf">program.c</span>
        <span class="err">gcc</span> <span class="err">-c</span> <span class="err">$&lt;</span> <span class="err">-o</span> <span class="err">$@</span>
</code></pre></div></div>
<p>여기서  <code class="language-plaintext highlighter-rouge">$&lt;</code> 는 <code class="language-plaintext highlighter-rouge">program.c</code> 을 의미하므로 <code class="language-plaintext highlighter-rouge">gcc -c $&lt; -o $@</code> 는 <code class="language-plaintext highlighter-rouge">gcc -c program.c -o program.o</code> 를 의미한다.</p>

<h4 id="-all-dependencies"><code class="language-plaintext highlighter-rouge">$^</code> (All Dependencies)</h4>

<p>현재 규칙의 모든 의존성 목록을 나타낸다. 중복된 의존성은 제거된다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">program</span><span class="o">:</span> <span class="nf">main.o lib.o util.o</span>
        <span class="err">gcc</span> <span class="err">-o</span> <span class="err">$@</span> <span class="err">$^</span>
</code></pre></div></div>
<p>여기서 <code class="language-plaintext highlighter-rouge">$^</code> 는 <code class="language-plaintext highlighter-rouge">main.o lib.o util.o</code> 을 의미하므로 <code class="language-plaintext highlighter-rouge">gcc -o $@ $^</code> 는 <code class="language-plaintext highlighter-rouge">gcc -o program main.o lib.o util.o</code> 를 의미한다.</p>

<h4 id="확장자-룰-sffix-rule-과-패턴-규칙pattern-rule">확장자 룰 (sffix rule) 과 패턴 규칙(pattern rule)</h4>

<p>Makefile 의 확장자 룰은 오래된 규칙으로, 파일 변환 규칙을 정의하는데 사용됨. 주로 한 종류의 파일을 다른 종류로 변환하는데 사용되며, 확장자만으로 이 변환 과정을 식별한다. <code class="language-plaintext highlighter-rouge">.SUFFIXES</code> 리스트에 정의된 확장자들을 사용하여, 소스파일에서 목적파일로 변환에 사용될 수 있다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">.SUFFIXES</span><span class="o">:</span> <span class="nf">.c .o</span>

<span class="nl">.c.o</span><span class="o">:</span>
        <span class="err">gcc</span> <span class="err">-c</span> <span class="err">$&lt;</span> <span class="err">-o</span> <span class="err">$@</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">.c.o:</code> 은 <code class="language-plaintext highlighter-rouge">.c</code> 파일을 <code class="language-plaintext highlighter-rouge">.o</code> 파일로 변환하는 규칙을 정의한 target 이다. 따라서 <code class="language-plaintext highlighter-rouge">gcc -c $&lt; -o $@</code> 은 첫번째 의존성 <code class="language-plaintext highlighter-rouge">.c</code> 파일을 동일 파일 이름의 <code class="language-plaintext highlighter-rouge">.o</code> 파일로 compile 하라는 의미 이다. <br /></p>

<p>그러나 현대의 Makefile 작성에서는 패턴 규칙을 사용하는 것이 더 권장된다. 확장자 규칙은 유연성과 명확성이 떨어질 수 있으며, GNU Make와 같은 최신 도구에서는 보다 강력하고 유연한 패턴 규칙을 사용할 수 있다. 패턴 규칙은 특정 파일 세트에 대해 적용할 수 있는 규칙을 정의할 때 % 와일드카드를 사용하여 보다 일반적인 규칙을 작성할 수 있게 해준다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">%.o</span><span class="o">:</span> <span class="nf">%.c</span>
        <span class="err">gcc</span> <span class="err">-c</span> <span class="err">$&lt;</span> <span class="err">-o</span> <span class="err">$@</span>
</code></pre></div></div>

<p>이는 앞의 확장자 룰과 동일한 명령을 수행하며, 좀더 명확하고 간결하게 표현된다.</p>

<p>그러나 결론적으로 동일한 파일명의 소스파일에서 목적 파일을 생성하는 룰은 Makefile 에 기본으로 내장되어 있기 때문에 사용자가 정의하는 Makefile 에서는 해당 내용을 생략해도 실행된다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">executable</span><span class="o">:</span> <span class="nf">distance.o main.o</span>
        <span class="err">ld</span> <span class="err">-o</span> <span class="err">executable</span> <span class="err">*.o</span> <span class="err">/usr/lib/x86_64-linux-gnu/crt1.o</span> <span class="err">-lm</span> <span class="err">-lc</span> <span class="nv">-dynamic-linker</span><span class="o">=</span>/lib64/ld-linux-x86-64.so.2

<span class="nl">distance.o </span><span class="o">:</span> <span class="nf">distance.c</span>
        <span class="err">gcc</span> <span class="err">-c</span> <span class="err">-o</span> <span class="err">distance.o</span> <span class="err">distance.c</span>

<span class="nl">main.o </span><span class="o">:</span> <span class="nf">main.c</span>
        <span class="err">gcc</span> <span class="err">-c</span> <span class="err">-o</span> <span class="err">main.o</span> <span class="err">main.c</span>
</code></pre></div></div>
<p>위 내용은 아래와 같이 명시적으로 작성하지 않아도,</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">executable</span><span class="o">:</span> <span class="nf">distance.o main.o</span>
        <span class="err">ld</span> <span class="err">-o</span> <span class="err">executable</span> <span class="err">*.o</span> <span class="err">/usr/lib/x86_64-linux-gnu/crt1.o</span> <span class="err">-lm</span> <span class="err">-lc</span> <span class="nv">-dynamic-linker</span><span class="o">=</span>/lib64/ld-linux-x86-64.so.2
</code></pre></div></div>
<p>최종 실행 파일 생성만 구현하고 <code class="language-plaintext highlighter-rouge">make</code>를 실행해도 이전과 동일하게 각 소스코드에서 목적파일이 생성되고 최종적으로 실행파일이 생성된다. 또한 점진적 빌드 (Incremental build) 도 정상적으로 동작한다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nl">buildroot_download</span><span class="o">:</span> 
        

</code></pre></div></div>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="bash" /><category term="makefile" /><category term="incremental build" /><category term="suffix rule" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 05]]></summary></entry><entry><title type="html">Shell Script 사용한 시스템 구축 01 (사용자 계정 생성)</title><link href="http://localhost:4000/shell-script04-systemsetting01-copy.html" rel="alternate" type="text/html" title="Shell Script 사용한 시스템 구축 01 (사용자 계정 생성)" /><published>2024-02-20T14:32:20+09:00</published><updated>2024-02-20T14:32:20+09:00</updated><id>http://localhost:4000/shell-script04-systemsetting01%20copy</id><content type="html" xml:base="http://localhost:4000/shell-script04-systemsetting01-copy.html"><![CDATA[<p>참고 자료 : <a href="https://product.kyobobook.co.kr/detail/S000001810353">처음 배우는 셸 스크립트 8장 시스템 구축</a></p>

<p>shell script 를 사용하여 사용자 개정을 생성하는 파일을 작성 및 실행</p>

<p>프로세스</p>
<ol>
  <li>사용자 계정과 패스워드 입력</li>
  <li>입력 정보가 없으면 에러 메세지를 보여주고, script 종료</li>
  <li>여러명의 사용자 계정을 생성할 경우 반복문을 사용하여 순회</li>
  <li>각 계정이 이미 사용자 계정에 포함되어 있는지 확인</li>
  <li>포함되어있지 않다면, 계정을 생성하고 패스워드 설정</li>
  <li>이미 존재하는 계정이라면, 이를 메세지로 보여줌.</li>
</ol>

<h3 id="1-다수의-사용자-계정-생성">1. 다수의 사용자 계정 생성</h3>

<p>(1) <code class="language-plaintext highlighter-rouge">if [[ -n $1 ]] &amp;&amp; [[ -n $2 ]]</code>
<br />해당 script 실행시 매개 변수로 사용자 계정(<code class="language-plaintext highlighter-rouge">$1</code>)과 패스워드(<code class="language-plaintext highlighter-rouge">$2</code>)가 모두 입력 되었는지 확인(<code class="language-plaintext highlighter-rouge">-n</code> : 비워있지 않아야 함) 한다. <code class="language-plaintext highlighter-rouge">$1</code> 과 <code class="language-plaintext highlighter-rouge">$2</code> 모두 외부 입력값이므로 이중 중괄호 <code class="language-plaintext highlighter-rouge">[[]]</code> 를 사용한다.
<br /></p>

<p>(2) <code class="language-plaintext highlighter-rouge">IFS=' ' read -r -a UserList &lt;&lt;&lt; "$1"</code> <br />
입력된 매개변수 값을 공백을 기준으로 값을 slice 하여 배열의 형태로 shell script 변수로 저장함.<br /></p>
<ul>
  <li>IFS (Internal Field Separator) : IFS 는 shell scirpt 에서 사용하는 내부 필드 구분자. 이 변수는 문자열을 분리하여 배열이나 개별 변수로 읽을 때 사용하는 구분자을 정의한다. 기본값은 공백, 탭, 개행 문자.</li>
  <li><code class="language-plaintext highlighter-rouge">read</code> : 표준 입력이나 파일로부터 입력을 읽어드림. 이 명령어를 사용하여 변수에 값을 할당할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">-r</code> : <code class="language-plaintext highlighter-rouge">read</code> 옵션 중 백슬래시(<code class="language-plaintext highlighter-rouge">\</code>) 가 이스케이프 문자로 처리되지 않고, 그대로 읽어드림.</li>
  <li><code class="language-plaintext highlighter-rouge">-a</code> : <code class="language-plaintext highlighter-rouge">read</code> 명령어에 의히 읽힌 값을 배열로 저장.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;&lt;&lt;</code> (Here String) :  “$1” 로 받은 외부 입력 값을 UserList 변수 값으로 취할 수 있도록 redirection 해줌. 
<br /></li>
</ul>

<p>(3) <code class="language-plaintext highlighter-rouge">for (( i=0 ; i &lt; ${#UserList[@]}; i++ ))</code> <br />
배열 <code class="language-plaintext highlighter-rouge">UserList</code> 의 길이만큼 반복할 수 있도록 설정
<br /></p>

<p>(4) <code class="language-plaintext highlighter-rouge">if [[ $(cat /etc/passwd | grep -w ${UserList[$i]} | wc -l) == 0 ]] </code><br /></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">$(cat /etc/passwd</code> 파일의 내용을 가져와서,</li>
  <li><code class="language-plaintext highlighter-rouge">UserList[$i]</code> 의 값과 정확히 (<code class="language-plaintext highlighter-rouge">-w</code>)일치하는 사용자 계정을 찾고,</li>
  <li><code class="language-plaintext highlighter-rouge">wc</code> (word count) 의 라인 수(<code class="language-plaintext highlighter-rouge">-l</code>) 을 출력,</li>
  <li>해당 값이 0 아니라면, 동일 계정이 존재한다는 것을 의미함.
<br /></li>
</ul>

<p>(5) <code class="language-plaintext highlighter-rouge">useradd ${UserList[$i]}</code> <br />
기존 계정이 존재하지 않는 경우, 해당 값 <code class="language-plaintext highlighter-rouge">${UserList{$i}}</code> 의 계정을 생성함. 
<br /></p>

<p>(6) <code class="language-plaintext highlighter-rouge">echo "${UserList[$i]}:${Password[$i]}" | chpasswd</code> <br />
새로 생성한 계정에 대한 패스워드 값을 사용하여 패스워드를 설정
<br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c"># 사용자 계정 및 패스워드가 입력되었는지 확인</span>
<span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="nv">$1</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="nv">$2</span> <span class="o">]]</span> <span class="c">#  (1)</span>
<span class="k">then

        </span><span class="nv">IFS</span><span class="o">=</span><span class="s1">' '</span> <span class="nb">read</span> <span class="nt">-r</span> <span class="nt">-a</span> UserList <span class="o">&lt;&lt;&lt;</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="c">#  (2)</span>
        <span class="nv">IFS</span><span class="o">=</span><span class="s1">' '</span> <span class="nb">read</span> <span class="nt">-r</span> <span class="nt">-a</span> Password <span class="o">&lt;&lt;&lt;</span> <span class="s2">"</span><span class="nv">$2</span><span class="s2">"</span>

        <span class="c"># for 문을 이용하여 사용자 계정 생성</span>
        <span class="k">for</span> <span class="o">((</span> <span class="nv">i</span><span class="o">=</span>0 <span class="p">;</span> i &lt; <span class="k">${#</span><span class="nv">UserList</span><span class="p">[@]</span><span class="k">}</span><span class="p">;</span> i++ <span class="o">))</span> <span class="c">#  (3)</span>
        <span class="k">do</span>
                <span class="c"># if문을 사용하여 사용자 계정이 있는지 확인</span>
                <span class="k">if</span> <span class="o">[[</span> <span class="si">$(</span><span class="nb">cat</span> /etc/passwd | <span class="nb">grep</span> <span class="nt">-w</span> <span class="k">${</span><span class="nv">UserList</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span> | <span class="nb">wc</span> <span class="nt">-l</span><span class="si">)</span> <span class="o">==</span> 0 <span class="o">]]</span> <span class="c">#  (4)</span>
                <span class="k">then</span>
                        <span class="c"># 사용자 생성 및 패스워드 설정</span>
                        useradd <span class="k">${</span><span class="nv">UserList</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span> <span class="c">#  (5)</span>
                        <span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">UserList</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span><span class="s2">:</span><span class="k">${</span><span class="nv">Password</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span><span class="s2">"</span> | chpasswd <span class="c">#  (6)</span>
                <span class="k">else</span>
                        <span class="c"># 사용자가 있다고 메세지를 보여줌</span>
                        <span class="nb">echo</span> <span class="s2">"this user </span><span class="k">${</span><span class="nv">UserList</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span><span class="s2"> is existing."</span>
                <span class="k">fi
        done

else</span>
        <span class="c"># 사용자가 계정과 패스워드를 입력하라는 메세지를 보여줌</span>
        <span class="nb">echo</span> <span class="nt">-e</span> <span class="s1">'Please input user id and password. \nUsage: adduser-script.sh "user01 user02" "pw01 pw02"'</span>
<span class="k">fi</span>
</code></pre></div></div>
<p>해당 script 를  <code class="language-plaintext highlighter-rouge">adduser-script.sh</code> 에 저장하고 아래와 같이 실행</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gon@DESKTOP:~/book/ch08<span class="nv">$ </span><span class="nb">sudo </span>bash adduser-script.sh <span class="s2">"user1 user2"</span> <span class="s2">"1111 2222"</span>
</code></pre></div></div>
<p>여기에서 <code class="language-plaintext highlighter-rouge">sh</code> 가 아닌 <code class="language-plaintext highlighter-rouge">bash</code> 명령어를 사용한 이유는, 일부 리눅스 (ex. Ubuntu) shell 이 <code class="language-plaintext highlighter-rouge">bash</code> 가 아닌 <code class="language-plaintext highlighter-rouge">dash</code> 에서 실행되는 경우가 있다. 이런 경우, <code class="language-plaintext highlighter-rouge">dash</code> 에서 지원되지 않는 기능 (ex. redirection <code class="language-plaintext highlighter-rouge">&lt;&lt;&lt;</code>)을 shell script 내 사용한 경우, 다음과 같은 에러가 발생한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gon@DESKTOP:~/book/ch08<span class="nv">$ </span><span class="nb">sudo </span>sh adduser-script.sh <span class="s2">"user1 user2"</span> <span class="s2">"1111 2222"</span>
adduser-script.sh: 7: Syntax error: redirection unexpected
</code></pre></div></div>

<p>이를 해결하는 다른 방법으로, 해당 파일의 실행 권한을 아예 변경하고, 직접 실행 시키면 된다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gon@DESKTOP:~/book/ch08<span class="nv">$ </span><span class="nb">chmod</span> +x adduser-script.sh
gon@DESKTOP:~/book/ch08<span class="nv">$ </span>./adduser-script.sh <span class="s2">"user1 user2"</span> <span class="s2">"1111 2222"</span>
</code></pre></div></div>

<p>최종적으로, 해당 실행이 정상적으로 동작했는지를 위해 <code class="language-plaintext highlighter-rouge">/etc/passwd</code> 파일 내용을 확인하면 아래 해당 user 가 추가된 것을 확인할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gon@DESKTOP:~/book/ch08<span class="nv">$ </span><span class="nb">cat</span> /etc/passwd

...
user1:x:1001:1001::/home/user1:/bin/sh
user2:x:1002:1002::/home/user2:/bin/sh
</code></pre></div></div>

<h3 id="2-ssh--를-활용하여-다른-서버에-사용자-계정-생성">2. ssh  를 활용하여 다른 서버에 사용자 계정 생성</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="k">for </span>server <span class="k">in</span> <span class="s2">"host01 host02 host03"</span>
<span class="k">do</span>
        <span class="c"># 여러 대의 시스템에 사용자 생성 및 패스워드 설정</span>
        <span class="nb">echo</span> <span class="nv">$server</span>
        ssh root@<span class="nv">$server</span> <span class="s2">"useradd </span><span class="nv">$1</span><span class="s2">"</span>  <span class="c"># (1)</span>
        ssh root@<span class="nv">$server</span> <span class="s2">"echo </span><span class="nv">$2</span><span class="s2">:</span><span class="nv">$1</span><span class="s2"> | chpasswd"</span> 
<span class="k">done</span>
</code></pre></div></div>

<p>(1) <code class="language-plaintext highlighter-rouge">ssh root@$server "useradd $1"</code></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ssh</code> : SSH protocol 을 사용하여 원격 서버에 접속하가나 원격 서버에서 명령을 실행하기 위한 client 프로그램</li>
  <li><code class="language-plaintext highlighter-rouge">root@$server</code> : <code class="language-plaintext highlighter-rouge">사용자명@호스트명</code> 형식으로 접속할 원격 서버의 최고 관리자 계정을 의미</li>
  <li><code class="language-plaintext highlighter-rouge">"useradd $1"</code> : ssh root 계정으로 해당 host 에 접속하여 사용자 계정 추가를 실행</li>
</ul>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="bash" /><category term="shell scirpt" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 04]]></summary></entry><entry><title type="html">Shell Script 기본 문법 03 (큰따옴표 작은 따음표)</title><link href="http://localhost:4000/shell-script03-quates.html" rel="alternate" type="text/html" title="Shell Script 기본 문법 03 (큰따옴표 작은 따음표)" /><published>2024-02-10T12:32:20+09:00</published><updated>2024-02-10T12:32:20+09:00</updated><id>http://localhost:4000/shell-script03-quates</id><content type="html" xml:base="http://localhost:4000/shell-script03-quates.html"><![CDATA[<p>Bash 스크립트에서 큰따옴표(““)와 작은따옴표(‘‘)는 문자열을 묶는 데 사용되지만, 그들이 처리하는 방식에는 중요한 차이가 있다.</p>

<h3 id="큰따옴표">큰따옴표(“”)</h3>

<ol>
  <li>
    <p>변수 확장(Expansion)<br />
  큰따옴표 안에 있는 변수는 그 값으로 확장됨. 예를 들어, “$VARIABLE”은 VARIABLE의 값을 나타냄.</p>
  </li>
  <li>
    <p>명령어 치환(Command Substitution)<br />
  큰따옴표 안에서 명령어 치환. 예를 들어, “$(date)”는 현재 날짜와 시간으로 치환됨.</p>
  </li>
  <li>
    <p>공백과 특수 문자<br /> 
  큰따옴표 안의 공백, 탭 등은 문자열의 일부로 유지됨. 이는 여러 단어나 공백을 포함하는 문자열을 하나의 인자나 값으로 처리해야 할 때 유용.</p>
  </li>
</ol>

<h3 id="작은따옴표">작은따옴표(‘’)</h3>

<ol>
  <li>
    <p>문자 그대로의 값<br /> 
  작은따옴표 안의 모든 문자는 그대로의 값으로 처리됨. 변수 확장이나 명령어 치환 같은 것은 일어나지 않는다. 예를 들어, ‘$VARIABLE’은 표기된 문자열 “$VARIABLE” 그 자체를 의미.</p>
  </li>
  <li>
    <p>공백과 특수 문자<br /> 
  작은따옴표 안의 공백과 특수 문자도 문자열의 일부로 유지되며, 이 역시 여러 단어나 공백을 포함하는 문자열을 하나의 인자나 값으로 처리하고자 할 때 유용.</p>
  </li>
</ol>

<h3 id="사용-예시">사용 예시</h3>

<ol>
  <li>
    <p>변수 확장이 필요한 경우<br /> 
  “Hello, $USER” (USER 변수에 해당하는 사용자 이름으로 확장.)</p>
  </li>
  <li>
    <p>명령어 치환을 사용하는 경우<br /> 
  “Today is $(date)” (현재 날짜로 치환.)</p>
  </li>
  <li>
    <p>문자 그대로의 값이 필요한 경우<br /> 
  ‘Data $5 not processed’ (문자열이 그대로 출력, 변수 확장이나 치환 없이.)</p>
  </li>
</ol>

<h3 id="결론">결론</h3>

<p>각각의 사용법은 스크립트에서 변수의 값이나 명령어의 결과를 어떻게 처리할지에 따라 달라진다. 문자열 내에서 변수의 값을 그대로 사용하고 싶지 않거나, 특수 문자를 명령어의 일부로 해석되지 않게 하고 싶을 때 작은따옴표를 사용한다. 반면, 변수의 값을 확장하거나 명령어의 결과를 사용하고자 할 때는 큰따옴표를 사용한다.</p>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="bash" /><category term="shell scirpt" /><category term="quates" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 03]]></summary></entry><entry><title type="html">Shell Script 기본 문법 01</title><link href="http://localhost:4000/shell-script01.html" rel="alternate" type="text/html" title="Shell Script 기본 문법 01" /><published>2024-02-10T08:32:20+09:00</published><updated>2024-02-10T08:32:20+09:00</updated><id>http://localhost:4000/shell-script01</id><content type="html" xml:base="http://localhost:4000/shell-script01.html"><![CDATA[<h3 id="1-간단한-함수를-사용한-script-1">1. 간단한 함수를 사용한 script 1</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c"># 함수 정의: 두 인자를 받아 출력함</span>
add_inner_numbers<span class="o">()</span> <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">"첫 번째 숫자: </span><span class="nv">$1</span><span class="s2">"</span>
    <span class="nb">echo</span> <span class="s2">"두 번째 숫자: </span><span class="nv">$2</span><span class="s2">"</span>
    
    <span class="nb">local sum</span><span class="o">=</span>0
    <span class="nb">sum</span><span class="o">=</span><span class="k">$((</span> <span class="nv">$1</span> <span class="o">+</span> <span class="nv">$2</span> <span class="k">))</span>
    <span class="nb">echo</span> <span class="s2">"두 수의 합: </span><span class="nv">$sum</span><span class="s2">"</span>
<span class="o">}</span>

<span class="c"># 함수 호출: 5와 10을 인자로 전달</span>
add_inner_numbers 5 10
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">#!/bin/bash</code>
    <ul>
      <li>“shebang” (또는 “hashbang”)</li>
      <li>해당 script를 실행할 때 사용할 interpreter 의 경로를 진행</li>
      <li>여기서는 Bash shell 을 사용하여 실행되어야 함을 의미</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">subtract_num() {}</code></li>
  <li>
    <p>script 함수를 정의할 때, 매개변수는 명시하지 않는다. 함수 내 $1, $2, $3 … 과 같이 함수 내부에 명시된 value 의 숫자값에 순서대로 매칭되어 입력된다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">sum=$(( $1 + $2 ))</code>
    <ul>
      <li>첫번째 괄호는 $() 로 연산 결과를 값으로 취함을 의미</li>
      <li>두번째 괄호는 연산에 대한 괄호</li>
      <li>띄어쓰기는 여기서는 결과에 영향을 미치지는 않지만 일반적인 작성 기준을 따름.</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>실행 결과</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@DESKTOP:~<span class="nv">$ </span>./example.sh
첫 번째 숫자: 5
두 번째 숫자: 10
두 수의 합: 15
</code></pre></div></div>

<h3 id="2-간단한-함수를-사용한-script-2-외부-입력">2. 간단한 함수를 사용한 script 2 (외부 입력)</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c">#  두수를 빼는  함수 정의</span>
subtract_num<span class="o">()</span> <span class="o">{</span>
        <span class="nb">local </span><span class="nv">sub</span><span class="o">=</span>0
        <span class="nv">sub</span><span class="o">=</span><span class="k">$((</span> <span class="nv">$2</span> <span class="o">-</span> <span class="nv">$1</span> <span class="k">))</span>
        <span class="nb">echo</span> <span class="s2">"두 수의 차: </span><span class="nv">$sub</span><span class="s2">"</span>
<span class="o">}</span>

<span class="c"># 사용자로부터 두수 입력 받기</span>
<span class="nb">read</span> <span class="nt">-p</span> <span class="s2">"첫번째 수를 입력하세요: "</span> num1
<span class="nb">read</span> <span class="nt">-p</span> <span class="s2">"두번째 수를 입력하세요: "</span> num2

<span class="c"># 함수 호출</span>
subtract_num <span class="nv">$num1</span> <span class="nv">$num2</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">read -p "첫번째 수를 입력하세요: " num1</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">read</code> 명령어로 표준입력 값을 받을 수 있다.</li>
      <li><code class="language-plaintext highlighter-rouge">-p</code> 옵션으로 <code class="language-plaintext highlighter-rouge">echo</code> 명령어를 사용하지 않고 프롬프트 메세지를 보여줄 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>실행 결과</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@DESKTOP:~<span class="nv">$ </span>./example.sh
첫번째 수를 입력하세요: 2
두번째 수를 입력하세요: <span class="nt">-5</span>
두 수의 차: <span class="nt">-7</span>
</code></pre></div></div>

<h3 id="3-간단한-함수를-사용한-script-3-외부-입력-조건문">3. 간단한 함수를 사용한 script 3 (외부 입력, 조건문)</h3>

<p>외부 입력을 함수의 실행과 함께 받도록 아래와 같이 구현할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c">#  두수를 빼는  함수 정의</span>
subtract_num<span class="o">()</span> <span class="o">{</span>
        <span class="nb">local </span><span class="nv">sub</span><span class="o">=</span>0
        <span class="nv">sub</span><span class="o">=</span><span class="k">$((</span> <span class="nv">$2</span> <span class="o">-</span> <span class="nv">$1</span> <span class="k">))</span>
        <span class="nb">echo</span> <span class="s2">"두 수의 차: </span><span class="nv">$sub</span><span class="s2">"</span>
<span class="o">}</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$# </span><span class="nt">-ne</span> 2 <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"사용방법: </span><span class="nv">$0</span><span class="s2"> 숫자1 숫자2"</span>
        <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># 함수 호출</span>
subtract_num <span class="nv">$1</span> <span class="nv">$2</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">if [ $# -ne 2 ]; then ... fi</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">[];</code> 내 조건이 참일 경우, <code class="language-plaintext highlighter-rouge">then ... fi</code> 내 명령어를 실행</li>
      <li><code class="language-plaintext highlighter-rouge">if</code>, <code class="language-plaintext highlighter-rouge">[];</code>, <code class="language-plaintext highlighter-rouge">then</code> 사이에는 띄어쓰기를 반드시 해야 함.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">$# -ne 2</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">$#</code> 은 script 에 전달된 positional parameter 의 갯수. 위 예제의 경우, <code class="language-plaintext highlighter-rouge">./example.sh 1 2</code> 와 같이 실행되는데, 이 때 <code class="language-plaintext highlighter-rouge">$#</code> 값은 2 이다.</li>
      <li><code class="language-plaintext highlighter-rouge">-ne</code> 은 “not equal”  의 약자로, 두 값이 서로 다른지를 비교</li>
      <li><code class="language-plaintext highlighter-rouge">2</code> 는 비교 대상의 값</li>
      <li>즉 해당 script 부분은 “입력된 positional parameter 갯수가 2개가 아니라면” 이라는 조건을 정의함.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">echo "..." exit 1</code>
    <ul>
      <li>해당 조건일 때, 메세지를 출력하고 에러 상태로 script 를 종료</li>
      <li><code class="language-plaintext highlighter-rouge">exit 0</code> 인 경우, 정상적으로 작업이 성공되고 종료됨을 의미, 0 이 아닌 경우는, 에러나 특정 조건으로 인한 종료를 의미</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>실행 결과</li>
</ul>

<p>매개변수를 입력하지 않은 경우</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@DESKTOP~<span class="nv">$ </span>./example.sh
사용방법: ./example.sh 숫자1 숫자2
</code></pre></div></div>

<p>매개변수 값을 함께 입력한 경우</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@DESKTOP:~<span class="nv">$ </span>./example.sh 3 3
두 수의 차: 0
</code></pre></div></div>

<h3 id="4-파일-입력--반복문을-이용-script">4. 파일 입력 &amp; 반복문을 이용 script</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c"># 'list' 파일을 읽어와 line 변수에 저장</span>
<span class="k">while </span><span class="nb">read</span> <span class="nt">-r</span> line<span class="p">;</span> <span class="k">do</span>
    <span class="c"># 공백으로 구분된 값을 배열로 변환</span>
    <span class="nv">IFS</span><span class="o">=</span><span class="s1">' '</span> <span class="nb">read</span> <span class="nt">-ra</span> ADDR <span class="o">&lt;&lt;&lt;</span> <span class="s2">"</span><span class="nv">$line</span><span class="s2">"</span>
    <span class="c"># 배열의 각 요소를 반복하여 출력</span>
    <span class="k">for </span>i <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">ADDR</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do
        </span><span class="nb">echo</span> <span class="nv">$i</span>
    <span class="k">done
done</span> &lt; <span class="s2">"list"</span>
</code></pre></div></div>

<p>list 파일</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 2 3 4 5
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">while read -r line: do ... done &lt; "list"</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">list</code> 파일로 부터 해당 내용을 줄별로 읽어와서 각 줄의 값을 <code class="language-plaintext highlighter-rouge">line</code> 변수의 값으로 생성한다.</li>
      <li><code class="language-plaintext highlighter-rouge">-r</code> 옵션은 <code class="language-plaintext highlighter-rouge">read</code> 명령어가 <code class="language-plaintext highlighter-rouge">\</code> 을 이스케이프 문자가 아닌 데이터 원본 그대로 무결성을 유지한채로 값을 가질 수 있도록 조건을 부여한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">IFS=' ' read -ra ADDR &lt;&lt;&lt; "$line"</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">IFS</code> 는 “Internal Field Separator” 의 약자, Bash 에서 단어 경계를 정의하는데 사용되는 환경 변수. 이 구분에서 <code class="language-plaintext highlighter-rouge">IFS</code> 는 공백문자 <code class="language-plaintext highlighter-rouge">' '</code> 로 설정되어 단어의 구분을 공백으로 사용하겠다는 의미.</li>
      <li><code class="language-plaintext highlighter-rouge">-ra</code> 에서 <code class="language-plaintext highlighter-rouge">a</code> 옵션은 입력된 data 를 배열로 변수 <code class="language-plaintext highlighter-rouge">ADDR</code> 에 저장함을 의미</li>
      <li><code class="language-plaintext highlighter-rouge">&lt;&lt;&lt;</code> 은 here string redirction 을 의미. <code class="language-plaintext highlighter-rouge">here string</code> 은 문자열 데이터를 명령어의 표준입력으로 직접 전달할 수 있게 해준다. <code class="language-plaintext highlighter-rouge">명령어 &lt;&lt;&lt; "문자열"</code> 과 같은 형태로, redirection 을 뒤에 오는 문자열 값을 바로 가져와서 사용할 수 있게 해준다. 예를 들어,
        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@DESKTOP:~<span class="nv">$ </span><span class="nb">grep</span> <span class="s2">"찾는"</span> <span class="o">&lt;&lt;&lt;</span> <span class="s2">"여기에는 찾는 단어가 있을까요?"</span>
여기에는 찾는 단어가 있을까요?
</code></pre></div>        </div>
        <p>와 같이, 외부 파일 등에서 가져오는 것이 아니라 뒤에 명시된 문자열 값을 바로 redirection 하여 가져와 사용하게 된다.</p>
      </li>
      <li>따라서 해당 구문을 정리하면,<br />
(1). line 변수 값을 문자열로 생성한다.<br />
(2). (1) 번 값을 redirection 하여 가져오고,<br /> 
(3). <code class="language-plaintext highlighter-rouge">\</code> 를 별도 처리하지 않고, <br />
(4). 띄어쓰기(‘ ‘) 로 구분하여 생성된 배열 값을<br /> 
(5). 배열 변수 <code class="language-plaintext highlighter-rouge">ADDR</code> 의 값으로 생성한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">for i in "${ADDR[@]}"; do ... done</code>
    <ul>
      <li>반복문 <code class="language-plaintext highlighter-rouge">for</code> 는 배열 변수 ADDR 의 원소를 순회하면서 원소값 을 대입하여 <code class="language-plaintext highlighter-rouge">do ... done</code> 내 script 를 수행함.</li>
      <li><code class="language-plaintext highlighter-rouge">ADDR[@]</code> 는 각 원소를 의미</li>
      <li><code class="language-plaintext highlighter-rouge">""</code> 감싸 해당 원소값을 문자열로 변환, 혹시 문자열 내 다른 문자열을 포함한 경우 (ex. “값은 ${ADDR[@]}”) 다른 문자열과  배열 변수 값 부분을 명확히 구분하기 위해 <code class="language-plaintext highlighter-rouge">${}</code> 로 감싸줌.</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>실행 결과</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@DESKTOP:~<span class="nv">$ </span>./example.sh
1
2
3
4
5
</code></pre></div></div>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="shell scirpt" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 01]]></summary></entry></feed>