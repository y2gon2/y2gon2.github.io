<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-02-23T16:26:21+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Gon’s Tech Jurnal</title><subtitle>The Record of Backend Development</subtitle><author><name>Yong gon Yun</name></author><entry><title type="html">Buildroot 설치 및 Kernel build</title><link href="http://localhost:4000/buildroot-setting01.html" rel="alternate" type="text/html" title="Buildroot 설치 및 Kernel build" /><published>2024-02-22T10:32:20+09:00</published><updated>2024-02-22T10:32:20+09:00</updated><id>http://localhost:4000/buildroot-setting01</id><content type="html" xml:base="http://localhost:4000/buildroot-setting01.html"><![CDATA[<p>개발자를 위한 시스템 반도체 SW개발 기초(디바이스 드라이버 개발) - Rootfs 빌드 강의 내용 (https://comento.kr/)</p>

<h3 id="1-buildroot--다운로드-및-설치">1. buildroot  다운로드 및 설치</h3>

<h3 id="11-buildroot--다운로드">1.1 buildroot  다운로드</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span>git clone git://git.buildroot.net/buildroot
</code></pre></div></div>

<h4 id="12-qemu-설정">1.2 qemu 설정</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span><span class="nb">cd </span>buildroot
root@:~/buildroot<span class="nv">$ </span><span class="nb">ls </span>configs  <span class="c"># config 종류 확인</span>
root@:~/buildroot<span class="nv">$ </span>make qemu_aarch64_virt_defconfig
root@:~/buildroot<span class="nv">$ </span>make menuconfig
</code></pre></div></div>

<center><img src="assets\img\posts\2024-02-22-buildroot-setting01.png" width="600" /></center>

<p>다음과 같이 설정을 진행</p>

<ul>
  <li>system configuration -&gt; init system -&gt; systemd 선택</li>
  <li>kernel -&gt; linux kernel  해제</li>
  <li>target packages -&gt; text editors -&gt; vim -&gt; target packages -&gt; libaries -&gt; Crypto -&gt; openssl support 선택 -&gt; openssl binary 도 선택</li>
  <li>Filesystem images -&gt; ext2/3/4 -&gt; ext4 -&gt; exact size -&gt; 128M</li>
  <li>host utilities -&gt; 모두 선택 해제 (해제 불가 항목은 그대로 둠) -&gt; 최종 exit -&gt; 저장</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/buildroot<span class="nv">$ </span><span class="nb">cat</span> /proc/cpuinfo | <span class="nb">grep </span>processor | <span class="nb">wc</span> <span class="nt">-l</span> <span class="c"># cpu 갯수 확인</span>
root@:~/buildroot<span class="nv">$ </span>make <span class="nt">-j</span>&lt;cpu 수&gt;
</code></pre></div></div>

<h4 id="13-에러-처리">1.3 에러 처리</h4>

<p>다만 해당 실행 시 에러가 발생하였는데 관련 내용은 다음과 같다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/buildroot<span class="nv">$ </span>make <span class="nt">-j</span>&lt;cpu 수&gt;
Your PATH contains spaces, TABs, and/or newline <span class="o">(</span><span class="se">\n</span><span class="o">)</span> characters.
This doesn<span class="s1">'t work. Fix you PATH.
make: *** [support/dependencies/dependencies.mk:27: dependencies] Error 1
</span></code></pre></div></div>

<p>이 에러 메시지는 Linux 시스템의 PATH 환경 변수에 공백, 탭(TABs), 또는 줄바꿈 문자(newline, \n)가 포함되어 있어서 발생한 것이다. make와 같은 빌드 시스템에서는 PATH 환경 변수를 사용하여 필요한 실행 파일들을 찾는다. 만약 PATH에 이러한 특수 문자가 포함되어 있다면, 빌드 프로세스가 제대로 실행 파일들을 찾지 못하게 되어 오류가 발생하게 된다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/buildroot<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$PATH</span>
</code></pre></div></div>

<p>이 명령어를 실행하면 PATH에 설정된 디렉토리들이 콜론(:)으로 구분되어 출력된다. 여기서 공백, 탭, 또는 줄바꿈 문자가 있는지 확인해보니 몇 군데 공백이 확인 되었다. 따라서, PATH에서 문제가 되는 문자를 아래와 같이 제거함.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/buildroot<span class="nv">$ </span><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="nv">$PATH</span> | <span class="nb">tr</span> <span class="nt">-d</span> <span class="s1">' \t\n'</span><span class="si">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">echo $PATH</code> 로 제거가 되었는지 확인한 이후, 다시 make 실행에 unzip 이 설치되어 있지 않다고 에러가 발생하여 이를 설치하였다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/buildroot<span class="nv">$ </span><span class="nb">sudo </span>apt-get update
root@:~/buildroot<span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>unzip
</code></pre></div></div>

<h4 id="14-buildroot-설치">1.4 buildroot 설치</h4>

<p>그리고 최종적으로 make 를 실행하여 설치함 (20 여분 소요)</p>

<p>해당 작업을 통해 Buildroot 는 위 설정에 따라 다음의 주요 작업을 진행, embedded system S/W stackt 을 빌드 한다.</p>

<ol>
  <li>
    <p>구성 검증: Buildroot는 .config 파일이나 다른 구성 파일에 정의된 설정을 검증한다. 이 설정은 make menuconfig, make xconfig 또는 make nconfig와 같은 명령어를 통해 사전에 사용자에 의해 정의 것들 이다..</p>
  </li>
  <li>
    <p>툴체인(Toolchain) 빌드 또는 다운로드: 툴체인은 컴파일러, 링커, 라이브러리 등 임베디드 소프트웨어를 컴파일하기 위해 필요한 도구들의 집합이다. Buildroot는 선택된 설정에 따라 적절한 툴체인을 빌드하거나 사전에 빌드된 툴체인을 다운로드한다. 다만 현재의 설정에서 toolchain 빌드는 따로 진행된다.</p>
  </li>
  <li>
    <p>리눅스 커널 빌드: 사용자가 지정한 버전의 리눅스 커널을 다운로드하고, 필요한 패치를 적용한 후 커널을 크로스 컴파일한다. 역시 현재의 설정에서 커널 빌드는 따로 진행된다.</p>
  </li>
  <li>
    <p>루트 파일 시스템(Root Filesystem) 구성: Buildroot는 사용자가 선택한 모든 소프트웨어 패키지를 다운로드하고, 이들을 크로스 컴파일하여 루트 파일 시스템을 구성. 이 과정에는 라이브러리, 시스템 유틸리티, 애플리케이션 등이 포함된다.</p>
  </li>
  <li>
    <p>부트로더(Bootloader) 빌드: 필요한 경우, 선택된 부트로더(예: U-Boot)를 빌드.</p>
  </li>
  <li>
    <p>이미지 생성: 모든 빌드 과정이 완료되면, Buildroot는 이들을 통합하여 임베디드 시스템을 위한 최종 이미지(예: SD 카드 이미지, NAND 플래시 이미지)를 생성한다. 이 이미지는 실제 하드웨어에서 직접 부팅할 수 있다. 3 번과 마찬가지로 현재 설정에서 해당 과정은 별도로 커널 빌드 때 진행된다.</p>
  </li>
</ol>

<h3 id="2-kernel-build-다운로드-및-이미지-생성">2. Kernel Build 다운로드 및 이미지 생성</h3>

<h4 id="21-kernel-download-httpskernelorg">2.1 kernel download (https://kernel.org/)</h4>

<center><img src="assets\img\posts\2024-02-22-buildroot-setting012.png" width="600" /></center>

<p>해당 사이트 git 주소 -&gt; “stable/linux” 검색 해서 나온 kernel/git/stable/linux.git 경로를 git clone 하여 다운 받음.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/buildroot<span class="nv">$ </span><span class="nb">cd</span> ..
root@:~<span class="nv">$ </span>git clone https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/
</code></pre></div></div>
<p>-&gt;  linux 디렉토리에 해다 repository 파일 다운로드 완료</p>

<h4 id="22-kernel-build-에-필요한-라이브러리-설치">2.2 kernel build 에 필요한 라이브러리 설치</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span><span class="nb">sudo </span>apt-get <span class="nb">install </span>bison flex libelf-dev libssl-dev
</code></pre></div></div>

<p>(각 라이브러리 들의 기능에 대한 이해는 부족한 상태임. 추가학습 필요)</p>

<ol>
  <li>Bison</li>
</ol>

<ul>
  <li>용도: bison은 GNU 프로젝트의 구문 분석기 생성기로, 커널 소스 코드 내의 구문을 분석하는 데 사용된다. 커널 빌드 과정에서는 특히 커널의 구성 설정 도구인 kconfig에 의해 사용됨.</li>
</ul>

<ol>
  <li>Flex</li>
</ol>

<ul>
  <li>용도: flex는 텍스트 스캔을 위한 패턴 매칭을 수행하는 렉서(lexer) 또는 스캐너(scanner) 생성기. lex의 GNU 버전으로, 텍스트 입력 스트림에서 패턴을 인식하고 처리하는 프로그램을 생성한다. bison과 함께 kconfig에 의해 사용되며, 커널의 설정 옵션을 해석하고 처리하는 데 필요.</li>
</ul>

<ol>
  <li>libelf-dev</li>
</ol>

<ul>
  <li>용도: libelf-dev는 ELF(Executable and Linkable Format) <a href="https://doitnow-man.tistory.com/entry/ELF-1-ELF-%EB%9E%80">(참고 자료 : ELF 란?)</a> 파일을 다루기 위한 개발 라이브러리. ELF 파일 포맷은 리눅스 시스템에서 실행 파일, 오브젝트 코드, 공유 라이브러리, 코어 덤프 등을 위해 사용. 커널 모듈과 같은 ELF 형식의 바이너리 파일을 생성하고 조작하는 데 사용되므로 커널 모듈을 빌드하고 분석하는 데 필수적.</li>
</ul>

<ol>
  <li>libssl-dev</li>
</ol>

<ul>
  <li>용도: libssl-dev는 OpenSSL 라이브러리의 개발 버전 패키지. OpenSSL은 네트워크 연결에 대한 암호화 통신을 제공하는 라이브러리로, SSL(Secure Sockets Layer)과 TLS(Transport Layer Security) 프로토콜을 구현한다. 커널에서는 예를 들어, 보안 통신이 필요한 네트워크 기능을 개발할 때 이 라이브러리가 사용될 수 있다.</li>
</ul>

<h4 id="23-buildroot-에-있는-config-복사-및-config-파일-생성">2.3 buildroot 에 있는 config 복사 및 .config 파일 생성</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/linux<span class="nv">$ </span><span class="nb">cp</span> ../buildroot/board/qemu/aarch64-virt/linux.config <span class="nb">arch</span>/arm64/configs/qemu_defconfig
root@:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 make qemu_defconfig <span class="c"># 반환값으로 .config 생성</span>
</code></pre></div></div>

<h4 id="24-kernel-build-를-위한-toolchain-download-httpsdeveloperarmcom">2.4 kernel build 를 위한 toolchain download (https://developer.arm.com/)</h4>

<p>-&gt; Tools and Software -&gt; Compilers and Libraries -&gt; Arm GNU toolchain -&gt; GNU Toolchain releases for A-profile processors -&gt; GNU-A Downloads (https://developer.arm.com/downloads/-/gnu-a) -&gt; AArch64 GNU/Linux target (aarch64-none-linux-gnu) (gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz) 다운로드</p>

<hr />

<p>(해당 작업을 wsl2 로 설치한 ubuntu 로 진행하는 경우 다운로드 파일은 windows file system) 내부로 들어오게 된다. 이것을 linux 로 복사하기 위해서는 다음과 같이 복사 및 압풀 해제를 진행한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~/linux<span class="nv">$ </span><span class="nb">cd</span> ..
root@:~<span class="nv">$ </span><span class="nb">cp</span> /mnt/c/Users/&lt;사용자 이름&gt;/Downloads/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz <span class="nb">.</span>
</code></pre></div></div>
<hr />

<h4 id="25-toolchain-압축-풀기">2.5 toolchain 압축 풀기</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span> <span class="nb">tar </span>xvf gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz
</code></pre></div></div>

<h4 id="26-build-진행-이미지-생성">2.6 build 진행 (이미지 생성)</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span><span class="nb">cd </span>linux
root@:~/linux<span class="nv">$ ARCH</span><span class="o">=</span>arm64 <span class="nv">CROSS_COMPILE</span><span class="o">=</span>/home/gon/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu- make <span class="nt">-j16</span>
</code></pre></div></div>
<center><img src="assets\img\posts\2024-02-22-buildroot-setting013.png" width="400" /></center>

<p>build 가 완료되면 위와 같이  vmlinux 를 생성하고 이것을 가지고 arch/arm64/boot/Image 가 생성된것을 확인할 수 있다.</p>

<h3 id="3-buildroot-이미지-실행">3. buildroot 이미지 실행</h3>

<h4 id="31-qemu-설치">3.1 QEMU 설치</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span><span class="nb">sudo </span>apt <span class="nb">install </span>qemu-system-arm
</code></pre></div></div>

<h4 id="32-이미지-실행">3.2 이미지 실행</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@:~<span class="nv">$ </span>qemu-system-aarch64 <span class="se">\</span>
<span class="o">&gt;</span> <span class="nt">-kernel</span> linux/arch/arm64/boot/Image <span class="se">\</span>
<span class="o">&gt;</span> <span class="nt">-drive</span> <span class="nv">format</span><span class="o">=</span>raw,file<span class="o">=</span>buildroot/output/images/rootfs.ext4,if<span class="o">=</span>virtio <span class="se">\</span>
<span class="o">&gt;</span> <span class="nt">-append</span> <span class="s2">"root=/dev/vda console=ttyAMA0 nokaslr"</span> <span class="se">\</span>
<span class="o">&gt;</span> <span class="nt">-nographic</span> <span class="nt">-M</span> virt <span class="nt">-cpu</span> cortex-a72 <span class="se">\</span>
<span class="o">&gt;</span> <span class="nt">-m</span> 2G <span class="se">\</span>
<span class="o">&gt;</span> <span class="nt">-smp</span> 2
</code></pre></div></div>

<center><img src="assets\img\posts\2024-02-22-buildroot-setting014.png" width="600" /></center>

<h4 id="33-이미지-종료">3.3 이미지 종료</h4>

<p>터미널 창을 별도로 열어서 kill 명령어로 종료</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">kill</span> <span class="nt">-9</span> qemu-system-aarch64
</code></pre></div></div>

<p>또는 qemu 내에서 shutdown 명령어로 종료</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shutdown <span class="nt">-h</span> now
</code></pre></div></div>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="buildroot" /><category term="kernel build" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 06]]></summary></entry><entry><title type="html">Makefile 기본 문법 01</title><link href="http://localhost:4000/makfile01.html" rel="alternate" type="text/html" title="Makefile 기본 문법 01" /><published>2024-02-21T14:32:20+09:00</published><updated>2024-02-21T14:32:20+09:00</updated><id>http://localhost:4000/makfile01</id><content type="html" xml:base="http://localhost:4000/makfile01.html"><![CDATA[<h3 id="makefile-변수-macro-사용">Makefile 변수 (macro) 사용</h3>

<p>의존성 부분은 일반적으로 매크로로 선언하여 사용함.</p>

<p>매크로를 사용하여 값을 할당할 때, 여러가지 할당 방법이 존재</p>

<h4 id="-recursive-assignment"><code class="language-plaintext highlighter-rouge">=</code> (Recursive Assignment)</h4>
<p><code class="language-plaintext highlighter-rouge">=</code> 연산자는 재귀적 할당을 수행한다. 이는 매크로가 사용될 때마다 평가되어 확장된다. 매크로의 값이 다른 매크로를 참조하는 경우, 참조된 변수의 최종값에 따라 달라진다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">FOO</span> <span class="o">=</span> <span class="p">${</span>BAR<span class="p">}</span>
<span class="nv">BAR</span> <span class="o">=</span> bar_value

<span class="nl">all</span><span class="o">:</span>
        <span class="err">@echo</span> <span class="err">$(FOO)</span>
</code></pre></div></div>

<p>해당 Makefile 을 실행하면 <code class="language-plaintext highlighter-rouge">FOO</code> 매크로는 <code class="language-plaintext highlighter-rouge">BAR</code>의 값을 참조한다. 따라서 실행될 때, <code class="language-plaintext highlighter-rouge">BAR</code> 의 값은 <code class="language-plaintext highlighter-rouge">bar_value</code> 이므로  <code class="language-plaintext highlighter-rouge">bar_value</code> 가 출력된다.</p>

<h4 id="-simle-assignment"><code class="language-plaintext highlighter-rouge">:=</code> (Simle Assignment)</h4>
<p><code class="language-plaintext highlighter-rouge">:=</code> 연산자를 사용한 단순할당의 경우, 매크로에 값이 할당될 때 시점의 값으로 바로 평가, 확장된다. 따라서 이후 참조하고 있는 매크로의 값이 변경되더라도, 최초에 할당된 값을 유지한다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">BAR</span> <span class="o">=</span> bar_value
<span class="nv">FOO</span> <span class="o">:=</span> <span class="p">$(</span>BAR<span class="p">)</span>
<span class="nv">BAR</span> <span class="o">=</span> new_value

<span class="nl">all</span><span class="o">:</span>
        <span class="err">@echo</span> <span class="err">$(FOO)</span>
</code></pre></div></div>

<p>이 경우, <code class="language-plaintext highlighter-rouge">FOO</code> 는 <code class="language-plaintext highlighter-rouge">BAR</code> 의 현재값인 <code class="language-plaintext highlighter-rouge">bar_value</code> 로 초기화 되고, 이후 <code class="language-plaintext highlighter-rouge">BAR</code> 의 값이 변경되더라도 <code class="language-plaintext highlighter-rouge">FOO</code> 의 값은 변하지 않는다. 따라서 해당 Makefile 을 실행하면 출력값은 <code class="language-plaintext highlighter-rouge">bar_value</code> 가 된다.</p>

<h4 id="-append"><code class="language-plaintext highlighter-rouge">+=</code> (Append)</h4>

<p>기존 변수의 값에 값을 추가함. 만약 매크로가 정의되어 있지 않았었다면 해당 매크로를 생성한다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CFLAGS</span> <span class="o">:=</span> <span class="nt">-Wall</span>
<span class="nv">CFLAGS</span> <span class="o">+=</span> <span class="nt">-g</span>   <span class="c"># CFLAGS는 이제 "-Wall -g"</span>
</code></pre></div></div>

<h4 id="-conditional-assignment"><code class="language-plaintext highlighter-rouge">?=</code> (Conditional Assignment)</h4>

<p>매크로가 아직 값이 할당되어 있지 않을 경우에만 값을 할당. 이미 값이 있으면 할당하지 않음.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CC</span> <span class="o">?=</span> gcc <span class="c"># CC가 이전에 정의되지 않았다면 gcc를 사용</span>
</code></pre></div></div>

<h4 id="-target-name"><code class="language-plaintext highlighter-rouge">$@</code> (Target Name)</h4>

<p><code class="language-plaintext highlighter-rouge">$@</code> : 현재 target 의 이름을 명시</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">all</span><span class="o">:</span> <span class="nf">program</span>
<span class="nl">program</span><span class="o">:</span> <span class="nf">program.o</span>
        <span class="err">gcc</span> <span class="err">-o</span> <span class="err">$@</span> <span class="err">$^</span>
</code></pre></div></div>
<p>이 경우 <code class="language-plaintext highlighter-rouge">program: program.o</code> 에서  <code class="language-plaintext highlighter-rouge">program</code> 이 현재 target 이다.  따라서 <code class="language-plaintext highlighter-rouge">$@</code> 는 <code class="language-plaintext highlighter-rouge">program</code> 으로 대체 된다.</p>

<h4 id="-first-dependency"><code class="language-plaintext highlighter-rouge">$&lt;</code> (First Dependency)</h4>

<p><code class="language-plaintext highlighter-rouge">$&lt;</code> 는 규치의 첫 번째 의존성을 나타냄.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">program.o</span><span class="o">:</span> <span class="nf">program.c</span>
        <span class="err">gcc</span> <span class="err">-c</span> <span class="err">$&lt;</span> <span class="err">-o</span> <span class="err">$@</span>
</code></pre></div></div>
<p>여기서  <code class="language-plaintext highlighter-rouge">$&lt;</code> 는 <code class="language-plaintext highlighter-rouge">program.c</code> 을 의미하므로 <code class="language-plaintext highlighter-rouge">gcc -c $&lt; -o $@</code> 는 <code class="language-plaintext highlighter-rouge">gcc -c program.c -o program.o</code> 를 의미한다.</p>

<h4 id="-all-dependencies"><code class="language-plaintext highlighter-rouge">$^</code> (All Dependencies)</h4>

<p>현재 규칙의 모든 의존성 목록을 나타낸다. 중복된 의존성은 제거된다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">program</span><span class="o">:</span> <span class="nf">main.o lib.o util.o</span>
        <span class="err">gcc</span> <span class="err">-o</span> <span class="err">$@</span> <span class="err">$^</span>
</code></pre></div></div>
<p>여기서 <code class="language-plaintext highlighter-rouge">$^</code> 는 <code class="language-plaintext highlighter-rouge">main.o lib.o util.o</code> 을 의미하므로 <code class="language-plaintext highlighter-rouge">gcc -o $@ $^</code> 는 <code class="language-plaintext highlighter-rouge">gcc -o program main.o lib.o util.o</code> 를 의미한다.</p>

<h4 id="확장자-룰-sffix-rule-과-패턴-규칙pattern-rule">확장자 룰 (sffix rule) 과 패턴 규칙(pattern rule)</h4>

<p>Makefile 의 확장자 룰은 오래된 규칙으로, 파일 변환 규칙을 정의하는데 사용됨. 주로 한 종류의 파일을 다른 종류로 변환하는데 사용되며, 확장자만으로 이 변환 과정을 식별한다. <code class="language-plaintext highlighter-rouge">.SUFFIXES</code> 리스트에 정의된 확장자들을 사용하여, 소스파일에서 목적파일로 변환에 사용될 수 있다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">.SUFFIXES</span><span class="o">:</span> <span class="nf">.c .o</span>

<span class="nl">.c.o</span><span class="o">:</span>
        <span class="err">gcc</span> <span class="err">-c</span> <span class="err">$&lt;</span> <span class="err">-o</span> <span class="err">$@</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">.c.o:</code> 은 <code class="language-plaintext highlighter-rouge">.c</code> 파일을 <code class="language-plaintext highlighter-rouge">.o</code> 파일로 변환하는 규칙을 정의한 target 이다. 따라서 <code class="language-plaintext highlighter-rouge">gcc -c $&lt; -o $@</code> 은 첫번째 의존성 <code class="language-plaintext highlighter-rouge">.c</code> 파일을 동일 파일 이름의 <code class="language-plaintext highlighter-rouge">.o</code> 파일로 compile 하라는 의미 이다. <br /></p>

<p>그러나 현대의 Makefile 작성에서는 패턴 규칙을 사용하는 것이 더 권장된다. 확장자 규칙은 유연성과 명확성이 떨어질 수 있으며, GNU Make와 같은 최신 도구에서는 보다 강력하고 유연한 패턴 규칙을 사용할 수 있다. 패턴 규칙은 특정 파일 세트에 대해 적용할 수 있는 규칙을 정의할 때 % 와일드카드를 사용하여 보다 일반적인 규칙을 작성할 수 있게 해준다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">%.o</span><span class="o">:</span> <span class="nf">%.c</span>
        <span class="err">gcc</span> <span class="err">-c</span> <span class="err">$&lt;</span> <span class="err">-o</span> <span class="err">$@</span>
</code></pre></div></div>

<p>이는 앞의 확장자 룰과 동일한 명령을 수행하며, 좀더 명확하고 간결하게 표현된다.</p>

<p>그러나 결론적으로 동일한 파일명의 소스파일에서 목적 파일을 생성하는 룰은 Makefile 에 기본으로 내장되어 있기 때문에 사용자가 정의하는 Makefile 에서는 해당 내용을 생략해도 실행된다.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">executable</span><span class="o">:</span> <span class="nf">distance.o main.o</span>
        <span class="err">ld</span> <span class="err">-o</span> <span class="err">executable</span> <span class="err">*.o</span> <span class="err">/usr/lib/x86_64-linux-gnu/crt1.o</span> <span class="err">-lm</span> <span class="err">-lc</span> <span class="nv">-dynamic-linker</span><span class="o">=</span>/lib64/ld-linux-x86-64.so.2

<span class="nl">distance.o </span><span class="o">:</span> <span class="nf">distance.c</span>
        <span class="err">gcc</span> <span class="err">-c</span> <span class="err">-o</span> <span class="err">distance.o</span> <span class="err">distance.c</span>

<span class="nl">main.o </span><span class="o">:</span> <span class="nf">main.c</span>
        <span class="err">gcc</span> <span class="err">-c</span> <span class="err">-o</span> <span class="err">main.o</span> <span class="err">main.c</span>
</code></pre></div></div>
<p>위 내용은 아래와 같이 명시적으로 작성하지 않아도,</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">executable</span><span class="o">:</span> <span class="nf">distance.o main.o</span>
        <span class="err">ld</span> <span class="err">-o</span> <span class="err">executable</span> <span class="err">*.o</span> <span class="err">/usr/lib/x86_64-linux-gnu/crt1.o</span> <span class="err">-lm</span> <span class="err">-lc</span> <span class="nv">-dynamic-linker</span><span class="o">=</span>/lib64/ld-linux-x86-64.so.2
</code></pre></div></div>
<p>최종 실행 파일 생성만 구현하고 <code class="language-plaintext highlighter-rouge">make</code>를 실행해도 이전과 동일하게 각 소스코드에서 목적파일이 생성되고 최종적으로 실행파일이 생성된다. 또한 점진적 빌드 (Incremental build) 도 정상적으로 동작한다.</p>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="bash" /><category term="makefile" /><category term="incremental build" /><category term="suffix rule" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 05]]></summary></entry><entry><title type="html">Shell Script 사용한 시스템 구축 01 (사용자 계정 생성)</title><link href="http://localhost:4000/shell-script04-systemsetting01-copy.html" rel="alternate" type="text/html" title="Shell Script 사용한 시스템 구축 01 (사용자 계정 생성)" /><published>2024-02-20T14:32:20+09:00</published><updated>2024-02-20T14:32:20+09:00</updated><id>http://localhost:4000/shell-script04-systemsetting01%20copy</id><content type="html" xml:base="http://localhost:4000/shell-script04-systemsetting01-copy.html"><![CDATA[<p>참고 자료 : <a href="https://product.kyobobook.co.kr/detail/S000001810353">처음 배우는 셸 스크립트 8장 시스템 구축</a></p>

<p>shell script 를 사용하여 사용자 개정을 생성하는 파일을 작성 및 실행</p>

<p>프로세스</p>
<ol>
  <li>사용자 계정과 패스워드 입력</li>
  <li>입력 정보가 없으면 에러 메세지를 보여주고, script 종료</li>
  <li>여러명의 사용자 계정을 생성할 경우 반복문을 사용하여 순회</li>
  <li>각 계정이 이미 사용자 계정에 포함되어 있는지 확인</li>
  <li>포함되어있지 않다면, 계정을 생성하고 패스워드 설정</li>
  <li>이미 존재하는 계정이라면, 이를 메세지로 보여줌.</li>
</ol>

<h3 id="1-다수의-사용자-계정-생성">1. 다수의 사용자 계정 생성</h3>

<p>(1) <code class="language-plaintext highlighter-rouge">if [[ -n $1 ]] &amp;&amp; [[ -n $2 ]]</code>
<br />해당 script 실행시 매개 변수로 사용자 계정(<code class="language-plaintext highlighter-rouge">$1</code>)과 패스워드(<code class="language-plaintext highlighter-rouge">$2</code>)가 모두 입력 되었는지 확인(<code class="language-plaintext highlighter-rouge">-n</code> : 비워있지 않아야 함) 한다. <code class="language-plaintext highlighter-rouge">$1</code> 과 <code class="language-plaintext highlighter-rouge">$2</code> 모두 외부 입력값이므로 이중 중괄호 <code class="language-plaintext highlighter-rouge">[[]]</code> 를 사용한다.
<br /></p>

<p>(2) <code class="language-plaintext highlighter-rouge">IFS=' ' read -r -a UserList &lt;&lt;&lt; "$1"</code> <br />
입력된 매개변수 값을 공백을 기준으로 값을 slice 하여 배열의 형태로 shell script 변수로 저장함.<br /></p>
<ul>
  <li>IFS (Internal Field Separator) : IFS 는 shell scirpt 에서 사용하는 내부 필드 구분자. 이 변수는 문자열을 분리하여 배열이나 개별 변수로 읽을 때 사용하는 구분자을 정의한다. 기본값은 공백, 탭, 개행 문자.</li>
  <li><code class="language-plaintext highlighter-rouge">read</code> : 표준 입력이나 파일로부터 입력을 읽어드림. 이 명령어를 사용하여 변수에 값을 할당할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">-r</code> : <code class="language-plaintext highlighter-rouge">read</code> 옵션 중 백슬래시(<code class="language-plaintext highlighter-rouge">\</code>) 가 이스케이프 문자로 처리되지 않고, 그대로 읽어드림.</li>
  <li><code class="language-plaintext highlighter-rouge">-a</code> : <code class="language-plaintext highlighter-rouge">read</code> 명령어에 의히 읽힌 값을 배열로 저장.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;&lt;&lt;</code> (Here String) :  “$1” 로 받은 외부 입력 값을 UserList 변수 값으로 취할 수 있도록 redirection 해줌. 
<br /></li>
</ul>

<p>(3) <code class="language-plaintext highlighter-rouge">for (( i=0 ; i &lt; ${#UserList[@]}; i++ ))</code> <br />
배열 <code class="language-plaintext highlighter-rouge">UserList</code> 의 길이만큼 반복할 수 있도록 설정
<br /></p>

<p>(4) <code class="language-plaintext highlighter-rouge">if [[ $(cat /etc/passwd | grep -w ${UserList[$i]} | wc -l) == 0 ]] </code><br /></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">$(cat /etc/passwd</code> 파일의 내용을 가져와서,</li>
  <li><code class="language-plaintext highlighter-rouge">UserList[$i]</code> 의 값과 정확히 (<code class="language-plaintext highlighter-rouge">-w</code>)일치하는 사용자 계정을 찾고,</li>
  <li><code class="language-plaintext highlighter-rouge">wc</code> (word count) 의 라인 수(<code class="language-plaintext highlighter-rouge">-l</code>) 을 출력,</li>
  <li>해당 값이 0 아니라면, 동일 계정이 존재한다는 것을 의미함.
<br /></li>
</ul>

<p>(5) <code class="language-plaintext highlighter-rouge">useradd ${UserList[$i]}</code> <br />
기존 계정이 존재하지 않는 경우, 해당 값 <code class="language-plaintext highlighter-rouge">${UserList{$i}}</code> 의 계정을 생성함. 
<br /></p>

<p>(6) <code class="language-plaintext highlighter-rouge">echo "${UserList[$i]}:${Password[$i]}" | chpasswd</code> <br />
새로 생성한 계정에 대한 패스워드 값을 사용하여 패스워드를 설정
<br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c"># 사용자 계정 및 패스워드가 입력되었는지 확인</span>
<span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="nv">$1</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="nv">$2</span> <span class="o">]]</span> <span class="c">#  (1)</span>
<span class="k">then

        </span><span class="nv">IFS</span><span class="o">=</span><span class="s1">' '</span> <span class="nb">read</span> <span class="nt">-r</span> <span class="nt">-a</span> UserList <span class="o">&lt;&lt;&lt;</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="c">#  (2)</span>
        <span class="nv">IFS</span><span class="o">=</span><span class="s1">' '</span> <span class="nb">read</span> <span class="nt">-r</span> <span class="nt">-a</span> Password <span class="o">&lt;&lt;&lt;</span> <span class="s2">"</span><span class="nv">$2</span><span class="s2">"</span>

        <span class="c"># for 문을 이용하여 사용자 계정 생성</span>
        <span class="k">for</span> <span class="o">((</span> <span class="nv">i</span><span class="o">=</span>0 <span class="p">;</span> i &lt; <span class="k">${#</span><span class="nv">UserList</span><span class="p">[@]</span><span class="k">}</span><span class="p">;</span> i++ <span class="o">))</span> <span class="c">#  (3)</span>
        <span class="k">do</span>
                <span class="c"># if문을 사용하여 사용자 계정이 있는지 확인</span>
                <span class="k">if</span> <span class="o">[[</span> <span class="si">$(</span><span class="nb">cat</span> /etc/passwd | <span class="nb">grep</span> <span class="nt">-w</span> <span class="k">${</span><span class="nv">UserList</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span> | <span class="nb">wc</span> <span class="nt">-l</span><span class="si">)</span> <span class="o">==</span> 0 <span class="o">]]</span> <span class="c">#  (4)</span>
                <span class="k">then</span>
                        <span class="c"># 사용자 생성 및 패스워드 설정</span>
                        useradd <span class="k">${</span><span class="nv">UserList</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span> <span class="c">#  (5)</span>
                        <span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">UserList</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span><span class="s2">:</span><span class="k">${</span><span class="nv">Password</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span><span class="s2">"</span> | chpasswd <span class="c">#  (6)</span>
                <span class="k">else</span>
                        <span class="c"># 사용자가 있다고 메세지를 보여줌</span>
                        <span class="nb">echo</span> <span class="s2">"this user </span><span class="k">${</span><span class="nv">UserList</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span><span class="s2"> is existing."</span>
                <span class="k">fi
        done

else</span>
        <span class="c"># 사용자가 계정과 패스워드를 입력하라는 메세지를 보여줌</span>
        <span class="nb">echo</span> <span class="nt">-e</span> <span class="s1">'Please input user id and password. \nUsage: adduser-script.sh "user01 user02" "pw01 pw02"'</span>
<span class="k">fi</span>
</code></pre></div></div>
<p>해당 script 를  <code class="language-plaintext highlighter-rouge">adduser-script.sh</code> 에 저장하고 아래와 같이 실행</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gon@DESKTOP:~/book/ch08<span class="nv">$ </span><span class="nb">sudo </span>bash adduser-script.sh <span class="s2">"user1 user2"</span> <span class="s2">"1111 2222"</span>
</code></pre></div></div>
<p>여기에서 <code class="language-plaintext highlighter-rouge">sh</code> 가 아닌 <code class="language-plaintext highlighter-rouge">bash</code> 명령어를 사용한 이유는, 일부 리눅스 (ex. Ubuntu) shell 이 <code class="language-plaintext highlighter-rouge">bash</code> 가 아닌 <code class="language-plaintext highlighter-rouge">dash</code> 에서 실행되는 경우가 있다. 이런 경우, <code class="language-plaintext highlighter-rouge">dash</code> 에서 지원되지 않는 기능 (ex. redirection <code class="language-plaintext highlighter-rouge">&lt;&lt;&lt;</code>)을 shell script 내 사용한 경우, 다음과 같은 에러가 발생한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gon@DESKTOP:~/book/ch08<span class="nv">$ </span><span class="nb">sudo </span>sh adduser-script.sh <span class="s2">"user1 user2"</span> <span class="s2">"1111 2222"</span>
adduser-script.sh: 7: Syntax error: redirection unexpected
</code></pre></div></div>

<p>이를 해결하는 다른 방법으로, 해당 파일의 실행 권한을 아예 변경하고, 직접 실행 시키면 된다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gon@DESKTOP:~/book/ch08<span class="nv">$ </span><span class="nb">chmod</span> +x adduser-script.sh
gon@DESKTOP:~/book/ch08<span class="nv">$ </span>./adduser-script.sh <span class="s2">"user1 user2"</span> <span class="s2">"1111 2222"</span>
</code></pre></div></div>

<p>최종적으로, 해당 실행이 정상적으로 동작했는지를 위해 <code class="language-plaintext highlighter-rouge">/etc/passwd</code> 파일 내용을 확인하면 아래 해당 user 가 추가된 것을 확인할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gon@DESKTOP:~/book/ch08<span class="nv">$ </span><span class="nb">cat</span> /etc/passwd

...
user1:x:1001:1001::/home/user1:/bin/sh
user2:x:1002:1002::/home/user2:/bin/sh
</code></pre></div></div>

<h3 id="2-ssh--를-활용하여-다른-서버에-사용자-계정-생성">2. ssh  를 활용하여 다른 서버에 사용자 계정 생성</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="k">for </span>server <span class="k">in</span> <span class="s2">"host01 host02 host03"</span>
<span class="k">do</span>
        <span class="c"># 여러 대의 시스템에 사용자 생성 및 패스워드 설정</span>
        <span class="nb">echo</span> <span class="nv">$server</span>
        ssh root@<span class="nv">$server</span> <span class="s2">"useradd </span><span class="nv">$1</span><span class="s2">"</span>  <span class="c"># (1)</span>
        ssh root@<span class="nv">$server</span> <span class="s2">"echo </span><span class="nv">$2</span><span class="s2">:</span><span class="nv">$1</span><span class="s2"> | chpasswd"</span> 
<span class="k">done</span>
</code></pre></div></div>

<p>(1) <code class="language-plaintext highlighter-rouge">ssh root@$server "useradd $1"</code></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ssh</code> : SSH protocol 을 사용하여 원격 서버에 접속하가나 원격 서버에서 명령을 실행하기 위한 client 프로그램</li>
  <li><code class="language-plaintext highlighter-rouge">root@$server</code> : <code class="language-plaintext highlighter-rouge">사용자명@호스트명</code> 형식으로 접속할 원격 서버의 최고 관리자 계정을 의미</li>
  <li><code class="language-plaintext highlighter-rouge">"useradd $1"</code> : ssh root 계정으로 해당 host 에 접속하여 사용자 계정 추가를 실행</li>
</ul>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="bash" /><category term="shell scirpt" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 04]]></summary></entry><entry><title type="html">Shell Script 기본 문법 03 (큰따옴표 작은 따음표)</title><link href="http://localhost:4000/shell-script03-quates.html" rel="alternate" type="text/html" title="Shell Script 기본 문법 03 (큰따옴표 작은 따음표)" /><published>2024-02-10T12:32:20+09:00</published><updated>2024-02-10T12:32:20+09:00</updated><id>http://localhost:4000/shell-script03-quates</id><content type="html" xml:base="http://localhost:4000/shell-script03-quates.html"><![CDATA[<p>Bash 스크립트에서 큰따옴표(““)와 작은따옴표(‘‘)는 문자열을 묶는 데 사용되지만, 그들이 처리하는 방식에는 중요한 차이가 있다.</p>

<h3 id="큰따옴표">큰따옴표(“”)</h3>

<ol>
  <li>
    <p>변수 확장(Expansion)<br />
  큰따옴표 안에 있는 변수는 그 값으로 확장됨. 예를 들어, “$VARIABLE”은 VARIABLE의 값을 나타냄.</p>
  </li>
  <li>
    <p>명령어 치환(Command Substitution)<br />
  큰따옴표 안에서 명령어 치환. 예를 들어, “$(date)”는 현재 날짜와 시간으로 치환됨.</p>
  </li>
  <li>
    <p>공백과 특수 문자<br /> 
  큰따옴표 안의 공백, 탭 등은 문자열의 일부로 유지됨. 이는 여러 단어나 공백을 포함하는 문자열을 하나의 인자나 값으로 처리해야 할 때 유용.</p>
  </li>
</ol>

<h3 id="작은따옴표">작은따옴표(‘’)</h3>

<ol>
  <li>
    <p>문자 그대로의 값<br /> 
  작은따옴표 안의 모든 문자는 그대로의 값으로 처리됨. 변수 확장이나 명령어 치환 같은 것은 일어나지 않는다. 예를 들어, ‘$VARIABLE’은 표기된 문자열 “$VARIABLE” 그 자체를 의미.</p>
  </li>
  <li>
    <p>공백과 특수 문자<br /> 
  작은따옴표 안의 공백과 특수 문자도 문자열의 일부로 유지되며, 이 역시 여러 단어나 공백을 포함하는 문자열을 하나의 인자나 값으로 처리하고자 할 때 유용.</p>
  </li>
</ol>

<h3 id="사용-예시">사용 예시</h3>

<ol>
  <li>
    <p>변수 확장이 필요한 경우<br /> 
  “Hello, $USER” (USER 변수에 해당하는 사용자 이름으로 확장.)</p>
  </li>
  <li>
    <p>명령어 치환을 사용하는 경우<br /> 
  “Today is $(date)” (현재 날짜로 치환.)</p>
  </li>
  <li>
    <p>문자 그대로의 값이 필요한 경우<br /> 
  ‘Data $5 not processed’ (문자열이 그대로 출력, 변수 확장이나 치환 없이.)</p>
  </li>
</ol>

<h3 id="결론">결론</h3>

<p>각각의 사용법은 스크립트에서 변수의 값이나 명령어의 결과를 어떻게 처리할지에 따라 달라진다. 문자열 내에서 변수의 값을 그대로 사용하고 싶지 않거나, 특수 문자를 명령어의 일부로 해석되지 않게 하고 싶을 때 작은따옴표를 사용한다. 반면, 변수의 값을 확장하거나 명령어의 결과를 사용하고자 할 때는 큰따옴표를 사용한다.</p>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="bash" /><category term="shell scirpt" /><category term="quates" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 03]]></summary></entry><entry><title type="html">Shell Script 기본 문법 02 (types)</title><link href="http://localhost:4000/shell-script02-types-copy.html" rel="alternate" type="text/html" title="Shell Script 기본 문법 02 (types)" /><published>2024-02-10T08:32:20+09:00</published><updated>2024-02-10T08:32:20+09:00</updated><id>http://localhost:4000/shell-script02-types%20copy</id><content type="html" xml:base="http://localhost:4000/shell-script02-types-copy.html"><![CDATA[<p>Bash Shell Script에서는 다른 프로그래밍 언어들처럼 명시적인 데이터 타입 선언을 사용하지 않는다. Bash는 기본적으로 모든 변수를 문자열로 처리하지만, Bash 스크립트 내에서 다양한 형태의 데이터를 다룰 수 있으며, 이를 위해 특정 명령어나 구문을 사용하여 숫자, 문자열, 배열 등과 같은 다양한 “형태”의 데이터를 다루게 된다. 아래는 Bash에서 사용될 수 있는 주요 “데이터 타입”의 개념과 예시이다.</p>

<h3 id="문자열-string">문자열 (String)</h3>
<p>Bash에서 가장 기본적이고 자주 사용되는 데이터 타입. 변수에 값을 할당할 때 따옴표를 사용하지 않거나, 단일 따옴표(‘)나 이중 따옴표(“)를 사용하여 문자열을 할당.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">name</span><span class="o">=</span><span class="s2">"John Doe"</span>
<span class="nv">greeting</span><span class="o">=</span><span class="s1">'Hello, World!'</span>
</code></pre></div></div>

<h3 id="정수integer">정수(Integer)</h3>
<p>Bash에서는 declare -i 명령어를 사용하여 변수를 정수로 선언할 수 있다. 또한, 산술 연산에서 Bash는 변수를 자동으로 정수로 취급</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">declare</span> <span class="nt">-i</span> number
<span class="nv">number</span><span class="o">=</span>10
<span class="nb">echo</span> <span class="k">$((</span>number <span class="o">+</span> <span class="m">5</span><span class="k">))</span>  <span class="c"># 15 출력</span>
</code></pre></div></div>

<h3 id="배열array">배열(Array)</h3>
<p>Bash에서 배열은 여러 값을 저장할 수 있는 데이터 구조. 배열은 0부터 시작하는 인덱스를 가지며, ()를 사용하여 배열을 선언.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">arr</span><span class="o">=(</span>1 2 <span class="s2">"hello"</span> <span class="s2">"world"</span><span class="o">)</span>
<span class="nb">echo</span> <span class="k">${</span><span class="nv">arr</span><span class="p">[0]</span><span class="k">}</span>  <span class="c"># 1 출력</span>
<span class="nb">echo</span> <span class="k">${</span><span class="nv">arr</span><span class="p">[3]</span><span class="k">}</span>  <span class="c"># world 출력</span>
</code></pre></div></div>

<ul>
  <li>Bash 배열과 다른 프로그래밍 언어 배열 (ex. C)과 다른점 <br /></li>
</ul>

<ol>
  <li>
    <p>index &amp; mata-data <br />
Bash 배열의 구현은 C 배열과 달리 고수준에서 이루어지기 때문에, 원소가 저장된 메모리에 대한 접근 방법 등을 고려할 필요가 없다.  Bash 배열은 각 원소애 대한 index 와 mata-data 를 내부적으로 유지하며, 여기에 원소의 위치, 길이 등이 포함될 수 있다. <br /></p>
  </li>
  <li>
    <p>동적 할당과 관리<br />
Bash는 필요에 따라 동적으로 메모리를 할당하고, 배열의 원소를 관리한다. 사용자가 배열에 원소를 추가하거나 제거할 때, Bash는 내부적으로 이러한 변경을 처리하고, 배열의 각 원소가 올바르게 접근될 수 있도록 한다.</p>
  </li>
  <li>
    <p>추상화된 접근 방식<br />
사용자가 배열의 원소에 접근할 때, Bash는 추상화된 인터페이스(예: 인덱스를 사용-한 접근)를 제공한다. 사용자는 인덱스를 통해 간단하게 원소에 접근할 수 있으며, Bash가 원소의 실제 메모리 위치와 경계를 관리한다.<br /></p>
  </li>
</ol>

<h3 id="연관-배열associative-arrays">연관 배열(Associative Arrays)</h3>
<p>ash 4 이상에서는 연관 배열(키-값 쌍을 저장하는 배열)을 사용할 수 있음. declare -A를 사용하여 연관 배열을 선언.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">declare</span> <span class="nt">-A</span> fruits
fruits[apple]<span class="o">=</span><span class="s2">"red"</span>
fruits[banana]<span class="o">=</span><span class="s2">"yellow"</span>
<span class="nb">echo</span> <span class="k">${</span><span class="nv">fruits</span><span class="p">[apple]</span><span class="k">}</span>  <span class="c"># red 출력</span>
</code></pre></div></div>

<h3 id="부동-소수점floating-point-numbers">부동 소수점(Floating Point Numbers)</h3>
<p>Bash 자체는 부동 소수점 수를 직접 지원하지 않는다. 부동 소수점 연산을 수행하려면 bc나 awk와 같은 외부 도구를 사용해야 함.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">result</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="s2">"3.5 + 4.2"</span> | bc<span class="si">)</span>
<span class="nb">echo</span> <span class="nv">$result</span>  <span class="c"># 7.7 출력</span>
</code></pre></div></div>

<h3 id="환경-변수environment-variables">환경 변수(Environment Variables)</h3>
<p>환경 변수는 운영 체제의 환경 설정을 포함하는 전역 변수. Bash 스크립트에서는 이러한 환경 변수를 읽고 설정할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="nv">$PATH</span>
<span class="nb">export </span><span class="nv">MY_VAR</span><span class="o">=</span><span class="s2">"SomeValue"</span>
</code></pre></div></div>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="bash" /><category term="shell scirpt" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 02]]></summary></entry><entry><title type="html">Shell Script 기본 문법 01</title><link href="http://localhost:4000/shell-script01.html" rel="alternate" type="text/html" title="Shell Script 기본 문법 01" /><published>2024-02-10T08:32:20+09:00</published><updated>2024-02-10T08:32:20+09:00</updated><id>http://localhost:4000/shell-script01</id><content type="html" xml:base="http://localhost:4000/shell-script01.html"><![CDATA[<h3 id="1-간단한-함수를-사용한-script-1">1. 간단한 함수를 사용한 script 1</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c"># 함수 정의: 두 인자를 받아 출력함</span>
add_inner_numbers<span class="o">()</span> <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">"첫 번째 숫자: </span><span class="nv">$1</span><span class="s2">"</span>
    <span class="nb">echo</span> <span class="s2">"두 번째 숫자: </span><span class="nv">$2</span><span class="s2">"</span>
    
    <span class="nb">local sum</span><span class="o">=</span>0
    <span class="nb">sum</span><span class="o">=</span><span class="k">$((</span> <span class="nv">$1</span> <span class="o">+</span> <span class="nv">$2</span> <span class="k">))</span>
    <span class="nb">echo</span> <span class="s2">"두 수의 합: </span><span class="nv">$sum</span><span class="s2">"</span>
<span class="o">}</span>

<span class="c"># 함수 호출: 5와 10을 인자로 전달</span>
add_inner_numbers 5 10
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">#!/bin/bash</code>
    <ul>
      <li>“shebang” (또는 “hashbang”)</li>
      <li>해당 script를 실행할 때 사용할 interpreter 의 경로를 진행</li>
      <li>여기서는 Bash shell 을 사용하여 실행되어야 함을 의미</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">subtract_num() {}</code></li>
  <li>
    <p>script 함수를 정의할 때, 매개변수는 명시하지 않는다. 함수 내 $1, $2, $3 … 과 같이 함수 내부에 명시된 value 의 숫자값에 순서대로 매칭되어 입력된다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">sum=$(( $1 + $2 ))</code>
    <ul>
      <li>첫번째 괄호는 $() 로 연산 결과를 값으로 취함을 의미</li>
      <li>두번째 괄호는 연산에 대한 괄호</li>
      <li>띄어쓰기는 여기서는 결과에 영향을 미치지는 않지만 일반적인 작성 기준을 따름.</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>실행 결과</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@DESKTOP:~<span class="nv">$ </span>./example.sh
첫 번째 숫자: 5
두 번째 숫자: 10
두 수의 합: 15
</code></pre></div></div>

<h3 id="2-간단한-함수를-사용한-script-2-외부-입력">2. 간단한 함수를 사용한 script 2 (외부 입력)</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c">#  두수를 빼는  함수 정의</span>
subtract_num<span class="o">()</span> <span class="o">{</span>
        <span class="nb">local </span><span class="nv">sub</span><span class="o">=</span>0
        <span class="nv">sub</span><span class="o">=</span><span class="k">$((</span> <span class="nv">$2</span> <span class="o">-</span> <span class="nv">$1</span> <span class="k">))</span>
        <span class="nb">echo</span> <span class="s2">"두 수의 차: </span><span class="nv">$sub</span><span class="s2">"</span>
<span class="o">}</span>

<span class="c"># 사용자로부터 두수 입력 받기</span>
<span class="nb">read</span> <span class="nt">-p</span> <span class="s2">"첫번째 수를 입력하세요: "</span> num1
<span class="nb">read</span> <span class="nt">-p</span> <span class="s2">"두번째 수를 입력하세요: "</span> num2

<span class="c"># 함수 호출</span>
subtract_num <span class="nv">$num1</span> <span class="nv">$num2</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">read -p "첫번째 수를 입력하세요: " num1</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">read</code> 명령어로 표준입력 값을 받을 수 있다.</li>
      <li><code class="language-plaintext highlighter-rouge">-p</code> 옵션으로 <code class="language-plaintext highlighter-rouge">echo</code> 명령어를 사용하지 않고 프롬프트 메세지를 보여줄 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>실행 결과</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@DESKTOP:~<span class="nv">$ </span>./example.sh
첫번째 수를 입력하세요: 2
두번째 수를 입력하세요: <span class="nt">-5</span>
두 수의 차: <span class="nt">-7</span>
</code></pre></div></div>

<h3 id="3-간단한-함수를-사용한-script-3-외부-입력-조건문">3. 간단한 함수를 사용한 script 3 (외부 입력, 조건문)</h3>

<p>외부 입력을 함수의 실행과 함께 받도록 아래와 같이 구현할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c">#  두수를 빼는  함수 정의</span>
subtract_num<span class="o">()</span> <span class="o">{</span>
        <span class="nb">local </span><span class="nv">sub</span><span class="o">=</span>0
        <span class="nv">sub</span><span class="o">=</span><span class="k">$((</span> <span class="nv">$2</span> <span class="o">-</span> <span class="nv">$1</span> <span class="k">))</span>
        <span class="nb">echo</span> <span class="s2">"두 수의 차: </span><span class="nv">$sub</span><span class="s2">"</span>
<span class="o">}</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$# </span><span class="nt">-ne</span> 2 <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"사용방법: </span><span class="nv">$0</span><span class="s2"> 숫자1 숫자2"</span>
        <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># 함수 호출</span>
subtract_num <span class="nv">$1</span> <span class="nv">$2</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">if [ $# -ne 2 ]; then ... fi</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">[];</code> 내 조건이 참일 경우, <code class="language-plaintext highlighter-rouge">then ... fi</code> 내 명령어를 실행</li>
      <li><code class="language-plaintext highlighter-rouge">if</code>, <code class="language-plaintext highlighter-rouge">[];</code>, <code class="language-plaintext highlighter-rouge">then</code> 사이에는 띄어쓰기를 반드시 해야 함.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">$# -ne 2</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">$#</code> 은 script 에 전달된 positional parameter 의 갯수. 위 예제의 경우, <code class="language-plaintext highlighter-rouge">./example.sh 1 2</code> 와 같이 실행되는데, 이 때 <code class="language-plaintext highlighter-rouge">$#</code> 값은 2 이다.</li>
      <li><code class="language-plaintext highlighter-rouge">-ne</code> 은 “not equal”  의 약자로, 두 값이 서로 다른지를 비교</li>
      <li><code class="language-plaintext highlighter-rouge">2</code> 는 비교 대상의 값</li>
      <li>즉 해당 script 부분은 “입력된 positional parameter 갯수가 2개가 아니라면” 이라는 조건을 정의함.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">echo "..." exit 1</code>
    <ul>
      <li>해당 조건일 때, 메세지를 출력하고 에러 상태로 script 를 종료</li>
      <li><code class="language-plaintext highlighter-rouge">exit 0</code> 인 경우, 정상적으로 작업이 성공되고 종료됨을 의미, 0 이 아닌 경우는, 에러나 특정 조건으로 인한 종료를 의미</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>실행 결과</li>
</ul>

<p>매개변수를 입력하지 않은 경우</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@DESKTOP~<span class="nv">$ </span>./example.sh
사용방법: ./example.sh 숫자1 숫자2
</code></pre></div></div>

<p>매개변수 값을 함께 입력한 경우</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@DESKTOP:~<span class="nv">$ </span>./example.sh 3 3
두 수의 차: 0
</code></pre></div></div>

<h3 id="4-파일-입력--반복문을-이용-script">4. 파일 입력 &amp; 반복문을 이용 script</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c"># 'list' 파일을 읽어와 line 변수에 저장</span>
<span class="k">while </span><span class="nb">read</span> <span class="nt">-r</span> line<span class="p">;</span> <span class="k">do</span>
    <span class="c"># 공백으로 구분된 값을 배열로 변환</span>
    <span class="nv">IFS</span><span class="o">=</span><span class="s1">' '</span> <span class="nb">read</span> <span class="nt">-ra</span> ADDR <span class="o">&lt;&lt;&lt;</span> <span class="s2">"</span><span class="nv">$line</span><span class="s2">"</span>
    <span class="c"># 배열의 각 요소를 반복하여 출력</span>
    <span class="k">for </span>i <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">ADDR</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do
        </span><span class="nb">echo</span> <span class="nv">$i</span>
    <span class="k">done
done</span> &lt; <span class="s2">"list"</span>
</code></pre></div></div>

<p>list 파일</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 2 3 4 5
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">while read -r line: do ... done &lt; "list"</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">list</code> 파일로 부터 해당 내용을 줄별로 읽어와서 각 줄의 값을 <code class="language-plaintext highlighter-rouge">line</code> 변수의 값으로 생성한다.</li>
      <li><code class="language-plaintext highlighter-rouge">-r</code> 옵션은 <code class="language-plaintext highlighter-rouge">read</code> 명령어가 <code class="language-plaintext highlighter-rouge">\</code> 을 이스케이프 문자가 아닌 데이터 원본 그대로 무결성을 유지한채로 값을 가질 수 있도록 조건을 부여한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">IFS=' ' read -ra ADDR &lt;&lt;&lt; "$line"</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">IFS</code> 는 “Internal Field Separator” 의 약자, Bash 에서 단어 경계를 정의하는데 사용되는 환경 변수. 이 구분에서 <code class="language-plaintext highlighter-rouge">IFS</code> 는 공백문자 <code class="language-plaintext highlighter-rouge">' '</code> 로 설정되어 단어의 구분을 공백으로 사용하겠다는 의미.</li>
      <li><code class="language-plaintext highlighter-rouge">-ra</code> 에서 <code class="language-plaintext highlighter-rouge">a</code> 옵션은 입력된 data 를 배열로 변수 <code class="language-plaintext highlighter-rouge">ADDR</code> 에 저장함을 의미</li>
      <li><code class="language-plaintext highlighter-rouge">&lt;&lt;&lt;</code> 은 here string redirction 을 의미. <code class="language-plaintext highlighter-rouge">here string</code> 은 문자열 데이터를 명령어의 표준입력으로 직접 전달할 수 있게 해준다. <code class="language-plaintext highlighter-rouge">명령어 &lt;&lt;&lt; "문자열"</code> 과 같은 형태로, redirection 을 뒤에 오는 문자열 값을 바로 가져와서 사용할 수 있게 해준다. 예를 들어,
        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@DESKTOP:~<span class="nv">$ </span><span class="nb">grep</span> <span class="s2">"찾는"</span> <span class="o">&lt;&lt;&lt;</span> <span class="s2">"여기에는 찾는 단어가 있을까요?"</span>
여기에는 찾는 단어가 있을까요?
</code></pre></div>        </div>
        <p>와 같이, 외부 파일 등에서 가져오는 것이 아니라 뒤에 명시된 문자열 값을 바로 redirection 하여 가져와 사용하게 된다.</p>
      </li>
      <li>따라서 해당 구문을 정리하면,<br />
(1). line 변수 값을 문자열로 생성한다.<br />
(2). (1) 번 값을 redirection 하여 가져오고,<br /> 
(3). <code class="language-plaintext highlighter-rouge">\</code> 를 별도 처리하지 않고, <br />
(4). 띄어쓰기(‘ ‘) 로 구분하여 생성된 배열 값을<br /> 
(5). 배열 변수 <code class="language-plaintext highlighter-rouge">ADDR</code> 의 값으로 생성한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">for i in "${ADDR[@]}"; do ... done</code>
    <ul>
      <li>반복문 <code class="language-plaintext highlighter-rouge">for</code> 는 배열 변수 ADDR 의 원소를 순회하면서 원소값 을 대입하여 <code class="language-plaintext highlighter-rouge">do ... done</code> 내 script 를 수행함.</li>
      <li><code class="language-plaintext highlighter-rouge">ADDR[@]</code> 는 각 원소를 의미</li>
      <li><code class="language-plaintext highlighter-rouge">""</code> 감싸 해당 원소값을 문자열로 변환, 혹시 문자열 내 다른 문자열을 포함한 경우 (ex. “값은 ${ADDR[@]}”) 다른 문자열과  배열 변수 값 부분을 명확히 구분하기 위해 <code class="language-plaintext highlighter-rouge">${}</code> 로 감싸줌.</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>실행 결과</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@DESKTOP:~<span class="nv">$ </span>./example.sh
1
2
3
4
5
</code></pre></div></div>]]></content><author><name>Yong gon Yun</name></author><category term="linux" /><category term="shell scirpt" /><summary type="html"><![CDATA[개발자를 위한 반도체 SW개발 기초 (디바이스 드라이버 개발) 관련 학습 01]]></summary></entry><entry><title type="html">Phoenix Live Generator</title><link href="http://localhost:4000/phonix-generator.html" rel="alternate" type="text/html" title="Phoenix Live Generator" /><published>2024-01-26T08:32:20+09:00</published><updated>2024-01-26T08:32:20+09:00</updated><id>http://localhost:4000/phonix-generator</id><content type="html" xml:base="http://localhost:4000/phonix-generator.html"><![CDATA[<p>(아래 내용은 <a href="https://pragprog.com/titles/liveview/programming-phoenix-liveview/">programming-phoenix-liveview_B10.0 - chapter 3 Generators: Contexts and Schemas</a> 를 정리한 것임을 밝힙니다.)</p>

<h3 id="phoenix-live-generator-란">Phoenix Live Generator 란?</h3>

<p>Phoenix Live Generator 는 주어진 resource 에 대한 기본적인 CRUD code 생성을 도와주는 utility 로 다음 작업에 대한 설정을 자동을 생성해준다.</p>

<ul>
  <li>backend  : schema, context</li>
  <li>frontend : routs, LiveView, templates</li>
</ul>

<p>다만 위에서 표현한 ‘code 생성’ 의 의미는 elixir 에서는 조금 다른 의미를 포함하고 있다. 이는 Generator 가 자체적으로 새로운 code 을 생성 해준다기보다, 이미 정의된 macro 를 사용하여 ‘code 를 생성하는 code’ 를 실행시킴으로써, 최종적으로 사용자가 정의한 code 를 얻을 수 있게 되는 것을 의미한다.</p>

<p>결과적으로 Generator 를 사용하여, 작성자의 반복적 작업을 줄여 줌으로써, 작성자는 각 부분의 logic 및 공통적이지 않은 부분의 작업에 집중할 수 있도록 도와준다.</p>

<h3 id="phoenix-live-generator-기본-구조">Phoenix Live Generator 기본 구조</h3>

<p>간단한 예제로 상품에 대한 정보를 DB 에 저장하고, 상품 리스트를 화면에 보여주는 view 를 가진 application 을 개발한다고 가정해보면, 해당 application 의 구조를 아래와 같이 그려볼 수 있다.</p>

<center><img src="assets\img\posts\2024-01-26-product_diagram.png" width="300" /></center>

<ul>
  <li>frontend: web 에서 <code class="language-plaintext highlighter-rouge">/product</code> GET 요청이 있을 때, 상품 리스트를 보여주는 tempalte 이 rendering 됨.</li>
  <li>backend : phoenix application 에서 live view 는 전체적으로 context 에 관리되며, core part 인 schema 를 감싸고 있다. 즉, context 는 frontend 및 DB 와 상호작용을 담당한다.</li>
</ul>

<h3 id="phoenix-live-generator-의-실행">Phoenix Live Generator 의 실행</h3>

<p>기본 원리와 개념 이해를 위해, 아래 command 를 실행하여, Generator 를 실행시킨다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mix phx.gen.live Catalog Product products name:string <span class="se">\</span>
description:string unit_price:float sku:integer:unique
</code></pre></div></div>

<p>그러면 자동으로 관련 migration, schema 를 포함한 context, template 파일들이 생성되며, command 속성값들의 의미는 다음과 같다.</p>

<ul>
  <li>Catalog : boundary layer 인 context</li>
  <li>Product : applcation core 인 schema</li>
  <li>prodcuts: DB table</li>
  <li>name:string description:string unit_price:float sku:integer:unique : schema fields &amp; DB table colums</li>
</ul>

<h3 id="generated-core-의-이해">Generated Core 의 이해</h3>

<p>Generated Core (ex. Product) 는,</p>

<ul>
  <li>항상 동일한 입력에 대해 동일한 출력을 제공하는 순수함수이여야 한다.</li>
  <li>database 를 관리하며 상호작용 한다. 즉 database table 생성, data 관리/유지 작업, transaction 과 query 준비 작업을 담당한다.</li>
</ul>

<p>이와 관련된 파일들을 살펴보면 다음과 같다.</p>

<h4 id="the-product-migration">The Product Migration</h4>

<p>database table 을 정의한 migration 파일을 <code class="language-plaintext highlighter-rouge">pento/priv/repo/migrations/20230728120332_create_products.exs</code>와 같이 생성되어 진다. 해당 code 를 살펴보면 아래와 같이 command 에서 명시한 table 이름, column 명, data type 이 생성되어 있다.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">Pento</span><span class="o">.</span><span class="no">Repo</span><span class="o">.</span><span class="no">Migrations</span><span class="o">.</span><span class="no">CreateProducts</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Migration</span>

  <span class="k">def</span> <span class="n">change</span> <span class="k">do</span>
    <span class="n">create</span> <span class="n">table</span><span class="p">(</span><span class="ss">:products</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">add</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:string</span>
      <span class="n">add</span> <span class="ss">:description</span><span class="p">,</span> <span class="ss">:string</span>
      <span class="n">add</span> <span class="ss">:unit_price</span><span class="p">,</span> <span class="ss">:float</span>
      <span class="n">add</span> <span class="ss">:sku</span><span class="p">,</span> <span class="ss">:integer</span>

      <span class="n">timestamps</span><span class="p">()</span>
    <span class="k">end</span>

    <span class="n">create</span> <span class="n">unique_index</span><span class="p">(</span><span class="ss">:products</span><span class="p">,</span> <span class="p">[</span><span class="ss">:sku</span><span class="p">])</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>그리고 아래 command 실행을 통해 DB 에 해당 table 이 생성됨을 확인할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mix ecto.migrate
</code></pre></div></div>

<h4 id="the-product-schema">The Product Schema</h4>

<p>아래 <code class="language-plaintext highlighter-rouge">lib/pento/catalog/product.ex</code> 생성된 파일 <code class="language-plaintext highlighter-rouge">schema</code> macro 구현부를 통해 Elixir 구조체와 databalse <code class="language-plaintext highlighter-rouge">products</code> table record 간 변환할 수 있게 해준다.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">Pento</span><span class="o">.</span><span class="no">Catalog</span><span class="o">.</span><span class="no">Product</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Schema</span>
  <span class="kn">import</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Changeset</span>
  
  <span class="n">schema</span> <span class="s2">"products"</span> <span class="k">do</span>
    <span class="n">field</span> <span class="ss">:description</span><span class="p">,</span> <span class="ss">:string</span>
    <span class="n">field</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:string</span>
    <span class="n">field</span> <span class="ss">:sku</span><span class="p">,</span> <span class="ss">:integer</span>
    <span class="n">field</span> <span class="ss">:unit_price</span><span class="p">,</span> <span class="ss">:float</span>
  <span class="n">timestamps</span><span class="p">()</span>
<span class="k">end</span>
</code></pre></div></div>

<p>관련 작업을 수행해주는 함수의 경우, macro 에 의해 자동 생성되며, 그 목록은 아래와 같다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; <span class="nb">alias </span>Pento.Catalog.Product
iex&gt; exports Product
__changeset__/0 __schema__/1 __schema__/2 __struct__/0
__struct__/1 changeset/2

</code></pre></div></div>

<p>이중 <code class="language-plaintext highlighter-rouge">schema</code> 함수가 elixir 구조체를 생성해서 database table record 와 엮는 작업을 담당한다.</p>

<p>해당 구조체 생성은 <code class="language-plaintext highlighter-rouge">struct/1</code> 로 생성하며, 이를 CLI 상태에서 실행하여, 직접 그 결과를 확인할 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; Product.__struct__<span class="o">(</span>name: <span class="s2">"Exploding Ninja Cows"</span><span class="o">)</span>
%Pento.Catalog.Product<span class="o">{</span>
  __meta__: <span class="c">#Ecto.Schema.Metadata&lt;:built, "products"&gt;,</span>
  description: nil,
  <span class="nb">id</span>: nil,
  inserted_at: nil,
  name: <span class="s2">"Exploding Ninja Cows"</span>,
  sku: nil,
  unit_price: nil,
  updated_at: nil
<span class="o">}</span>
</code></pre></div></div>

<p>여기에서 <code class="language-plaintext highlighter-rouge">id</code>, <code class="language-plaintext highlighter-rouge">inserted_at</code>, <code class="language-plaintext highlighter-rouge">updated_at</code> field 의 경우, 자동 생성되는 field 로 record 관리에 필요한 data (ex. <code class="language-plaintext highlighter-rouge">id</code> 의 경우, 각 record 고유값으로 식별자 역할) 들을 저장한다.</p>

<p><code class="language-plaintext highlighter-rouge">changeest</code> 의 경우, 기존에 정리된 내용 참고. (<a href="https://y2gon2.github.io/changeset.html">changeset/2 in Ecto Library</a>)</p>

<h3 id="generated-boundary-의-이해">Generated Boundary 의 이해</h3>

<p>boundary 영역에 대한 code 을 Context 라고 하며, 외부에서 입력된 data 를 sanitizing, validating 해서 변환된 data 를 cord 영역으로 넘겨주는 작업을 담당하며 이를 정리하면 아래와 같다.</p>

<ul>
  <li>Access External Services : 외부 서비스에 대한 단일 접근 지점을 제공. application 에서 필요한 외부 data 나 기능을 통합하고, 이러한 서비스들과 상호 작용을 중앙에서 관리하게 해줌.</li>
  <li>Abstract Away Tedious Details : 반복적이거나 복잡한 작업등ㄹ을 숨김(추상화) 함으로써, 개발자가 보다 중요한 logic 에 집중할 수 있도록 함. 예를 들어, data formating 이나 네트워크 통신과 같은 작업을 사전에 처리</li>
  <li>Handle uncertainty : {:ok, result} 또는 {:error, message} 와 같은 형태로 그 결과를 반환함으로써, 성공 또는 실패를 명확하게 함. 이를 통해, 오류 처리 및 예외 상황을 보다 효율적으로 처리할 수 있음.</li>
  <li>Present a single, common API : 하나의 database table 관련 service 들에 대해 단일 접근점을 제공하여 application 내 다양한 기능들을 일관된 방식으로 사용할 수 있게 해주며, 이를 통해 application 의 사용성과 유지보수서을 향상시킴.</li>
</ul>

<h4 id="외부-service-로부터의-접근의-예">외부 service 로부터의 접근의 예</h4>

<p>database 의 접근은 applciation 입장에서 외부 service 에 대한 접근에 해당한다. 관련 Repo 작업은 <code class="language-plaintext highlighter-rouge">Ecto</code> library 함수를 사용하게 되며, 따라서 <code class="language-plaintext highlighter-rouge">Ecto</code> code 도 core 와 boundary 부분으로 나누어지게 된다.</p>

<ul>
  <li>Ecto core : query build &amp; transaction 준비 작업 (외부 환경에 영향 없이 입력값과 내부 logic 에만 영향을 받아 결과가 항상 확정적이고 예측가능, ex. <code class="language-plaintext highlighter-rouge">changeset</code>)</li>
  <li>Ecto boundary : <code class="language-plaintext highlighter-rouge">Ecto.Repo</code> 작업의 경우, 외부 상황 (ex. DB server 연결 상태)에 따라 그 결과가 바뀔 수 있으므로, boundary 에 해당</li>
</ul>]]></content><author><name>Yong gon Yun</name></author><category term="phoenix" /><category term="generator" /><summary type="html"><![CDATA[Phoenix Live Generator 는 주어진 resource 에 대한 기본적인 CRUD code 생성을 도와주는 utility 이다. 이에 대해 알아보자.]]></summary></entry><entry><title type="html">(App 개발 03) Account context - users table 에 nickname 항목 추가</title><link href="http://localhost:4000/users-column-add.html" rel="alternate" type="text/html" title="(App 개발 03) Account context - users table 에 nickname 항목 추가" /><published>2024-01-25T10:32:20+09:00</published><updated>2024-01-25T10:32:20+09:00</updated><id>http://localhost:4000/users-column-add</id><content type="html" xml:base="http://localhost:4000/users-column-add.html"><![CDATA[<p>Phoenix LiveView Authrization 설정을 위해 lon in 기능을 활성화에 필요한 계정 생성 작업이 필요하다. 이 때, <code class="language-plaintext highlighter-rouge">mix phx.gen.auth Accounts User users</code> command 를 통해 사용자 email, password 정보를 저장하고 이를 사용하여 authrization, session 괸리를 위한 service code, template, token 저장 table 까지 모두 알아서 생성해 준다.</p>

<p>매우 편리한 기능이지만, 해당 command 로 추가 정보를 저장/관리하는 기능을 함께 생성할 수는 없음을 확인하였다. 대신 추가 migration 생성 및 필요한 요소를 관련 code 에 직접 추가하여 사용 가능하였다.</p>

<p>현재 작업하고 있는 application 에서 사용자 정보를 노출 시킬 때, email 보다 nickname 으로 보여지는 것이 좋다고 판단되어 이를 추가하고 실제 application 에 반영하는 작업을 정리해 보았다.</p>

<h3 id="1-migration-생성-및-실행">1. migration 생성 및 실행</h3>

<p>다음의 command 를 실행하여 migration script 파일을 생성</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mix ecto.gen.migration add_nickname_to_users
</code></pre></div></div>

<p>이를 실행하면 <code class="language-plaintext highlighter-rouge">priv/repo/migrations/(생성일시)_add_nickname__to_users.exs</code> 파일이 생성된다. 해당 파일에서 <code class="language-plaintext highlighter-rouge">nickname</code> column 을 추가할 code 를 작성한다.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">MyPjt1</span><span class="o">.</span><span class="no">Repo</span><span class="o">.</span><span class="no">Migrations</span><span class="o">.</span><span class="no">AddNicknameToUsers</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Migration</span>

  <span class="k">def</span> <span class="n">change</span> <span class="k">do</span>
    <span class="n">alter</span> <span class="n">table</span><span class="p">(</span><span class="ss">:users</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">add</span> <span class="ss">:nickname</span><span class="p">,</span> <span class="ss">:string</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>해당 파일을 아래의 command 로 실행하고, database 에 변경 사항이 반영되었는지 확인한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mix ecto.migrate
</code></pre></div></div>

<h3 id="2-user-module-에서-schema-및-changeset2-수정">2. <code class="language-plaintext highlighter-rouge">User</code> module 에서 schema 및 <code class="language-plaintext highlighter-rouge">changeset/2</code> 수정</h3>

<p>아래와 같이 <code class="language-plaintext highlighter-rouge">Usher</code> module 에서 <code class="language-plaintext highlighter-rouge">schema</code> 에 field 를 추가시켜 준다.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">schema</span> <span class="s2">"users"</span> <span class="k">do</span>
    <span class="n">field</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:string</span>
    <span class="n">field</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">:string</span><span class="p">,</span> <span class="ss">virtual:</span> <span class="no">true</span><span class="p">,</span> <span class="ss">redact:</span> <span class="no">true</span>
    <span class="n">field</span> <span class="ss">:hashed_password</span><span class="p">,</span> <span class="ss">:string</span><span class="p">,</span> <span class="ss">redact:</span> <span class="no">true</span>
    <span class="n">field</span> <span class="ss">:confirmed_at</span><span class="p">,</span> <span class="ss">:naive_datetime</span>
    <span class="n">field</span> <span class="ss">:nickname</span><span class="p">,</span> <span class="ss">:string</span>  <span class="c1"># field 추가</span>

    <span class="n">timestamps</span><span class="p">(</span><span class="ss">type:</span> <span class="ss">:utc_datetime</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>그러나, field 를 추가하고, 계정 등록 module (<code class="language-plaintext highlighter-rouge">user_registration_live.ex</code>) 에서 nickname 입력을 구현하여도 실제로 저장이 되지 않는다. 그 이유는 nickname 정보까지 모두 입력 후 저장 버튼을 누를 때, 입력 값의 유효성 검증이 우선 진행되며, 검증을 통과된 경우, db 에 저장 및 authorization 작업이 진행되게 된다.</p>

<p>그런데, 관련 유효성 검증 작업, 즉 <code class="language-plaintext highlighter-rouge">changeset/2</code> code 를 확인하면</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">registration_changeset</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">opts</span> <span class="p">\\</span> <span class="p">[])</span> <span class="k">do</span>
    <span class="n">user</span>
    <span class="o">|&gt;</span> <span class="n">cast</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="p">[</span><span class="ss">:email</span><span class="p">,</span> <span class="ss">:password</span><span class="p">])</span>
    <span class="o">|&gt;</span> <span class="n">validate_email</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">validate_password</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>여기에서 <code class="language-plaintext highlighter-rouge">cast(attrs, [:email, :password])</code> 함수는 매개변수로 입력된 key 들 (<code class="language-plaintext highlighter-rouge">:email, :password</code>) 에 대한 value 값이 변경되었을 때, 해당 항목에 대한 <code class="language-plaintext highlighter-rouge">changeset</code> 을 반환하는 함수이다. 즉 해당 항목에 <code class="language-plaintext highlighter-rouge">:nickname</code> 을 추가해 주어야 함께 <code class="language-plaintext highlighter-rouge">changeset</code> 으로 변환되어, 유효성을 검증하고, 다음 작업을 진행할 수 있게 된다. (<code class="language-plaintext highlighter-rouge">:nickname</code>에 대한 vaildation 은 필요하지 않아서 추가하지 않았음.)</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">registration_changeset</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">opts</span> <span class="p">\\</span> <span class="p">[])</span> <span class="k">do</span>
    <span class="n">user</span>
    <span class="o">|&gt;</span> <span class="n">cast</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="p">[</span><span class="ss">:email</span><span class="p">,</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">:nickname</span><span class="p">])</span> <span class="c1"># :nickname 추가</span>
    <span class="o">|&gt;</span> <span class="n">validate_email</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">validate_password</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre></div></div>

<h3 id="3-계정-생성-시-nickname-추가-화면-구현">3. 계정 생성 시 nickname 추가 화면 구현</h3>

<p><code class="language-plaintext highlighter-rouge">user_registration_live.ex</code> <code class="language-plaintext highlighter-rouge">render/2</code> 내 아래와 같이 nickname 항목을 추가하면 최종적으로 계정 생성시 nickname 정보까지 입력해야 조건을 만들어 줄 수 있다.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">...</span>
  <span class="o">&lt;.</span><span class="n">simple_form</span> <span class="o">...</span> <span class="o">&gt;</span>
    <span class="o">...</span>
    <span class="o">&lt;.</span><span class="n">input</span> <span class="n">field</span><span class="o">=</span><span class="p">{</span><span class="nv">@form</span><span class="p">[</span><span class="ss">:email</span><span class="p">]}</span> <span class="n">type</span><span class="o">=</span><span class="s2">"email"</span> <span class="n">label</span><span class="o">=</span><span class="s2">"Email"</span> <span class="n">required</span> <span class="o">/&gt;</span>
    <span class="o">&lt;.</span><span class="n">input</span> <span class="n">field</span><span class="o">=</span><span class="p">{</span><span class="nv">@form</span><span class="p">[</span><span class="ss">:password</span><span class="p">]}</span> <span class="n">type</span><span class="o">=</span><span class="s2">"password"</span> <span class="n">label</span><span class="o">=</span><span class="s2">"Password"</span> <span class="n">required</span> <span class="o">/&gt;</span>
    <span class="o">&lt;.</span><span class="n">input</span> <span class="n">field</span><span class="o">=</span><span class="p">{</span><span class="nv">@form</span><span class="p">[</span><span class="ss">:nickname</span><span class="p">]}</span> <span class="n">label</span><span class="o">=</span><span class="s2">"Nickname"</span> <span class="n">required</span> <span class="o">/&gt;</span>
    <span class="o">...</span>
  <span class="o">&lt;/.</span><span class="n">simple_form</span><span class="o">&gt;</span>
<span class="o">...</span>
</code></pre></div></div>
<center><img src="assets\img\posts\nickname_form.png" width="500" /></center>
<p><br /></p>
<center><strong>users table</strong></center>
<center><img src="assets\img\posts\nickname_db.png" width="700" /></center>
<p><br /></p>]]></content><author><name>Yong gon Yun</name></author><category term="phoenix" /><category term="liveview" /><category term="migration" /><category term="table_항목_추가" /><category term="schema" /><category term="changeset/2" /><category term="applciation_개발1" /><summary type="html"><![CDATA[계정 정보에서 nickname 정보가 필요함에 따라, 이를 기존에 생성한 users table 에 추가하고, 계정 생성 시, nickname 을 입력하도록 함.]]></summary></entry><entry><title type="html">(App 개발 02) root.html.heex 과 app.html.heex 에 대해</title><link href="http://localhost:4000/root-and-app.html" rel="alternate" type="text/html" title="(App 개발 02) root.html.heex 과 app.html.heex 에 대해" /><published>2024-01-25T08:32:20+09:00</published><updated>2024-01-25T08:32:20+09:00</updated><id>http://localhost:4000/root-and-app</id><content type="html" xml:base="http://localhost:4000/root-and-app.html"><![CDATA[<p>현재 Phoenix LiveView application 작업을 진행하면서, 아래와 같이 page 최상단에 메뉴바를 띄우고자 한다.</p>

<center><img src="assets\img\posts\header.png" width="500" /></center>

<p>다만 <code class="language-plaintext highlighter-rouge">/</code> 과 <code class="language-plaintext highlighter-rouge">/games</code> url 에 대해서는 메뉴바가 있고, <code class="language-plaintext highlighter-rouge">/games/:id</code> url 에 대해서는 메뉴바가 없도록 구성하고 싶다. 해당 작업을 진행하면 <code class="language-plaintext highlighter-rouge">root.html.heex</code> 와 <code class="language-plaintext highlighter-rouge">app.html.heex</code> 파일을 수정하고, 수정된 파일을 어떻게하면 적절하게 이용할 수 있을지 위에서의 고민을 토대로 각 파일에 대해 알아본다.</p>

<h3 id="roothtmlheex-역할">root.html.heex 역할</h3>

<p>이 파일은 전체 Phoenix 애플리케이션의 최상위 레이아웃을 정의하며, 다른 템플릿들은 이 안에 삽입되어 최종 HTML 문서를 형성한다. 일반적으로 전체 애플리케이션에 걸쳐 공통적으로 사용되는 HTML 요소를 포함한다.(<code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> 태그 내의 meta data, stylesheet link, javascript 파일 등)</p>

<p><code class="language-plaintext highlighter-rouge">router.ex</code> 에서 <code class="language-plaintext highlighter-rouge">pipeline :browser</code> 를 통해 주입되며, 모든 정적 html와 LiveView는 이 파일의 구조 안에서 렌더링된다.</p>

<p>만약 <code class="language-plaintext highlighter-rouge">root1.html.heex</code> 파일에서 해당 메뉴바를 구현하고, <code class="language-plaintext highlighter-rouge">root2.html.heex</code> 에는 메뉴바를 구현하지 않고, 이렇게 두 개의 파일을 만들어서 <code class="language-plaintext highlighter-rouge">pipeline :browser1</code> , <code class="language-plaintext highlighter-rouge">pipeline :browser2</code> 를 각각 정의하여 이를 각각 필요한 url 에 맞게 사용하고자 시도하였으나, 이런 경우, 동일한 매개변수를 가지는 <code class="language-plaintext highlighter-rouge">live_session</code> macro 가 두번 정의되어야 한다. 이는 다음의 에러가 발생시킨다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">**</span> <span class="o">(</span>RuntimeError<span class="o">)</span> attempting to redefine live_session :require_authenticated_user.
live_session routes must be declared <span class="k">in </span>a single named block.
</code></pre></div></div>

<p>따라서 동일한 <code class="language-plaintext highlighter-rouge">scope</code> macro 에서 정의되어야 하는 url page 에 대해서는 동일한 <code class="language-plaintext highlighter-rouge">root.html.heex</code> 가 적용되어야 한다.</p>

<h3 id="apphtmlheex-역할">app.html.heex 역할</h3>

<p><code class="language-plaintext highlighter-rouge">app.html.heex</code>는 <code class="language-plaintext highlighter-rouge">root.html.heex</code> 내에 삽입되는, 특정 부분의 레이아웃을 정의하는 파일로, 주로 애플리케이션의 주요 컨텐츠를 포함하며, 특정 페이지나 섹션에 대한 레이아웃을 정의하는 데 사용된다. 예를 들어, header, footer, sidebar 등 페이지의 주요 부분을 구성할 수 있으며, 페이지 별로 다른 내용을 표시하는데 사용된다.</p>

<p>따라서 url 별로 header 적용 여부를 다르게 하고 싶다면 <code class="language-plaintext highlighter-rouge">app.html.heex</code> 파일을 각각 만들어서 각 page mdoule 에서 다른 template 을 가져오면 된다.</p>

<h3 id="구현">구현</h3>

<p>기존에 작성한 header 는 <code class="language-plaintext highlighter-rouge">root.html.heex</code> 에 있었다. 그래서 해당 code 를 <code class="language-plaintext highlighter-rouge">app.html.heex</code> 로 이동시키고, header 가 없은 <code class="language-plaintext highlighter-rouge">app_no_header.html.heex</code> 를 추가 생성하였다.</p>

<p>그리고 <code class="language-plaintext highlighter-rouge">app_no_header.html.heex</code> 을 liveview 에서 가져올 수 있도록 <code class="language-plaintext highlighter-rouge">my_pjt_web.ex</code> 에 callback 함수를 추가해주었다.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">MyPjt1Web</span> <span class="k">do</span>
  <span class="o">...</span>
  <span class="c1"># 기존 app.html.heex 를 layout 로 사용하는 함수</span>
  <span class="k">def</span> <span class="n">live_view</span> <span class="k">do</span>
    <span class="kn">quote</span> <span class="k">do</span>
      <span class="kn">use</span> <span class="no">Phoenix</span><span class="o">.</span><span class="no">LiveView</span><span class="p">,</span>
        <span class="ss">layout:</span> <span class="p">{</span><span class="no">MyPjt1Web</span><span class="o">.</span><span class="no">Layouts</span><span class="p">,</span> <span class="ss">:app</span><span class="p">}</span>

      <span class="kn">unquote</span><span class="p">(</span><span class="n">html_helpers</span><span class="p">())</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># 추가된 함수. app_no_header.html.heex 를 layout 로 사용</span>
  <span class="k">def</span> <span class="n">live_view_no_header</span> <span class="k">do</span>
    <span class="kn">quote</span> <span class="k">do</span>
      <span class="kn">use</span> <span class="no">Phoenix</span><span class="o">.</span><span class="no">LiveView</span><span class="p">,</span>
        <span class="ss">layout:</span> <span class="p">{</span><span class="no">MyPjt1Web</span><span class="o">.</span><span class="no">Layouts</span><span class="p">,</span> <span class="ss">:app_no_header</span><span class="p">}</span>

      <span class="kn">unquote</span><span class="p">(</span><span class="n">html_helpers</span><span class="p">())</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>다음으로 각 url 대한 module 에서 <code class="language-plaintext highlighter-rouge">use</code> macro 를 사용하여 앞에서 정의한 callback 을 맞게 가져옴</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">MyPjt1Web</span><span class="o">.</span><span class="no">GameLive</span><span class="o">.</span><span class="no">Index</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">MyPjt1Web</span><span class="p">,</span> <span class="ss">:live_view</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">MyPjt1Web</span><span class="o">.</span><span class="no">GameLive</span><span class="o">.</span><span class="no">Show</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">MyPjt1Web</span><span class="p">,</span> <span class="ss">:live_view_no_header</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>마지막으로 남은 것은 <code class="language-plaintext highlighter-rouge">get "/", PageController, :home</code> 에서 가져오는 module 만 처리해주면 된다. 그런데, 분명 <code class="language-plaintext highlighter-rouge">my_pjt1_web</code>module <code class="language-plaintext highlighter-rouge">controller</code> callback 에 <code class="language-plaintext highlighter-rouge">layout: {MyPjt1Web.Layouts, :app}</code> 이 정의되어 있음에도 불구하고, application 실행시 <code class="language-plaintext highlighter-rouge">app.html.heex</code> 의 header 가 표시되어지지 않았다. 그래서 어쩔수 없이 <code class="language-plaintext highlighter-rouge">home.html.heex</code> 에 동일한 header 를 추가하여 
자체적으로 header 를 rendering 하도록 구현하였다.</p>]]></content><author><name>Yong gon Yun</name></author><category term="phoenix" /><category term="liveview" /><category term="root.html.heex" /><category term="app.html.heex" /><category term="applciation_개발1" /><summary type="html"><![CDATA[Phoenix LiveView 에서 기본 설정 및 공통으로 rendering 될 요소를 넣을 수 있는 root.html.heex 과 app.html.heex 에 대해 각각의 용도를 확인하고 이를 수정 사용하는 작업 방법 확인함]]></summary></entry><entry><title type="html">(App 개발 01) Phoenix LiveView 에서 사용자 정의 JS code 사용 방법</title><link href="http://localhost:4000/custom-js-phoenix.html" rel="alternate" type="text/html" title="(App 개발 01) Phoenix LiveView 에서 사용자 정의 JS code 사용 방법" /><published>2024-01-24T08:32:20+09:00</published><updated>2024-01-24T08:32:20+09:00</updated><id>http://localhost:4000/custom-js-phoenix</id><content type="html" xml:base="http://localhost:4000/custom-js-phoenix.html"><![CDATA[<p>Phoenix LiveView 를 사용하여 아래와 같이 버튼 클릭시 번갈아가며 버튼의 배경색과 내용이 바뀌는 toggle button 을 사용하고자 하였다. 그런데 기존의 Phoenix LiveView 제공 html tag 및 css 로 이를 생성할 수 없었으며, 따라서 자체적으로 JS 를 작성하여 기존 button 에 적용해야 하는 상황이다. 해당 과정에서 필요한 설정 및 <code>render/1</code>에 적용하기까지의 과정을 정리하고자 한다. </p>

<center>
  <img src="assets\img\posts\toggle_button.png" width="300" />
</center>

<h3>1. Node module 설치 및 관련 package 설치</h3>

<p>(1) <code>package.json</code> 생성</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>assets
npm init
</code></pre></div></div>

<p>만약 <code>package.json</code> 파일이 없다면, 새로 생성해야 한다. 이를 위해 <code>npm init</code> 명령어를 실행하여 새로운 <code>package.json</code> 파일을 생성할 수 있다. 이 과정에서 프로젝트에 대한 기본 정보를 입력해야 한다.</p>

<p>(2) <code>npm init</code> 작업을 위한 기본 정보 입력
</p>
<p><code>npm init</code> 을 실행하면 프로젝트 이름, 버전, 설명, 진입점(주로 index.js), 테스트 명령어, 저장소, 키워드, 라이선스 등을 입력을 요청 받는다. 입력을 완료하면 <code>package.json</code> 이 생성되며, 여기서 해당 내용 등을 수정, 추가할 수 있다. 해당 script 은 다음과 같다.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"***"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1.0.0"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"phoenix liveview project"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"main"</span><span class="p">:</span><span class="w"> </span><span class="s2">"tailwind.config.js"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"scripts"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"test"</span><span class="p">:</span><span class="w"> </span><span class="s2">"echo </span><span class="se">\"</span><span class="s2">Error: no test specified</span><span class="se">\"</span><span class="s2"> &amp;&amp; exit 1"</span><span class="p">,</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"author"</span><span class="p">:</span><span class="w"> </span><span class="s2">"***"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"license"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ISC"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"repository"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"git"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"git+https://github.com/***/***.git"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"keywords"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="s2">"phoenix"</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"bugs"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"https://github.com/***/***/issues"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"homepage"</span><span class="p">:</span><span class="w"> </span><span class="s2">"https://github.com/***/***#readme"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>(3) Webpack 설치 전 설정 추가</p>

<p><code>package.json</code> <code>scripts</code> 섹션에 <code>deploy</code> 스크립트를 추가해야 웹팩을 사용하여 build 할 수 있다. script 섹션 설정을 포함한  다음 코드를 <code>package.json</code> 에 추가한다.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="nl">"scripts"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="err">...</span><span class="p">,</span><span class="w">
    </span><span class="nl">"deploy"</span><span class="p">:</span><span class="w"> </span><span class="s2">"webpack --mode production"</span><span class="w"> 
  </span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Webpack 을 설치할 때, 진입점이 필요하다. <code>assets/src</code> 위치에 <code>index.js</code> 파일을 생성하고 프로젝트에 필요한 기본 JavaScript 코드나 모듈 가져오기(import)를 추가한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 예시: assets/src/index.js
import "phoenix_html";
// 다른 필요한 JavaScript 코드나 모듈 import
</code></pre></div></div>

<p>(4) Webpack 설정 config 파일 추가</p>

<p><code>assets</code> 디렉토리 내에 <code>webpack.config.js</code>을 생성하고 진입점(entry point)으로 <code>index.js</code> 을 설정해준다. 그 밖에 output, loader 등을 포함하여 다음과 같이 생성한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const path = require('path');

module.exports = {
  // 진입점 설정
  entry: './js/app.js', // 이 경로는 프로젝트에 맞게 조정해야 합니다

  // 출력 설정
  output: {
    path: path.resolve(__dirname, '../priv/static/assets'), // 출력 디렉토리
    filename: 'app.js', // 출력 파일명
  },

  // 모듈 설정
  module: {
    rules: [
      {
        test: /\.js$/, // .js 파일에 대한 처리
        exclude: /node_modules/, // node_modules 디렉토리 제외
        use: {
          loader: 'babel-loader', // Babel 로더 사용
          options: {
            presets: ['@babel/preset-env'], // Babel 프리셋 설정
          },
        },
      },
      // 추가적인 로더 설정(예: CSS, 이미지 파일 등)
    ],
  },
};
</code></pre></div></div>

<h3>2. Node 모듈 설치 및 Node.js 의존성 설정</h3>

<p>(1) Node 모듈 설치</p>
<p><code>assets</code> 디렉토리로 이동하여 <code>npm install</code>을 실행한다. 이 명령어는 <code>package.json</code>에 정의된 모든 Node 의존성을 설치한다. Phoenix 프로젝트의 경우,<code>phoenix</code>, <code>phoenix_html</code>, <code>phoenix_live_view</code> 패키지들은 자동으로 <code>package.json</code>에 추가되어 있어야 한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>assets
npm <span class="nb">install</span>
</code></pre></div></div>

<p>(2) Node.js 필수 Package 설치</p>

<p>- Webpack<br /> assets (HTML, CSS, JavaScript 파일, 이미지, 폰트 등 웹 애플리케이션을 구성하는 모든 정적 파일들) 을 bundling (여러 개의 파일을 하나 또는 소수의 파일로 결합하는 과정. 이를 통해 네트워크 요청 최소화, application 최적화, 의존성 관리의 이점이 있음) 하기 위해 필요</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install </span>webpack webpack-cli <span class="nt">--save-dev</span>
</code></pre></div></div>

<p>- Babel<br /> JavaScript 코드를 변환하기 위한 컴파일러. ES6 이상의 코드를 이전 버전의 JavaScript로 변환하는데 사용.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install</span> @babel/core @babel/preset-env babel-loader <span class="nt">--save-dev</span>
</code></pre></div></div>

<p>- CSS 관련 package<br />CSS를 처리하기 위해 필요한 패키지들</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install </span>css-loader style-loader mini-css-extract-plugin <span class="nt">--save-dev</span>
</code></pre></div></div>

<p>- Tailwind CSS</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install </span>tailwindcss postcss autoprefixer <span class="nt">--save-dev</span>
</code></pre></div></div>

<p>(3) Node.js Package 중 Phoenix LiveView 관련 설치</p>

<p><code>phoenix</code>, <code>phoenix_live_view</code>, <code>phoenix_html</code> package 를 설치하기 전, <code>assets/js/app.js</code> 다음 코드가 없다면 추가해준다.(phoenix_live_view 0.20.1 기준 기본적으로 추가되어 있음.)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import "phoenix_html";
import { Socket } from "phoenix";
import { LiveSocket } from "phoenix_live_view";
</code></pre></div></div>

<p><code>assets</code> 디렉토리에서 해당 package 를 추가해준다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install --save phoenix phoenix_html phoenix_live_view
</code></pre></div></div>
<p>제대로 설치되었다면, 앞에서 설치한 Node.js Package 디렉토리가 <code>assets/node_modules</code>에 생성된다.</p>

<h3>3. JavaScript 파일 작성</h3>
<p>앞의 과정에서 사용자 정의 JavaScript 를 사용할 수 있도록 관련 설정을 완료하였으므로, 이제 프로젝트의 <code>assets/js</code> 디렉토리 안에 사용자 정의 JavaScript 파일을 생성 (ex. <code>assets/js/custom.js</code>) 한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export function toggleButton(btn) {
  btn.classList.toggle('bg-blue-500');
  btn.classList.toggle('bg-gray-600');

  if (btn.innerText === 'READY !!') {
    btn.innerText = 'WAIT  ......  ';
  } else {
    btn.innerText = 'READY !!';
  }
}
</code></pre></div></div>

<h3>4. Phoenix 프로젝트에 JavaScript 통합</h3>
<p>(1) <code>app.js</code>에서 사용자 정의 <code>custom.js</code> 가져오기.</p>

<p><code>assets/js/app.js</code> 파일을 열고, 만들어진 <code>custom.js</code> 을 가져올 수 있도록 import 해준다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// assets/js/app.js
import { toggleButton } from "./custom";
window.toggleButton = toggleButton;
</code></pre></div></div>

<p>이렇게 하면 <code>customFunction</code>을 전역 변수로 설정하여, HTML에서 접근할 수 있게 된다.</p>

<p>(2) Webpack build</p>
<p>지금까지의 변경사항을 적용하기 위해 <code>assets</code> 디렉토리에서 <code>npm run deploy</code>를 실행하여 JavaScript 파일을 빌드한다.</p>

<h3>5. LiveView에서 JavaScript 사용</h3>
<p>(1) LiveView 템플릿에 스크립트 적용</p>
<p>LiveView의 <code>render/1</code> 함수에서 해당 JavaScript 함수를 사용하는 HTML을 반환</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">render</span><span class="p">(</span><span class="n">assigns</span><span class="p">)</span> <span class="k">do</span>
  <span class="sx">~H""</span><span class="s2">"
  ... ...
    &lt;button 
      type="</span><span class="n">button</span><span class="s2">" 
      onclick="</span><span class="n">window</span><span class="o">.</span><span class="n">toggleButton</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="s2">"
      class="</span><span class="n">text</span><span class="o">-</span><span class="n">white</span> <span class="n">bg</span><span class="o">-</span><span class="n">blue</span><span class="o">-</span><span class="mi">500</span> <span class="n">font</span><span class="o">-</span><span class="n">medium</span> <span class="n">rounded</span><span class="o">-</span><span class="n">lg</span> <span class="n">text</span><span class="o">-</span><span class="n">sm</span> <span class="n">px</span><span class="o">-</span><span class="mi">5</span> <span class="n">py</span><span class="o">-</span><span class="mf">2.5</span> <span class="n">me</span><span class="o">-</span><span class="mi">2</span> <span class="n">mb</span><span class="o">-</span><span class="mi">2</span><span class="s2">"&gt;
        READY !!
    &lt;/button&gt;    
  ... ...  
  """</span>
<span class="k">end</span>
</code></pre></div></div>

<h3>결론</h3>
<center>
  <img src="assets\img\posts\toggle_button.png" width="300" />
</center>

<p>위 작업이 정상적으로 완료되었다면 의도한대로 사용자 정의 toggle button 이 동작하는 것을 확인 할 수 있다. </p>]]></content><author><name>Yong gon Yun</name></author><category term="phoenix" /><category term="liveview" /><category term="custom javascript" /><category term="node.js" /><category term="applciation_개발1" /><summary type="html"><![CDATA[Phoenix LiveView 에서 사용자 정의 JS code 구현 및 적용을 위한 Node.js 설정 및 render/1 에 적용하는 과정]]></summary></entry></feed>