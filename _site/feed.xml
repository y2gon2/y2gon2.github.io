<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-01-25T14:12:04+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Gon’s Tech Jurnal</title><subtitle>The Record of Backend Development</subtitle><author><name>Yong gon Yun</name></author><entry><title type="html">root.html.heex 과 app.html.heex 에 대해</title><link href="http://localhost:4000/root-and-app.html" rel="alternate" type="text/html" title="root.html.heex 과 app.html.heex 에 대해" /><published>2024-01-25T08:32:20+09:00</published><updated>2024-01-25T08:32:20+09:00</updated><id>http://localhost:4000/root-and-app</id><content type="html" xml:base="http://localhost:4000/root-and-app.html"><![CDATA[<p>현재 Phoenix LiveView application 작업을 진행하면서, 아래와 같이 page 최상단에 메뉴바를 띄우고자 한다.</p>

<center><img src="assets\img\posts\header.png" width="500" /></center>

<p>다만 <code class="language-plaintext highlighter-rouge">/</code> 과 <code class="language-plaintext highlighter-rouge">/games</code> url 에 대해서는 메뉴바가 있고, <code class="language-plaintext highlighter-rouge">/games/:id</code> url 에 대해서는 메뉴바가 없도록 구성하고 싶다. 해당 작업을 진행하면 <code class="language-plaintext highlighter-rouge">root.html.heex</code> 와 <code class="language-plaintext highlighter-rouge">app.html.heex</code> 파일을 수정하고, 수정된 파일을 어떻게하면 적절하게 이용할 수 있을지 위에서의 고민을 토대로 각 파일에 대해 알아본다.</p>

<h3 id="roothtmlheex-역할">root.html.heex 역할</h3>

<p>이 파일은 전체 Phoenix 애플리케이션의 최상위 레이아웃을 정의하며, 다른 템플릿들은 이 안에 삽입되어 최종 HTML 문서를 형성한다. 일반적으로 전체 애플리케이션에 걸쳐 공통적으로 사용되는 HTML 요소를 포함한다.(<code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> 태그 내의 meta data, stylesheet link, javascript 파일 등)</p>

<p><code class="language-plaintext highlighter-rouge">router.ex</code> 에서 <code class="language-plaintext highlighter-rouge">pipeline :browser</code> 를 통해 주입되며, 모든 정적 html와 LiveView는 이 파일의 구조 안에서 렌더링된다.</p>

<p>만약 <code class="language-plaintext highlighter-rouge">root1.html.heex</code> 파일에서 해당 메뉴바를 구현하고, <code class="language-plaintext highlighter-rouge">root2.html.heex</code> 에는 메뉴바를 구현하지 않고, 이렇게 두 개의 파일을 만들어서 <code class="language-plaintext highlighter-rouge">pipeline :browser1</code> , <code class="language-plaintext highlighter-rouge">pipeline :browser2</code> 를 각각 정의하여 이를 각각 필요한 url 에 맞게 사용하고자 시도하였으나, 이런 경우, 동일한 매개변수를 가지는 <code class="language-plaintext highlighter-rouge">live_session</code> macro 가 두번 정의되어야 한다. 이는 다음의 에러가 발생시킨다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">**</span> <span class="o">(</span>RuntimeError<span class="o">)</span> attempting to redefine live_session :require_authenticated_user.
live_session routes must be declared <span class="k">in </span>a single named block.
</code></pre></div></div>

<p>따라서 동일한 <code class="language-plaintext highlighter-rouge">scope</code> macro 에서 정의되어야 하는 url page 에 대해서는 동일한 <code class="language-plaintext highlighter-rouge">root.html.heex</code> 가 적용되어야 한다.</p>

<h3 id="apphtmlheex-역할">app.html.heex 역할</h3>

<p><code class="language-plaintext highlighter-rouge">app.html.heex</code>는 <code class="language-plaintext highlighter-rouge">root.html.heex</code> 내에 삽입되는, 특정 부분의 레이아웃을 정의하는 파일로, 주로 애플리케이션의 주요 컨텐츠를 포함하며, 특정 페이지나 섹션에 대한 레이아웃을 정의하는 데 사용된다. 예를 들어, header, footer, sidebar 등 페이지의 주요 부분을 구성할 수 있으며, 페이지 별로 다른 내용을 표시하는데 사용된다.</p>

<p>따라서 url 별로 header 적용 여부를 다르게 하고 싶다면 <code class="language-plaintext highlighter-rouge">app.html.heex</code> 파일을 각각 만들어서 각 page mdoule 에서 다른 template 을 가져오면 된다.</p>

<h3 id="구현">구현</h3>

<p>기존에 작성한 header 는 <code class="language-plaintext highlighter-rouge">root.html.heex</code> 에 있었다. 그래서 해당 code 를 <code class="language-plaintext highlighter-rouge">app.html.heex</code> 로 이동시키고, header 가 없은 <code class="language-plaintext highlighter-rouge">app_no_header.html.heex</code> 를 추가 생성하였다.</p>

<p>그리고 <code class="language-plaintext highlighter-rouge">app_no_header.html.heex</code> 을 liveview 에서 가져올 수 있도록 <code class="language-plaintext highlighter-rouge">my_pjt_web.ex</code> 에 callback 함수를 추가해주었다.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">MyPjt1Web</span> <span class="k">do</span>
  <span class="o">...</span>
  <span class="c1"># 기존 app.html.heex 를 layout 로 사용하는 함수</span>
  <span class="k">def</span> <span class="n">live_view</span> <span class="k">do</span>
    <span class="kn">quote</span> <span class="k">do</span>
      <span class="kn">use</span> <span class="no">Phoenix</span><span class="o">.</span><span class="no">LiveView</span><span class="p">,</span>
        <span class="ss">layout:</span> <span class="p">{</span><span class="no">MyPjt1Web</span><span class="o">.</span><span class="no">Layouts</span><span class="p">,</span> <span class="ss">:app</span><span class="p">}</span>

      <span class="kn">unquote</span><span class="p">(</span><span class="n">html_helpers</span><span class="p">())</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># 추가된 함수. app_no_header.html.heex 를 layout 로 사용</span>
  <span class="k">def</span> <span class="n">live_view_no_header</span> <span class="k">do</span>
    <span class="kn">quote</span> <span class="k">do</span>
      <span class="kn">use</span> <span class="no">Phoenix</span><span class="o">.</span><span class="no">LiveView</span><span class="p">,</span>
        <span class="ss">layout:</span> <span class="p">{</span><span class="no">MyPjt1Web</span><span class="o">.</span><span class="no">Layouts</span><span class="p">,</span> <span class="ss">:app_no_header</span><span class="p">}</span>

      <span class="kn">unquote</span><span class="p">(</span><span class="n">html_helpers</span><span class="p">())</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>다음으로 각 url 대한 module 에서 <code class="language-plaintext highlighter-rouge">use</code> macro 를 사용하여 앞에서 정의한 callback 을 맞게 가져옴</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">MyPjt1Web</span><span class="o">.</span><span class="no">GameLive</span><span class="o">.</span><span class="no">Index</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">MyPjt1Web</span><span class="p">,</span> <span class="ss">:live_view</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">MyPjt1Web</span><span class="o">.</span><span class="no">GameLive</span><span class="o">.</span><span class="no">Show</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">MyPjt1Web</span><span class="p">,</span> <span class="ss">:live_view_no_header</span>
  <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>마지막으로 남은 것은 <code class="language-plaintext highlighter-rouge">get "/", PageController, :home</code> 에서 가져오는 module 만 처리해주면 된다. 그런데, 분명 <code class="language-plaintext highlighter-rouge">my_pjt1_web</code>module <code class="language-plaintext highlighter-rouge">controller</code> callback 에 <code class="language-plaintext highlighter-rouge">layout: {MyPjt1Web.Layouts, :app}</code> 이 정의되어 있음에도 불구하고, application 실행시 <code class="language-plaintext highlighter-rouge">app.html.heex</code> 의 header 가 표시되어지지 않았다. 그래서 어쩔수 없이 <code class="language-plaintext highlighter-rouge">home.html.heex</code> 에 동일한 header 를 추가하여 
자체적으로 header 를 rendering 하도록 구현하였다.</p>]]></content><author><name>Yong gon Yun</name></author><category term="phoenix" /><category term="liveview" /><category term="root.html.heex" /><category term="app.html.heex" /><summary type="html"><![CDATA[Phoenix LiveView 에서 기본 설정 및 공통으로 rendering 될 요소를 넣을 수 있는 root.html.heex 과 app.html.heex 에 대해 각각의 용도를 확인하고 이를 수정 사용하는 작업 방법 확인함]]></summary></entry><entry><title type="html">Phoenix LiveView 에서 사용자 정의 JS code 사용 방법</title><link href="http://localhost:4000/custom-js-phoenix.html" rel="alternate" type="text/html" title="Phoenix LiveView 에서 사용자 정의 JS code 사용 방법" /><published>2024-01-24T08:32:20+09:00</published><updated>2024-01-24T08:32:20+09:00</updated><id>http://localhost:4000/custom-js-phoenix</id><content type="html" xml:base="http://localhost:4000/custom-js-phoenix.html"><![CDATA[<p>Phoenix LiveView 를 사용하여 아래와 같이 버튼 클릭시 번갈아가며 버튼의 배경색과 내용이 바뀌는 toggle button 을 사용하고자 하였다. 그런데 기존의 Phoenix LiveView 제공 html tag 및 css 로 이를 생성할 수 없었으며, 따라서 자체적으로 JS 를 작성하여 기존 button 에 적용해야 하는 상황이다. 해당 과정에서 필요한 설정 및 <code>render/1</code>에 적용하기까지의 과정을 정리하고자 한다. </p>

<center>
  <img src="assets\img\posts\toggle_button.png" width="300" />
</center>

<h3>1. Node module 설치 및 관련 package 설치</h3>

<p>(1) <code>package.json</code> 생성</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>assets
npm init
</code></pre></div></div>

<p>만약 <code>package.json</code> 파일이 없다면, 새로 생성해야 한다. 이를 위해 <code>npm init</code> 명령어를 실행하여 새로운 <code>package.json</code> 파일을 생성할 수 있다. 이 과정에서 프로젝트에 대한 기본 정보를 입력해야 한다.</p>

<p>(2) <code>npm init</code> 작업을 위한 기본 정보 입력
</p>
<p><code>npm init</code> 을 실행하면 프로젝트 이름, 버전, 설명, 진입점(주로 index.js), 테스트 명령어, 저장소, 키워드, 라이선스 등을 입력을 요청 받는다. 입력을 완료하면 <code>package.json</code> 이 생성되며, 여기서 해당 내용 등을 수정, 추가할 수 있다. 해당 script 은 다음과 같다.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"***"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1.0.0"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"phoenix liveview project"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"main"</span><span class="p">:</span><span class="w"> </span><span class="s2">"tailwind.config.js"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"scripts"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"test"</span><span class="p">:</span><span class="w"> </span><span class="s2">"echo </span><span class="se">\"</span><span class="s2">Error: no test specified</span><span class="se">\"</span><span class="s2"> &amp;&amp; exit 1"</span><span class="p">,</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"author"</span><span class="p">:</span><span class="w"> </span><span class="s2">"***"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"license"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ISC"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"repository"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"git"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"git+https://github.com/***/***.git"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"keywords"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="s2">"phoenix"</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"bugs"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"https://github.com/***/***/issues"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"homepage"</span><span class="p">:</span><span class="w"> </span><span class="s2">"https://github.com/***/***#readme"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>(3) Webpack 설치 전 설정 추가</p>

<p><code>package.json</code> <code>scripts</code> 섹션에 <code>deploy</code> 스크립트를 추가해야 웹팩을 사용하여 build 할 수 있다. script 섹션 설정을 포함한  다음 코드를 <code>package.json</code> 에 추가한다.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="nl">"scripts"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="err">...</span><span class="p">,</span><span class="w">
    </span><span class="nl">"deploy"</span><span class="p">:</span><span class="w"> </span><span class="s2">"webpack --mode production"</span><span class="w"> 
  </span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Webpack 을 설치할 때, 진입점이 필요하다. <code>assets/src</code> 위치에 <code>index.js</code> 파일을 생성하고 프로젝트에 필요한 기본 JavaScript 코드나 모듈 가져오기(import)를 추가한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 예시: assets/src/index.js
import "phoenix_html";
// 다른 필요한 JavaScript 코드나 모듈 import
</code></pre></div></div>

<p>(4) Webpack 설정 config 파일 추가</p>

<p><code>assets</code> 디렉토리 내에 <code>webpack.config.js</code>을 생성하고 진입점(entry point)으로 <code>index.js</code> 을 설정해준다. 그 밖에 output, loader 등을 포함하여 다음과 같이 생성한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const path = require('path');

module.exports = {
  // 진입점 설정
  entry: './js/app.js', // 이 경로는 프로젝트에 맞게 조정해야 합니다

  // 출력 설정
  output: {
    path: path.resolve(__dirname, '../priv/static/assets'), // 출력 디렉토리
    filename: 'app.js', // 출력 파일명
  },

  // 모듈 설정
  module: {
    rules: [
      {
        test: /\.js$/, // .js 파일에 대한 처리
        exclude: /node_modules/, // node_modules 디렉토리 제외
        use: {
          loader: 'babel-loader', // Babel 로더 사용
          options: {
            presets: ['@babel/preset-env'], // Babel 프리셋 설정
          },
        },
      },
      // 추가적인 로더 설정(예: CSS, 이미지 파일 등)
    ],
  },
};
</code></pre></div></div>

<h3>2. Node 모듈 설치 및 Node.js 의존성 설정</h3>

<p>(1) Node 모듈 설치</p>
<p><code>assets</code> 디렉토리로 이동하여 <code>npm install</code>을 실행한다. 이 명령어는 <code>package.json</code>에 정의된 모든 Node 의존성을 설치한다. Phoenix 프로젝트의 경우,<code>phoenix</code>, <code>phoenix_html</code>, <code>phoenix_live_view</code> 패키지들은 자동으로 <code>package.json</code>에 추가되어 있어야 한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>assets
npm <span class="nb">install</span>
</code></pre></div></div>

<p>(2) Node.js 필수 Package 설치</p>

<p>- Webpack<br /> assets (HTML, CSS, JavaScript 파일, 이미지, 폰트 등 웹 애플리케이션을 구성하는 모든 정적 파일들) 을 bundling (여러 개의 파일을 하나 또는 소수의 파일로 결합하는 과정. 이를 통해 네트워크 요청 최소화, application 최적화, 의존성 관리의 이점이 있음) 하기 위해 필요</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install </span>webpack webpack-cli <span class="nt">--save-dev</span>
</code></pre></div></div>

<p>- Babel<br /> JavaScript 코드를 변환하기 위한 컴파일러. ES6 이상의 코드를 이전 버전의 JavaScript로 변환하는데 사용.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install</span> @babel/core @babel/preset-env babel-loader <span class="nt">--save-dev</span>
</code></pre></div></div>

<p>- CSS 관련 package<br />CSS를 처리하기 위해 필요한 패키지들</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install </span>css-loader style-loader mini-css-extract-plugin <span class="nt">--save-dev</span>
</code></pre></div></div>

<p>- Tailwind CSS</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install </span>tailwindcss postcss autoprefixer <span class="nt">--save-dev</span>
</code></pre></div></div>

<p>(3) Node.js Package 중 Phoenix LiveView 관련 설치</p>

<p><code>phoenix</code>, <code>phoenix_live_view</code>, <code>phoenix_html</code> package 를 설치하기 전, <code>assets/js/app.js</code> 다음 코드가 없다면 추가해준다.(phoenix_live_view 0.20.1 기준 기본적으로 추가되어 있음.)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import "phoenix_html";
import { Socket } from "phoenix";
import { LiveSocket } from "phoenix_live_view";
</code></pre></div></div>

<p><code>assets</code> 디렉토리에서 해당 package 를 추가해준다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install --save phoenix phoenix_html phoenix_live_view
</code></pre></div></div>
<p>제대로 설치되었다면, 앞에서 설치한 Node.js Package 디렉토리가 <code>assets/node_modules</code>에 생성된다.</p>

<h3>3. JavaScript 파일 작성</h3>
<p>앞의 과정에서 사용자 정의 JavaScript 를 사용할 수 있도록 관련 설정을 완료하였으므로, 이제 프로젝트의 <code>assets/js</code> 디렉토리 안에 사용자 정의 JavaScript 파일을 생성 (ex. <code>assets/js/custom.js</code>) 한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export function toggleButton(btn) {
  btn.classList.toggle('bg-blue-500');
  btn.classList.toggle('bg-gray-600');

  if (btn.innerText === 'READY !!') {
    btn.innerText = 'WAIT  ......  ';
  } else {
    btn.innerText = 'READY !!';
  }
}
</code></pre></div></div>

<h3>4. Phoenix 프로젝트에 JavaScript 통합</h3>
<p>(1) <code>app.js</code>에서 사용자 정의 <code>custom.js</code> 가져오기.</p>

<p><code>assets/js/app.js</code> 파일을 열고, 만들어진 <code>custom.js</code> 을 가져올 수 있도록 import 해준다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// assets/js/app.js
import { toggleButton } from "./custom";
window.toggleButton = toggleButton;
</code></pre></div></div>

<p>이렇게 하면 <code>customFunction</code>을 전역 변수로 설정하여, HTML에서 접근할 수 있게 된다.</p>

<p>(2) Webpack build</p>
<p>지금까지의 변경사항을 적용하기 위해 <code>assets</code> 디렉토리에서 <code>npm run deploy</code>를 실행하여 JavaScript 파일을 빌드한다.</p>

<h3>5. LiveView에서 JavaScript 사용</h3>
<p>(1) LiveView 템플릿에 스크립트 적용</p>
<p>LiveView의 <code>render/1</code> 함수에서 해당 JavaScript 함수를 사용하는 HTML을 반환</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">render</span><span class="p">(</span><span class="n">assigns</span><span class="p">)</span> <span class="k">do</span>
  <span class="sx">~H""</span><span class="s2">"
  ... ...
    &lt;button 
      type="</span><span class="n">button</span><span class="s2">" 
      onclick="</span><span class="n">window</span><span class="o">.</span><span class="n">toggleButton</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="s2">"
      class="</span><span class="n">text</span><span class="o">-</span><span class="n">white</span> <span class="n">bg</span><span class="o">-</span><span class="n">blue</span><span class="o">-</span><span class="mi">500</span> <span class="n">font</span><span class="o">-</span><span class="n">medium</span> <span class="n">rounded</span><span class="o">-</span><span class="n">lg</span> <span class="n">text</span><span class="o">-</span><span class="n">sm</span> <span class="n">px</span><span class="o">-</span><span class="mi">5</span> <span class="n">py</span><span class="o">-</span><span class="mf">2.5</span> <span class="n">me</span><span class="o">-</span><span class="mi">2</span> <span class="n">mb</span><span class="o">-</span><span class="mi">2</span><span class="s2">"&gt;
        READY !!
    &lt;/button&gt;    
  ... ...  
  """</span>
<span class="k">end</span>
</code></pre></div></div>

<h3>결론</h3>
<center>
  <img src="assets\img\posts\toggle_button.png" width="300" />
</center>

<p>위 작업이 정상적으로 완료되었다면 의도한대로 사용자 정의 toggle button 이 동작하는 것을 확인 할 수 있다. </p>]]></content><author><name>Yong gon Yun</name></author><category term="phoenix" /><category term="liveview" /><category term="custom javascript" /><category term="node.js" /><summary type="html"><![CDATA[Phoenix LiveView 에서 사용자 정의 JS code 구현 및 적용을 위한 Node.js 설정 및 render/1 에 적용하는 과정]]></summary></entry><entry><title type="html">impl attribute</title><link href="http://localhost:4000/impl_attribute.html" rel="alternate" type="text/html" title="impl attribute" /><published>2024-01-23T15:32:20+09:00</published><updated>2024-01-23T15:32:20+09:00</updated><id>http://localhost:4000/impl_attribute</id><content type="html" xml:base="http://localhost:4000/impl_attribute.html"><![CDATA[<p>elixir code 를 작성할 때, behaviour 나 macro 의 callback 의 구현체를 정의하는 구조는 일반 함수와 동일하다. 이를 구별하기 위해 <code>@impl true</code>를 사용하는 것이 좋다. 사용하지 않을 경우, 작업에 문제가 발생하지는 않으나 IDE 나 complier 가 아래 내용의 warning 이 나타날 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module attribute @impl was not set for function init/1 callback (specified in GenServer). This either means you forgot to add the "@impl true" annotation before the definition or that you are accidentally overriding this callback
</code></pre></div></div>
<p>아울러 해당 attribute 를 사용했을 때의 장점은 다음과 같다.</p>

<ol>
  <li><strong>명확성</strong>: <code>@impl true</code>는 해당 함수가 특정 행위(behaviour)의 callback 함수임을 명확히 함. 따라서 가독성이 높아질 수 있음.</li>
  <li><strong>컴파일러 검증</strong>: <code>@impl true</code>를 사용하면 Elixir compiler가 해당 함수가 실제로 지정된 행위의 callback 함수인지를 검증함으로 써, 잘못된 callback 함수일 경우, compile 단계에서 이를 감지할 수 있어짐</li>
  <li><strong>문서화</strong>: <code>@impl true</code>를 사용하면 ExDoc과 같은 문서화 도구에서 해당 함수가 콜백 함수임을 자동으로 식별하여 문서화할 수 있음.</li>
  <li><strong>유지보수 용이성</strong>: 코드의 유지보수를 담당하는 다른 개발자들에게 해당 함수의 역할과 중요성을 쉽게 전달할 수 있음.</li> 
</ol>

<p><strong>예시</strong></p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">ImplAttribute</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">GenServer</span>
  <span class="o">...</span> <span class="o">...</span>
  <span class="nv">@impl</span> <span class="no">true</span>
  <span class="k">def</span> <span class="n">init</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">list</span><span class="p">}</span>
  <span class="k">end</span>

  <span class="nv">@impl</span> <span class="no">true</span>
  <span class="k">def</span> <span class="n">handle_call</span><span class="p">(</span><span class="ss">:view</span><span class="p">,</span> <span class="n">_from</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:reply</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">}</span>
  <span class="k">end</span>
  <span class="o">...</span> <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>
<p>만약 callback 이 아닌 일반 함수에 해당 attribute 를 사용할 경우 다음과 같은 warning 이 발생한다.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">ImplAttribute</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">GenServer</span>
  <span class="o">...</span> <span class="o">...</span>
  <span class="nv">@impl</span> <span class="no">true</span>
  <span class="k">def</span> <span class="n">start_link</span><span class="p">()</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="p">[])</span>
  <span class="k">end</span>

  <span class="nv">@impl</span> <span class="no">true</span>
  <span class="k">def</span> <span class="n">view</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="ss">:view</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="o">...</span> <span class="o">...</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>got "@impl true" for function add/2 but no behaviour specifies such callback. The known callbacks are: ... ...
</code></pre></div></div>
<h3>그렇다면 다른 @impl attribute 는?</h3>

<p><code>@impl Module</code>: 여기서 Module은 특정 행위를 나타내는 모듈. 이 형식은 함수가 특정 행위의 일부임을 더 명시적으로 나타내는 데 사용된다. 예를 들어, <code>@impl GenServer</code>는 해당 함수가 <code>GenServer</code> 행위의 callback임을 나타낸다.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">MyGenServer</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">GenServer</span>

  <span class="c1"># Client API</span>

  <span class="k">def</span> <span class="n">start_link</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="ss">name:</span> <span class="bp">__MODULE__</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">add</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="p">{</span><span class="ss">:add</span><span class="p">,</span> <span class="n">value</span><span class="p">})</span>
  <span class="k">end</span>

  <span class="c1"># Server Callbacks</span>

  <span class="nv">@impl</span> <span class="no">GenServer</span>
  <span class="k">def</span> <span class="n">init</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">args</span><span class="p">}</span>
  <span class="k">end</span>

  <span class="nv">@impl</span> <span class="no">GenServer</span>
  <span class="k">def</span> <span class="n">handle_cast</span><span class="p">({</span><span class="ss">:add</span><span class="p">,</span> <span class="n">value</span><span class="p">},</span> <span class="n">state</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">new_state</span> <span class="o">=</span> <span class="n">state</span> <span class="o">+</span> <span class="n">value</span>
    <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="n">new_state</span><span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code>@impl GenServer</code> attribute는 <code>init/1</code> 및 <code>handle_cast/2</code> 함수가 <code>GenServer</code>의 callback임을 명시</p>]]></content><author><name>Yong gon Yun</name></author><category term="elixir" /><category term="impl" /><category term="attribute" /><summary type="html"><![CDATA[impl attribute]]></summary></entry><entry><title type="html">Elixir GenServer</title><link href="http://localhost:4000/genserver.html" rel="alternate" type="text/html" title="Elixir GenServer" /><published>2024-01-23T10:32:20+09:00</published><updated>2024-01-23T10:32:20+09:00</updated><id>http://localhost:4000/genserver</id><content type="html" xml:base="http://localhost:4000/genserver.html"><![CDATA[<p>Elixir의 <code>GenServer</code>는 OTP(Open Telecom Platform) behaviour 중 하나로, 서버 프로세스를 구현하기 위한 추상화를 제공한다. GenServer는 클라이언트-서버 관계에서 서버 부분을 담당하며, 상태를 유지하고, 요청을 동기적 또는 비동기적으로 처리할 수 있다. 이는 Elixir/Erlang 시스템에서 병렬처리와 상태 관리를 용이하게 하는 강력한 도구이다.</p>

<p><code>GenServer</code> 의 다양한 macro callback 중 주요한 것을을 사용하여 통신 moudule 을 구현하고자 한다. 해당 module 의 구조는 다음과 같다.</p>

<center>
  <img src="assets\img\posts\genserver.png" width="500" height="" />
</center>

<p>module 내 구성은 크게 client 와 server 구현 부분으로 구분 된다. client 는 경우, 해당 module 이 실행되는 application 자체 또는 일부 process 에서 실행될 code 이며, 해당 code 를 통해 server process 를 생성, 동기/비동기 작업 요청 및 응답, 종료 등의 작업을 정의한다.</p>
<p>server 부분의 경우, client 작업 요청에 대응하는 작업에 대한 code 를 정의한다. 위에 언급된 <code>GenServer</code> callback 들의 경우, 모두 <code>GenServer</code> behaviour의 구현체이다.</p>
<p>client-server 에 각 callback 들에 대해 간단하게 설명하면 다음과 같다.</p>

<ol>
  <li>Server 생성
    <ul>
      <li><code>start_link/3</code>: 새로운 GenServer 프로세스를 시작하고 연결</li>
      <li><code>init/1</code>: <code>start_link/3</code> 요청에 의해 GenServer가 시작될 때 호출되며, 초기 상태를 설정</li>
    </ul>
  </li>
  <li>비동기 요청/응답
    <ul>
      <li><code>cast/2</code>: 비동기적 통신에 사용. client 는 server 에 메시지를 보내고 즉시 반환됨. 이 메소드는 서버의 <code>handle_cast/2</code> callback을 trigger.</li>
      <li><code>handle_cast/2</code>: 비동기적 요청을 처리. 클라이언트는 응답을 기다리지 않음.</li>
    </ul>
  </li>
  <li>동기 요청/응답
    <ul>
      <li>call/3<code></code>: 동기적 통신에 사용. client는 server에 요청을 보내고, server가 응답할 때까지 기다리며, server의 <code>handle_call/3</code>s callback을 trigger.</li>
      <li><code>handle_call/3</code>: 동기적 요청을 처리하고 그 결과를 clientd에게 응답.</li>
    </ul>
  </li>
  <li>Server 종료
    <ul>
      <li><code>stop/3</code>: <code>GenServer</code> 프로세스를 안전하게 종료하기 위해 사용. 이 함수는 종료 이유(ex.  'normal', 'shutdown', 'kill' 등)와 타임아웃(default : 5 sec)을 지정할 수 있으며, 서버의 <code>terminate/2</code>  callback을 trigger.</li>
      <li><code>terminate/2</code>: server가 종료되기 전에 호출되는 callback <code>GenServer</code> 프로세스가 정상적으로 종료될 때 호출되며, 종료 전에 필요한 정리 작업(ex.종료되기 전에 상태를 저장하거나 열려 있는 리소스를 닫는 등의 작업 등)을 수행할 수 있습니다.</li>
    </ul>
  </li>
</ol>

<p><strong>예제 코드</strong></p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">defmodule</span> <span class="no">ShopingList</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">GenServer</span>

  <span class="c1">#  ------ client API --------</span>

  <span class="k">def</span> <span class="n">start_link</span><span class="p">()</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="p">[])</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">add</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">view</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="ss">:view</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">remove</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="p">{</span><span class="ss">:remove</span><span class="p">,</span> <span class="n">item</span><span class="p">})</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">stop</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="ss">:normal</span><span class="p">,</span> <span class="ss">:infinity</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># ----- server callback -----</span>

  <span class="k">def</span> <span class="n">init</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">list</span><span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">handle_cast</span><span class="p">({</span><span class="ss">:remove</span><span class="p">,</span> <span class="n">item</span><span class="p">},</span> <span class="n">list</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">updated_list</span> <span class="o">=</span> <span class="no">Enum</span><span class="o">.</span><span class="n">reject</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="k">fn</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">==</span> <span class="n">item</span> <span class="k">end</span><span class="p">)</span>
    <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="n">updated_list</span><span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">handle_cast</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">updated_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="o">|</span><span class="n">list</span><span class="p">]</span>
    <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="n">updated_list</span><span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">handle_call</span><span class="p">(</span><span class="ss">:view</span><span class="p">,</span> <span class="n">_from</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:reply</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">terminate</span><span class="p">(</span><span class="n">_reason</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">IO</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="s2">"This Server is termniated."</span><span class="p">)</span>
    <span class="no">IO</span><span class="o">.</span><span class="n">inspect</span><span class="p">(</span><span class="n">list</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><strong>실행 결과</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex(1)&gt; {:ok, pid} = ShoppingList.start_link()
{:ok, #PID&lt;0.422.0&gt;}
</code></pre></div></div>
<p><code>ShoppingList.start_link()</code> 를 통해 server process 를 생성한다. server 측 <code>init(list)</code> 함수 callback 이 실행되어 server process 를 초기화 하고 그 결과 및 pid 를 client 에게 반환한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex(2)&gt; ShoppingList.add(pid, "eggs") 
:ok
iex(3)&gt; ShoppingList.add(pid, "milk") 
:ok
iex(4)&gt; ShoppingList.add(pid, "cheese") 
:ok
iex(5)&gt; ShoppingList.view(pid) 
["cheese", "milk", "eggs"]
</code></pre></div></div>

<p><code>ShoppingList.add(pid, "eggs")</code> 등의 함수를 통해 server process 비동기 작업을 요청한다. <code>:ok</code> 응답은 server 작업의 완료와 관계없이 반환된다. <code>handle_cast(item, list)</code>가 작업을 하여 server 자체 list 에 client 가 보낸 메세지를 list 에 추가한다.</p>
<p><code>ShoppingList.view(pid)</code> 를 통해 동기화된 작업을 요청한다. 해당 요청으로 <code>handle_call(:view, _from, list)</code> callback 이 trigger 된다. 해당 callback 반환값 튜플<code>{:reply, list, list}</code>의 각 요소는 다음의 의미를 가진다.</p>
<ol>
  <li><code>:reply</code>: client 에게 동기적으로 응답을 보내야 함을 의미</li>
  <li><code>list</code>: client 에게 보낼 실제 응답 data</li>
  <li><code>list</code>: 해당 callback 작업 이후 server 가 가질 data</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex(6)&gt; ShoppingList.remove(pid, "cheese") 
:ok
iex(7)&gt; ShoppingList.view(pid)
["milk", "eggs"]
</code></pre></div></div>

<p><code>ShoppingList.remove(pid, "cheese")</code> 의 경우 앞에서 사용한  <code>ShoppingList.add(pid, "eggs")</code> 와 동일하게 비동기 작업을 요청하지만 함수 다형성(polymorphism) 을 적용하여 별도로 정의된 <code>handle_cast({:remove, item}, list)</code> callback 을 trigger 한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex(8)&gt; ShoppingList.stop(pid) 
This Server is termniated.
["milk", "eggs"]
:ok
</code></pre></div></div>

<p>server process 을 종료 요청을 보내고 triggering 된 <code>terminate(_reason, list)</code> 작업을 진행하고 해당 process 는 종료된다.</p>

<h3><code>Phoenix PubSub</code> 과 <code>GenServer</code></h3>

<p> <code>Phoenix PubSub</code>은 내부적으로 <code>GenServer</code>를 사용하여 구축된다. <code>Phoenix PubSub</code>은 Elixir 어플리케이션 내에서 프로세스 간의 메시징을 쉽게 구현할 수 있도록 해주는 시스템입니다. 이는 주로 Phoenix framework 내에서 실시간 웹 기능을 구현하는 데 사용되며, 웹소켓을 통해 client-server 간의 메시지를 효율적으로 교환할 수 있게 해준다. 그 주요 역할은 다음과 같다.</p>

<ul>
  <li>상태 관리: 각 PubSub 서버는 구독 정보와 같은 상태를 유지 관리.</li>
  <li>메시지 처리: 발행된 메시지는 <code>GenServer</code> 프로세스를 통해 구독자들에게 전달.</li>
  <li>동기화 및 제어: <code>GenServer</code> callback을 통해 메시지 전송 및 구독 관리를 제어.</li>
</ul>

<p><br />
<a href="https://elixircasts.io/intro-to-genserver">참고 문헌 - ElixirCasts - #12: Intro to GenServer</a></p>]]></content><author><name>Yong gon Yun</name></author><category term="elixir" /><category term="genserver" /><category term="pubsub" /><summary type="html"><![CDATA[Elixir GenServer]]></summary></entry><entry><title type="html">changeset/2 in Ecto Library</title><link href="http://localhost:4000/changeset.html" rel="alternate" type="text/html" title="changeset/2 in Ecto Library" /><published>2024-01-15T10:32:20+09:00</published><updated>2024-01-15T10:32:20+09:00</updated><id>http://localhost:4000/changeset</id><content type="html" xml:base="http://localhost:4000/changeset.html"><![CDATA[<p>Phoenix LiveView 에서 DB 처리 작업은 Ecto library 를 사용하여 작업이 진행된다. 이와 관련하여, Ecto 의 기능과 구성요소에 대해 알아보고, 여기에서 <code>changeset/2</code> 함수에 대해 좀더 알아 본다. </p>

<h3>Ecto 란?</h3>
<p>Phoenix LiveView 에서 사용하는 Ecto library 는 Elixir 언어를 위한 database wrapper 이다. 주로 Elixir web-framewor 인 Phoenix 와 함께 사용되며, 데이터베이스 상호작용을 효율적으로 만들어 준다.</p>

<p><strong>구성요소</strong></p>

<ol>
  <li>
    <p>Repo (Repository)</p>
    <ul>
      <li>데이터베이스와의 모든 상호작용(CRUD)을 처리</li>
      <li>데이터베이스에 query를 보내고 결과를 반환 받음</li>
      <li>여러 Repo 를 지원 할 수 있어, 다양한 데이터베이스와 동시에 작업 가능</li>
    </ul>
  </li>
    <li>
    <p>Schema</p>
    <ul>
      <li>데이터베이스 table 과 Elixir 구조체 간 mapping 을 정의</li>
      <li>각 field 는 Elixir data type 으로 선언됨</li>
      <li>schema 는 data 유효성 검사와 제약 조건도 함께 정의함</li>
    </ul>
  </li>
    <li>
    <p>Changeset</p>
    <ul>
      <li>data 를 삽입하거나 업데이트하기 전에 데이터를 검증하고 변환하는 역할</li>
      <li>유효성 검사, 제약 조건 확인, filtering, 형식 변환 등을 처리</li>
    </ul>
  </li>
    <li>
    <p>Query</p>
    <ul>
      <li>Elixir 의 구문을 사용하여 database query 를 생성 또는 사용자 정의 query 구현 가능하도록 함</li>
      <li>query 는 Ecto.Query module 을 사용하여 작성됨</li>
      <li>query 는 compile 타임에 생성되므로, 효율적인 성능을 발휘함</li>
    </ul>
  </li>
</ol>

<p><strong>Ecto 의 특징</strong></p>
<ul>
  <li>Database Adapter : PostgreSQL, MySQL, SQLite 등 다양한 데이터베이스를 지원</li>
  <li>Migration : 데이터베이스 schema 변경을 위한 migration 을 쉽게 관리</li>
  <li>Transaction: 데이터베이스 transaction을 통해 데이터 일관성을 보장</li>
  <li>Multi-Tenancy : 필요한 경우, 동일한 app 내에서 여러 데이터베이스를 다룰 수 있음</li>
</ul>

<h3>changset/2</h3>

<p><strong><code>changset/2</code>의 역할</strong></p>
<ul>
  <li><code>cast/3</code>를 사용하여 비 구조체 type 의 user data 를 구조체 형태로 변환하여 Ecto 데이터베이스 schema 와 안전한 상태로 mapping 될 수 있도록 변환</li>
  <li>관련 feild 값을 capture 하여 데이터베이스에 저장된 값과 비교, 변경 여부를 확인</li>
  <li>현재 작업 중이 값이 유효한지를 검증한다. 변경된 값이 query 를 통해 데이터베이스에 값이 저장 또는 수정되기 전에, 유효성 (field type, 길이, 값의 범위, 존재 여부 등) 을 확인하여 잘못된 형식 또는 잘못된 값이 아닌지를 먼저 판단한다. 해당 과정은 각 field 에 대해 항상 동일한 규칙과 조건을 적용한다. (consistent rule)</li>
  <li>유효성 확인의 결과로 <code>:ok</code> 또는 <code>:error</code> 상태를 반환하여 context 가 query 작업을 진행할지 여부에 대한 state 를 제공한다.</li>
</ul>

<p><strong>예제 code</strong></p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">changeset</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">product</span>
  <span class="o">|&gt;</span> <span class="n">cast</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="p">[</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:description</span><span class="p">,</span> <span class="ss">:unit_price</span><span class="p">,</span> <span class="ss">:sku</span><span class="p">])</span>
  <span class="o">|&gt;</span> <span class="n">validate_required</span><span class="p">([</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:description</span><span class="p">,</span> <span class="ss">:unit_price</span><span class="p">,</span> <span class="ss">:sku</span><span class="p">])</span>
  <span class="o">|&gt;</span> <span class="n">unique_constraint</span><span class="p">(</span><span class="ss">:sku</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="n">validate_number</span><span class="p">(</span><span class="ss">:unit_price</span><span class="p">,</span> <span class="ss">greater_than:</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>
<ol>
  <li><code>cast/3</code> 를 통해 attr key-values 중 <code>product</code> 구조체의 field (<code>[:name, :description, :unit_price, :sku]</code>) 에 해당하는 값이 있는지 확인하고 해당하는 값을 <code>product</code> 구조체로 변환</li>
  <li><code>validate/2</code>, <code>unique_constraint/2</code>, <code>validate_number/2</code> 함수들을 통해 유효성 검사를 진행</li>
  <li>최종으로 해당 값이 존재하고, 유효성에 문제가 없으면 <code>:ok</code> 아니면 <code>:error</code> 상태를 반환한다.</li>
  <li></li>
</ol>

<ul>
  <li><a href="https://pragprog.com/titles/liveview/programming-phoenix-liveview/">참고 문헌 - programming-phoenix-liveview_B10.0</a></li>
</ul>]]></content><author><name>Yong gon Yun</name></author><category term="ecto" /><category term="changeset/2" /><summary type="html"><![CDATA[changeset/2 in Ecto Library]]></summary></entry><entry><title type="html">Lazy Collection 과 Stream library</title><link href="http://localhost:4000/lazy-collection.html" rel="alternate" type="text/html" title="Lazy Collection 과 Stream library" /><published>2024-01-07T10:32:20+09:00</published><updated>2024-01-07T10:32:20+09:00</updated><id>http://localhost:4000/lazy-collection</id><content type="html" xml:base="http://localhost:4000/lazy-collection.html"><![CDATA[<h3>Lazy Collection</h3>
<p>Lazy Colleciton 은 Elixir와 같은 함수형 프로그래밍 언어에서 중요한 개념 중 하나로 데이터가 실제로 필요할 때까지 그 처리를 연기하는 방식으로 작동한다. 이 방식은 특히 대용량 데이터를 다룰 때 메모리 사용을 최소화하고 성능을 향상시킬 수 있다.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stream</span> <span class="o">=</span> <span class="no">Stream</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">10000</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="nv">&amp;1</span> <span class="o">*</span> <span class="nv">&amp;1</span><span class="p">))</span>
</code></pre></div></div>

<p>이 코드는 1부터 10,000까지의 숫자 각각에 대해 제곱을 하는 스트림을 생성한다. 그러나 실제 제곱 연산은 스트림을 열거하는 시점, 예를 들어 Enum.to_list(stream)을 호출할 때까지 수행되지 않는다.</p>

<p><strong>특징</strong></p>
<ul>
<li>비동기 처리: lazy collection은 데이터의 전체 집합을 메모리에 한 번에 로드하지 않는다. 대신, 요소들은 필요할 때, 즉 실제로 열거(enumerate)하거나 접근할 때 처리된다.</li><br />
<li>효율성: lazy collection은 메모리 사용을 최적화한다. 큰 데이터셋을 한 번에 처리하는 대신, 작은 조각으로 나누어 필요한 부분만 처리한다. 이는 특히 파일 읽기, 외부 API 호출, 대규모 계산과 같은 상황에서 유용하다.</li><br />
<li>Function Chaining: lazy collection은 여러 함수를 연결(chaining)하여 복잡한 데이터 처리 파이프라인을 구축할 수 있다. 각 함수는 이전 함수의 출력을 입력으로 받아 처리한다.(아래 보충 설명 참조)</li><br />
<li>Stream Module: Elixir에서 lazy collection을 구현하는 데 사용되는 주요 모듈은 Stream이다. Stream 모듈은 다양한 지연 처리 함수를 제공한다. 예를 들어, <code>Stream.map/2</code>은 컬렉션의 각 요소에 주어진 함수를 적용하지만, 실제 계산은 스트림을 열거할 때까지 연기된다.</li>
</ul>

<h3>즉시 연산 vs 지연 연산</h3>
<p>아래 두 예제의 경우, 반환값은 동일하지만, 아래와 같이 다른 기능적 특징을 가진다.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Stream</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">10000</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="nv">&amp;1</span> <span class="o">*</span> <span class="nv">&amp;1</span><span class="p">))</span>
</code></pre></div></div>
<ul>
<li>지연 연산: Stream.map은 연산을 즉시 수행하지 않고, 각 요소에 대한 연산을 정의하는 스트림을 반환한다. 이 스트림은 실제로 열거되기 전까지는 어떤 연산도 수행하지 않는다.</li><br />
<li>메모리 효율성: 큰 데이터셋을 처리할 때 Stream.map은 모든 요소를 한 번에 메모리에 로드하지 않는다. 대신, 스트림을 열거할 때 각 요소를 개별적으로 처리한다. 이는 대규모 데이터셋을 다룰 때 메모리 사용을 최소화한다.</li><br />
<li>적용 예: 위 code 에서 <code>Enum.to_list(stream)</code> 또는 다른 Enum 함수를 사용하여 스트림을 열거할 때까지 실제 연산이 연기된다.</li>
</ul>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Enum</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">10000</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="nv">&amp;1</span> <span class="o">*</span> <span class="nv">&amp;1</span><span class="p">))</span>
</code></pre></div></div>
<ul>
<li>즉시 연산: Enum.map은 함수가 호출되는 즉시 모든 요소에 대해 연산을 수행한다. 연산 결과는 즉시 계산되고 반환된다.</li><br />
<li>메모리 사용: 이 방식은 연산을 수행한 전체 결과를 메모리에 저장한다. 큰 데이터셋을 처리할 경우, 이는 상당한 양의 메모리를 사용할 수 있다.</li><br />
<li>적용 예: 연산 결과가 즉시 필요하고 데이터셋이 메모리에 들어갈 수 있을 정도로 작을 때 유용.</li>
</ul>

<center>*****</center>
<h3>Function Chaining 상태에서의 Lazy Collection</h3>
<p>앞에서 관련 장점을 설명했으나, 다양한 함수를 연속적으로 사용하는 function chaining 에서 항상 해당 장점이 발휘되는 것은 아니다.</p>
<p>예를 들면,</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">..</span><span class="mi">10000</span>
<span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="nv">&amp;1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>
<span class="o">|&gt;</span> <span class="no">Stream</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="nv">&amp;1</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">))</span>
<span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
</code></pre></div></div>

<p>의 처리 과정을 보면,</p>

<ol>
<li>chaining 과정에서 Stream 모듈의 함수 뒤에 Enum 모듈의 함수가 오면, 스트림에 대한 모든 연산이 Enum 함수 호출 시점에 즉시 수행된다. 이는 Enum 함수가 실제 데이터를 필요로 하기 때문이다.</li><br />
<li>반대로, Enum 함수 다음에 Stream 함수가 오면, Enum 함수는 즉시 실행되고, 그 결과는 Stream 함수에 의해 다시 지연 처리된다.</li><br />
<li>이 경우, Enum.map은 즉시 모든 요소에 대해 연산을 수행한다. 이어서 <code>Stream.filter</code>는 지연 처리 스트림을 생성하지만, 최종적으로 <code>Enum.to_list</code>에 의해 이 스트림이 즉시 열거되어 모든 데이터 처리가 완료된다.</li>
</ol>

<p>결론적으로, 예제에서 <code>Stream.filter(&amp;(&amp;1 &lt; 100))</code>는 결국 체인의 마지막에 있는 <code>Enum.to_list()</code> 함수 때문에 즉시 연산 처리된다.</p>
<p>chaining된 함수들 중 하나라도 즉시 연산을 수행하는 Enum 모듈의 함수를 포함하고 있고, 이것이 체인의 마지막에 위치한다면, 체인의 모든 연산은 결국 즉시 수행된다. 이는 Enum 모듈의 함수가 실제 데이터를 필요로 하기 때문에, 지연된 연산들도 강제로 실행되어 결과를 산출한다.</p>
<center>*****</center>]]></content><author><name>Yong gon Yun</name></author><category term="elixir" /><category term="lazy collection" /><category term="elixir stream" /><summary type="html"><![CDATA[Lazy Collection 과 Stream library]]></summary></entry><entry><title type="html">Elixir 의 Map, Struct 등은 왜 immutable data types 인가?</title><link href="http://localhost:4000/immutable-data-type.html" rel="alternate" type="text/html" title="Elixir 의 Map, Struct 등은 왜 immutable data types 인가?" /><published>2024-01-03T10:32:20+09:00</published><updated>2024-01-03T10:32:20+09:00</updated><id>http://localhost:4000/immutable-data-type</id><content type="html" xml:base="http://localhost:4000/immutable-data-type.html"><![CDATA[<p>Elixir 에서 Map 은 immutable type 이다. 따라서 <code>Map.delete/2</code>, <code>Map.put/3</code>, <code>Map.update/4</code> 등과 같은 함수는 실제로 기존 map data 를 수정하는 것이 아니라, 수정되된 값으로 새로운 map data 를 만들고 이것을 재할당 하는 것이다.</p>
<p>Struct 의 경우도, 한번 생성된 instance 의 내부 field 값을 변경하고자 하는 경우, 이는 수정이 아닌, 새로운 data 생성 및 이를 재할당 하는 것이다. 그런데 list, map 과 같이 많은 데이터를 포함하고 있는 경우, 그중 하나의 값이 바뀔 때마다 매번 모든 부분에 대한 재할당을 진행한다면, 메모리 사용이나 성능상 단점이 매 커보인다.</p>
<p>그렇다면, immutable data type 으로 처리할 때 어떤 이점이 있을 수 있으며, 예상되는 문제점은 어떻게 해결할까?</p>

<ul>
<li>구조적 공유(Structural Sharing): 변경 불가능한 데이터 구조에서는 종종 구조적 공유 작업이 필요하다. 즉, 새로운 맵을 생성할 때 전체 구조를 복사하는 대신, 변경되지 않은 부분은 기존 구조를 재사용하여 필요한 메모리 양과 복사 작업이 크게 줄인다. (결국 immutable data type 이라도 매번 모든 data 에 대한 memory 할당 및 쓰기 작업이 진행되지는 않는다.)</li><br />
<li>예측 가능성과 안정성: 데이터의 불변성은 함수의 부작용을 줄여준다. 이는 프로그램의 동작을 예측하기 쉽게 만들고, 디버깅과 유지보수를 용이하게 한다. </li><br />
<li>병렬 처리: 데이터가 변경 불가능하면 여러 스레드나 프로세스에서 동시에 데이터에 접근해도 안전하므로, 병렬 처리와 동시성 프로그래밍에서 큰 이점을 제공한다.</li><br />
<li>최적화: 현대의 가비지 컬렉션(GC) 시스템은 변경 불가능한 데이터 구조를 효율적으로 처리할 수 있도록 설계되어 있다. 따라서 새로운 구조를 생성하는 오버헤드는 종종 생각보다 작다.</li>
</ul>]]></content><author><name>Yong gon Yun</name></author><category term="elixir" /><category term="map" /><category term="struct" /><category term="immutable data type" /><summary type="html"><![CDATA[Elixir 의 immutable data types (Map, Struct)]]></summary></entry><entry><title type="html">slot attribute 사용</title><link href="http://localhost:4000/phoenix-slot.html" rel="alternate" type="text/html" title="slot attribute 사용" /><published>2024-01-01T10:32:20+09:00</published><updated>2024-01-01T10:32:20+09:00</updated><id>http://localhost:4000/phoenix-slot</id><content type="html" xml:base="http://localhost:4000/phoenix-slot.html"><![CDATA[<p>Phoenix LiveView 에서 동적인 component 를 삽입 하고자 하는 경우, 해당  component attribute 로 `slot` 을 정의하고 이를 사용해 주어야 한다. </p>

<h3>사용 방법</h3>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">slot</span> <span class="p">:</span><span class="err">블록명</span><span class="p">,</span> <span class="ss">required:</span> <span class="no">true</span>
<span class="k">def</span> <span class="err">컴포넌트명</span><span class="p">(</span><span class="n">assigns</span><span class="p">)</span> <span class="k">do</span>
	<span class="sx">~H""</span><span class="s2">"
	&lt;동적으로 구현할 컴포넌트 태그&gt;
		&lt;&gt;..사용자 구현...&lt;&gt;
		&lt;%= render_slot(@블록명) %&gt;
	&lt;/동적으로 구현할 컴포넌트 태그&gt;
	"""</span>
<span class="k">end</span>
</code></pre></div></div>

<h3> Slot 정의</h3>
<ul>
<li><code>slot :블록명</code> : 컴포넌트 내부에 동적으로 콘텐츠를 삽입할 수 있는 블록명이라는 이름의 슬롯을 정의.</li>
<li><code>required: true</code>:  이 슬롯이 반드시 제공되어야 함을 의미. 이 컴포넌트를 사용할 때는 블록명 슬롯에 대한 내용을 제공해야 한다.</li>
</ul>

<h3>컴포넌트 정의</h3>
<ul>
<li><code>def 컴포넌트명(assigns) do ... end</code> : 컴포넌트를 정의하는 함수. 이 함수 내에서 HTML 태그와 Elixir의 템플릿 언어를 사용하여 컴포넌트의 구조를 정의한다.</li>
</ul>

<h3>동적 콘텐츠의 삽입 위치</h3>
<ul>
<li><code>&lt;%= render_slot(@블록명) %&gt;</code> : 구문은 정의된 블록명 슬롯에 전달된 콘텐츠를 해당 위치에 렌더링.이 위치는 <code>"동적으로 구현할 컴포넌트 태그"</code> 내부로 이 태그 안에서 블록명 슬롯에 제공된 콘텐츠가 렌더링됨.</li>
</ul>

<h3>사용자 구현</h3>
<ul>
<li>사용자는 이 컴포넌트를 사용할 때 블록명 슬롯에 원하는 콘텐츠를 제공할 수 있다. 이 콘텐츠는 다양한 HTML 요소, 다른 LiveView 컴포넌트, 또는 동적인 데이터를 포함할 수 있다.</li>
</ul>

<h3>실제 코드 예시</h3>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">attr</span> <span class="ss">:view_box</span><span class="p">,</span> <span class="ss">:string</span>
<span class="n">slot</span> <span class="ss">:inner_block</span><span class="p">,</span> <span class="ss">required:</span> <span class="no">true</span>
<span class="k">def</span> <span class="n">canvas</span><span class="p">(</span><span class="n">assigns</span><span class="p">)</span> <span class="k">do</span>
  <span class="sx">~H""</span><span class="s2">"
  &lt;svg viewBox={ @view_box }&gt;
    &lt;defs&gt;
      &lt;%!-- 위에 정의된 point component 사용하여 정사각형 생성 --%&gt;
      &lt;rect id="</span><span class="n">point</span><span class="s2">" width="</span><span class="mi">10</span><span class="s2">" height="</span><span class="mi">10</span><span class="s2">" /&gt;
    &lt;/defs&gt;
    &lt;%= render_slot(@inner_block) %&gt;
  &lt;/svg&gt;
  """</span>
<span class="k">end</span>
</code></pre></div></div>]]></content><author><name>Yong gon Yun</name></author><category term="phoenix" /><category term="liveview" /><category term="slop" /><summary type="html"><![CDATA[slot attribute 사용]]></summary></entry><entry><title type="html">Elixir - intance 생성</title><link href="http://localhost:4000/create-instance.html" rel="alternate" type="text/html" title="Elixir - intance 생성" /><published>2023-12-29T13:32:20+09:00</published><updated>2023-12-29T13:32:20+09:00</updated><id>http://localhost:4000/create-instance</id><content type="html" xml:base="http://localhost:4000/create-instance.html"><![CDATA[<p>Elixir 문범에서 struct 에 대한 instace를 생성하는 방법은 아래와 같이 두가지가 존재한다. (ChatGPT 가 설명한 그 용도의 차이점에 대해서.. 아직 잘 모르겠다. 내눈에는 그냥 동일한 용도로 사용되는 것 처럼 보인다. ;;)</p>

<h3><code>__MODULE__</code> 사용</h3>
<ul>
<li>사용법: <code>%__MODULE__{}</code> 구문은 주로 모듈 내부에서 해당 모듈의 구조체 인스턴스를 생성할 때 사용. 이 경우, 모듈 내부에서 직접 <code>%__MODULE__{field1: value1, field2: value2}</code>와 같이 구조체 인스턴스를 생성할 수 있다.</li><br />
<li>예시: 모듈 내부에서 <code>def new()</code> 함수를 정의하고, 이 함수 안에서 <code>%__MODULE__{}</code>를 사용하여 인스턴스를 생성할 수 있다.</li>
</ul>

<h3><code>def new(field \\ []), do: __struct__(field)</code> 정의</h3>
<ul>
<li>사용법: 이 방법은 모듈 외부에서 인스턴스를 생성할 때 사용합니다. 여기서 new 함수는 외부에서 호출할 수 있는 공개 인터페이스를 제공하고, <code>__struct__</code> 호출을 통해 내부적으로 구조체 인스턴스를 생성한다.</li><br />
<li>예시: 다른 모듈에서 <code>ModuleName.new(field_values)</code>를 호출하여 구조체 인스턴스를 생성할 수 있다. 여기서 field_values는 인스턴스의 필드를 초기화하기 위해 사용됨.</li>
</ul>

<h3>결론</h3>
<p>두 방식 모두 Elixir에서 구조체 인스턴스를 생성하는 방법. <code>__MODULE__</code> 방식은 주로 모듈 내부에서 사용되며, <code>def new(field \\ []), do: __struct__(field)</code> 방식은 모듈 외부에서 구조체 인스턴스를 생성할 때 사용되는 공개 함수를 제공한다. 두 경우 모두, <code>모듈명.new(field 값)</code>과 같은 형태로 호출하여 인스턴스를 생성할 수 있다.</p>]]></content><author><name>Yong gon Yun</name></author><category term="elixir" /><category term="instance" /><category term="struct" /><summary type="html"><![CDATA[Elixir - intance 생성]]></summary></entry><entry><title type="html">struct - instance 에 대해 (Elixir vs OOP languages)</title><link href="http://localhost:4000/instance-with-elixir.html" rel="alternate" type="text/html" title="struct - instance 에 대해 (Elixir vs OOP languages)" /><published>2023-12-29T10:32:20+09:00</published><updated>2023-12-29T10:32:20+09:00</updated><id>http://localhost:4000/instance-with-elixir</id><content type="html" xml:base="http://localhost:4000/instance-with-elixir.html"><![CDATA[<p>elixir 에서의 구조체는 상속, 다형성 등이 지원되지 않고 한번 정의되면 구조체 내부 field 값을 변경할 수 없는, 내부에 field 가 존재하는 사용자 정의 type 이며, 해당 구조체 type 에 실제 data 를 가지게 하고 이를 변수 매칭 시킨것이 elixir instance 이다. </p>

<h3>유사점</h3>
<ol>
<li>데이터 캡슐화: Elixir의 구조체와 Java나 Python의 인스턴스 모두 데이터를 캡슐화. 여러 데이터를 하나의 구조로 묶어 관리할 수 있다.</li><br />
<li>필드 정의: 두 언어에서는 자료구조에 필드(데이터 요소)를 정의할 수 있으며, 이러한 필드는 각각의 자료구조에 속한 정보를 나타냄.</li><br />
<li>타입 안정성: Elixir의 구조체와 Java의 객체는 둘 다 특정 타입에 속하는 데이터를 담는데, 이는 데이터 타입에 대한 안정성과 예측 가능성을 제공.</li>
</ol>

<h3>차이점</h3>
<ol>
<li>불변성(Immutability) vs 가변성(Mutability): Elixir의 구조체는 불변성을 가짐. 한 번 생성되면 그 상태를 변경할 수 없음. 반면, Java나 Python의 객체는 가변적이며, 객체의 상태(필드 값 등)를 변경할 수 있음.</li><br />
<li>함수형 vs 객체지향: Elixir는 함수형 프로그래밍 패러다임을 따르기 때문에, 데이터와 함수가 분리되어 있음. 구조체는 단지 데이터를 담는 용도로 사용되며, 모든 작업은 순수 함수를 통해 처리됨. 반면, Java나 Python에서는 객체가 데이터와 그 데이터를 조작하는 메소드를 모두 포함.</li><br />
<li>상속과 다형성: Java나 Python에서는 클래스 상속과 다형성이 중요한 특징으로 객체는 부모 클래스의 속성과 메소드를 상속받을 수 있으며, 인터페이스나 추상 클래스를 통해 다형성을 구현할 수 있음. 반면, Elixir의 구조체는 이런 상속 메커니즘이나 다형성을 지원하지 않음.</li><br />
<li>메소드와 함수: Java나 Python에서 객체는 자신의 메소드를 가지고 있으며, 이를 통해 객체의 상태를 변경하거나 정보를 얻을 수 있음. Elixir에서는 모든 작업이 함수를 통해 이루어지며, 이 함수들은 구조체의 데이터에 대한 연산을 수행하지만, 구조체 내부에 정의되지 않음.</li>
</ol>

<h3>결론</h3>
<p>Elixir의 구조체는 Java나 Python의 객체와 유사하게 데이터를 캡슐화하는 역할을 하지만, 불변성, 함수형 패러다임, 상속 및 다형성 부재, 메소드와 함수의 차이라는 측면에서 분명한 차이점이 있다. 이러한 차이점들은 Elixir가 가진 함수형 프로그래밍의 특징을 반영한다.</p>]]></content><author><name>Yong gon Yun</name></author><category term="oop" /><category term="instance" /><category term="struct" /><category term="phoenix" /><category term="liveview" /><category term="elixir" /><summary type="html"><![CDATA[struct - instance 에 대해 (Elixir vs OOP languages)]]></summary></entry></feed>