[
  
    {
      "title"       : "changeset/2 in Ecto Library",
      "category"    : "",
      "tags"        : "ecto, changeset/2",
      "url"         : "./changeset.html",
      "date"        : "2024-01-15 10:32:20 +0900",
      "description" : "changeset/2 in Ecto Library",
      "content"     : "Phoenix LiveView 에서 DB 처리 작업은 Ecto library 를 사용하여 작업이 진행된다. 이와 관련하여, Ecto 의 기능과 구성요소에 대해 알아보고, 여기에서 changeset/2 함수에 대해 좀더 알아 본다. Ecto 란?Phoenix LiveView 에서 사용하는 Ecto library 는 Elixir 언어를 위한 database wrapper 이다. 주로 Elixir web-framewor 인 Phoenix 와 함께 사용되며, 데이터베이스 상호작용을 효율적으로 만들어 준다.구성요소 Repo (Repository) 데이터베이스와의 모든 상호작용(CRUD)을 처리 데이터베이스에 query를 보내고 결과를 반환 받음 여러 Repo 를 지원 할 수 있어, 다양한 데이터베이스와 동시에 작업 가능 Schema 데이터베이스 table 과 Elixir 구조체 간 mapping 을 정의 각 field 는 Elixir data type 으로 선언됨 schema 는 data 유효성 검사와 제약 조건도 함께 정의함 Changeset data 를 삽입하거나 업데이트하기 전에 데이터를 검증하고 변환하는 역할 유효성 검사, 제약 조건 확인, filtering, 형식 변환 등을 처리 Query Elixir 의 구문을 사용하여 database query 를 생성 또는 사용자 정의 query 구현 가능하도록 함 query 는 Ecto.Query module 을 사용하여 작성됨 query 는 compile 타임에 생성되므로, 효율적인 성능을 발휘함 Ecto 의 특징 Database Adapter : PostgreSQL, MySQL, SQLite 등 다양한 데이터베이스를 지원 Migration : 데이터베이스 schema 변경을 위한 migration 을 쉽게 관리 Transaction: 데이터베이스 transaction을 통해 데이터 일관성을 보장 Multi-Tenancy : 필요한 경우, 동일한 app 내에서 여러 데이터베이스를 다룰 수 있음changset/2changset/2의 역할 cast/3를 사용하여 비 구조체 type 의 user data 를 구조체 형태로 변환하여 Ecto 데이터베이스 schema 와 안전한 상태로 mapping 될 수 있도록 변환 관련 feild 값을 capture 하여 데이터베이스에 저장된 값과 비교, 변경 여부를 확인 현재 작업 중이 값이 유효한지를 검증한다. 변경된 값이 query 를 통해 데이터베이스에 값이 저장 또는 수정되기 전에, 유효성 (field type, 길이, 값의 범위, 존재 여부 등) 을 확인하여 잘못된 형식 또는 잘못된 값이 아닌지를 먼저 판단한다. 해당 과정은 각 field 에 대해 항상 동일한 규칙과 조건을 적용한다. (consistent rule) 유효성 확인의 결과로 :ok 또는 :error 상태를 반환하여 context 가 query 작업을 진행할지 여부에 대한 state 를 제공한다.예제 codedef changeset(product, attrs) do product |&gt; cast(attrs, [:name, :description, :unit_price, :sku]) |&gt; validate_required([:name, :description, :unit_price, :sku]) |&gt; unique_constraint(:sku) |&gt; validate_number(:unit_price, greater_than: 0.0)end cast/3 를 통해 attr key-values 중 product 구조체의 field ([:name, :description, :unit_price, :sku]) 에 해당하는 값이 있는지 확인하고 해당하는 값을 product 구조체로 변환 validate/2, unique_constraint/2, validate_number/2 함수들을 통해 유효성 검사를 진행 최종으로 해당 값이 존재하고, 유효성에 문제가 없으면 :ok 아니면 :error 상태를 반환한다. 참고 문헌 - programming-phoenix-liveview_B10.0"
    } ,
  
    {
      "title"       : "Lazy Collection 과 Stream library",
      "category"    : "",
      "tags"        : "elixir, lazy collection, elixir stream",
      "url"         : "./lazy-collection.html",
      "date"        : "2024-01-07 10:32:20 +0900",
      "description" : "Lazy Collection 과 Stream library",
      "content"     : "Lazy CollectionLazy Colleciton 은 Elixir와 같은 함수형 프로그래밍 언어에서 중요한 개념 중 하나로 데이터가 실제로 필요할 때까지 그 처리를 연기하는 방식으로 작동한다. 이 방식은 특히 대용량 데이터를 다룰 때 메모리 사용을 최소화하고 성능을 향상시킬 수 있다.stream = Stream.map(1..10000, &amp;(&amp;1 * &amp;1))이 코드는 1부터 10,000까지의 숫자 각각에 대해 제곱을 하는 스트림을 생성한다. 그러나 실제 제곱 연산은 스트림을 열거하는 시점, 예를 들어 Enum.to_list(stream)을 호출할 때까지 수행되지 않는다.특징비동기 처리: lazy collection은 데이터의 전체 집합을 메모리에 한 번에 로드하지 않는다. 대신, 요소들은 필요할 때, 즉 실제로 열거(enumerate)하거나 접근할 때 처리된다.효율성: lazy collection은 메모리 사용을 최적화한다. 큰 데이터셋을 한 번에 처리하는 대신, 작은 조각으로 나누어 필요한 부분만 처리한다. 이는 특히 파일 읽기, 외부 API 호출, 대규모 계산과 같은 상황에서 유용하다.Function Chaining: lazy collection은 여러 함수를 연결(chaining)하여 복잡한 데이터 처리 파이프라인을 구축할 수 있다. 각 함수는 이전 함수의 출력을 입력으로 받아 처리한다.(아래 보충 설명 참조)Stream Module: Elixir에서 lazy collection을 구현하는 데 사용되는 주요 모듈은 Stream이다. Stream 모듈은 다양한 지연 처리 함수를 제공한다. 예를 들어, Stream.map/2은 컬렉션의 각 요소에 주어진 함수를 적용하지만, 실제 계산은 스트림을 열거할 때까지 연기된다.즉시 연산 vs 지연 연산아래 두 예제의 경우, 반환값은 동일하지만, 아래와 같이 다른 기능적 특징을 가진다.Stream.map(1..10000, &amp;(&amp;1 * &amp;1))지연 연산: Stream.map은 연산을 즉시 수행하지 않고, 각 요소에 대한 연산을 정의하는 스트림을 반환한다. 이 스트림은 실제로 열거되기 전까지는 어떤 연산도 수행하지 않는다.메모리 효율성: 큰 데이터셋을 처리할 때 Stream.map은 모든 요소를 한 번에 메모리에 로드하지 않는다. 대신, 스트림을 열거할 때 각 요소를 개별적으로 처리한다. 이는 대규모 데이터셋을 다룰 때 메모리 사용을 최소화한다.적용 예: 위 code 에서 Enum.to_list(stream) 또는 다른 Enum 함수를 사용하여 스트림을 열거할 때까지 실제 연산이 연기된다.Enum.map(1..10000, &amp;(&amp;1 * &amp;1))즉시 연산: Enum.map은 함수가 호출되는 즉시 모든 요소에 대해 연산을 수행한다. 연산 결과는 즉시 계산되고 반환된다.메모리 사용: 이 방식은 연산을 수행한 전체 결과를 메모리에 저장한다. 큰 데이터셋을 처리할 경우, 이는 상당한 양의 메모리를 사용할 수 있다.적용 예: 연산 결과가 즉시 필요하고 데이터셋이 메모리에 들어갈 수 있을 정도로 작을 때 유용.*****Function Chaining 상태에서의 Lazy Collection앞에서 관련 장점을 설명했으나, 다양한 함수를 연속적으로 사용하는 function chaining 에서 항상 해당 장점이 발휘되는 것은 아니다.예를 들면,1..10000|&gt; Enum.map(&amp;(&amp;1 * 2))|&gt; Stream.filter(&amp;(&amp;1 &lt; 100))|&gt; Enum.to_list()의 처리 과정을 보면,chaining 과정에서 Stream 모듈의 함수 뒤에 Enum 모듈의 함수가 오면, 스트림에 대한 모든 연산이 Enum 함수 호출 시점에 즉시 수행된다. 이는 Enum 함수가 실제 데이터를 필요로 하기 때문이다.반대로, Enum 함수 다음에 Stream 함수가 오면, Enum 함수는 즉시 실행되고, 그 결과는 Stream 함수에 의해 다시 지연 처리된다.이 경우, Enum.map은 즉시 모든 요소에 대해 연산을 수행한다. 이어서 Stream.filter는 지연 처리 스트림을 생성하지만, 최종적으로 Enum.to_list에 의해 이 스트림이 즉시 열거되어 모든 데이터 처리가 완료된다.결론적으로, 예제에서 Stream.filter(&amp;(&amp;1 &lt; 100))는 결국 체인의 마지막에 있는 Enum.to_list() 함수 때문에 즉시 연산 처리된다.chaining된 함수들 중 하나라도 즉시 연산을 수행하는 Enum 모듈의 함수를 포함하고 있고, 이것이 체인의 마지막에 위치한다면, 체인의 모든 연산은 결국 즉시 수행된다. 이는 Enum 모듈의 함수가 실제 데이터를 필요로 하기 때문에, 지연된 연산들도 강제로 실행되어 결과를 산출한다.*****"
    } ,
  
    {
      "title"       : "Elixir 의 Map, Struct 등은 왜 immutable data types 인가?",
      "category"    : "",
      "tags"        : "elixir, map, struct, immutable data type",
      "url"         : "./immutable-data-type.html",
      "date"        : "2024-01-03 10:32:20 +0900",
      "description" : "Elixir 의 immutable data types (Map, Struct)",
      "content"     : "Elixir 에서 Map 은 immutable type 이다. 따라서 Map.delete/2, Map.put/3, Map.update/4 등과 같은 함수는 실제로 기존 map data 를 수정하는 것이 아니라, 수정되된 값으로 새로운 map data 를 만들고 이것을 재할당 하는 것이다.Struct 의 경우도, 한번 생성된 instance 의 내부 field 값을 변경하고자 하는 경우, 이는 수정이 아닌, 새로운 data 생성 및 이를 재할당 하는 것이다. 그런데 list, map 과 같이 많은 데이터를 포함하고 있는 경우, 그중 하나의 값이 바뀔 때마다 매번 모든 부분에 대한 재할당을 진행한다면, 메모리 사용이나 성능상 단점이 매 커보인다.그렇다면, immutable data type 으로 처리할 때 어떤 이점이 있을 수 있으며, 예상되는 문제점은 어떻게 해결할까?구조적 공유(Structural Sharing): 변경 불가능한 데이터 구조에서는 종종 구조적 공유 작업이 필요하다. 즉, 새로운 맵을 생성할 때 전체 구조를 복사하는 대신, 변경되지 않은 부분은 기존 구조를 재사용하여 필요한 메모리 양과 복사 작업이 크게 줄인다. (결국 immutable data type 이라도 매번 모든 data 에 대한 memory 할당 및 쓰기 작업이 진행되지는 않는다.)예측 가능성과 안정성: 데이터의 불변성은 함수의 부작용을 줄여준다. 이는 프로그램의 동작을 예측하기 쉽게 만들고, 디버깅과 유지보수를 용이하게 한다. 병렬 처리: 데이터가 변경 불가능하면 여러 스레드나 프로세스에서 동시에 데이터에 접근해도 안전하므로, 병렬 처리와 동시성 프로그래밍에서 큰 이점을 제공한다.최적화: 현대의 가비지 컬렉션(GC) 시스템은 변경 불가능한 데이터 구조를 효율적으로 처리할 수 있도록 설계되어 있다. 따라서 새로운 구조를 생성하는 오버헤드는 종종 생각보다 작다."
    } ,
  
    {
      "title"       : "slot attribute 사용",
      "category"    : "",
      "tags"        : "phoenix, liveview, slop",
      "url"         : "./phoenix-slot.html",
      "date"        : "2024-01-01 10:32:20 +0900",
      "description" : "slot attribute 사용",
      "content"     : "Phoenix LiveView 에서 동적인 component 를 삽입 하고자 하는 경우, 해당 component attribute 로 `slot` 을 정의하고 이를 사용해 주어야 한다. 사용 방법slot :블록명, required: truedef 컴포넌트명(assigns) do ~H\"\"\" &lt;동적으로 구현할 컴포넌트 태그&gt; &lt;&gt;..사용자 구현...&lt;&gt; &lt;%= render_slot(@블록명) %&gt; &lt;/동적으로 구현할 컴포넌트 태그&gt; \"\"\"end Slot 정의slot :블록명 : 컴포넌트 내부에 동적으로 콘텐츠를 삽입할 수 있는 블록명이라는 이름의 슬롯을 정의.required: true: 이 슬롯이 반드시 제공되어야 함을 의미. 이 컴포넌트를 사용할 때는 블록명 슬롯에 대한 내용을 제공해야 한다.컴포넌트 정의def 컴포넌트명(assigns) do ... end : 컴포넌트를 정의하는 함수. 이 함수 내에서 HTML 태그와 Elixir의 템플릿 언어를 사용하여 컴포넌트의 구조를 정의한다.동적 콘텐츠의 삽입 위치&lt;%= render_slot(@블록명) %&gt; : 구문은 정의된 블록명 슬롯에 전달된 콘텐츠를 해당 위치에 렌더링.이 위치는 \"동적으로 구현할 컴포넌트 태그\" 내부로 이 태그 안에서 블록명 슬롯에 제공된 콘텐츠가 렌더링됨.사용자 구현사용자는 이 컴포넌트를 사용할 때 블록명 슬롯에 원하는 콘텐츠를 제공할 수 있다. 이 콘텐츠는 다양한 HTML 요소, 다른 LiveView 컴포넌트, 또는 동적인 데이터를 포함할 수 있다.실제 코드 예시attr :view_box, :stringslot :inner_block, required: truedef canvas(assigns) do ~H\"\"\" &lt;svg viewBox={ @view_box }&gt; &lt;defs&gt; &lt;%!-- 위에 정의된 point component 사용하여 정사각형 생성 --%&gt; &lt;rect id=\"point\" width=\"10\" height=\"10\" /&gt; &lt;/defs&gt; &lt;%= render_slot(@inner_block) %&gt; &lt;/svg&gt; \"\"\"end"
    } ,
  
    {
      "title"       : "Elixir - intance 생성",
      "category"    : "",
      "tags"        : "elixir, instance, struct",
      "url"         : "./create-instance.html",
      "date"        : "2023-12-29 13:32:20 +0900",
      "description" : "Elixir - intance 생성",
      "content"     : "Elixir 문범에서 struct 에 대한 instace를 생성하는 방법은 아래와 같이 두가지가 존재한다. (ChatGPT 가 설명한 그 용도의 차이점에 대해서.. 아직 잘 모르겠다. 내눈에는 그냥 동일한 용도로 사용되는 것 처럼 보인다. ;;)__MODULE__ 사용사용법: %__MODULE__{} 구문은 주로 모듈 내부에서 해당 모듈의 구조체 인스턴스를 생성할 때 사용. 이 경우, 모듈 내부에서 직접 %__MODULE__{field1: value1, field2: value2}와 같이 구조체 인스턴스를 생성할 수 있다.예시: 모듈 내부에서 def new() 함수를 정의하고, 이 함수 안에서 %__MODULE__{}를 사용하여 인스턴스를 생성할 수 있다.def new(field \\\\ []), do: __struct__(field) 정의사용법: 이 방법은 모듈 외부에서 인스턴스를 생성할 때 사용합니다. 여기서 new 함수는 외부에서 호출할 수 있는 공개 인터페이스를 제공하고, __struct__ 호출을 통해 내부적으로 구조체 인스턴스를 생성한다.예시: 다른 모듈에서 ModuleName.new(field_values)를 호출하여 구조체 인스턴스를 생성할 수 있다. 여기서 field_values는 인스턴스의 필드를 초기화하기 위해 사용됨.결론두 방식 모두 Elixir에서 구조체 인스턴스를 생성하는 방법. __MODULE__ 방식은 주로 모듈 내부에서 사용되며, def new(field \\\\ []), do: __struct__(field) 방식은 모듈 외부에서 구조체 인스턴스를 생성할 때 사용되는 공개 함수를 제공한다. 두 경우 모두, 모듈명.new(field 값)과 같은 형태로 호출하여 인스턴스를 생성할 수 있다."
    } ,
  
    {
      "title"       : "struct - instance 에 대해 (Elixir vs OOP languages)",
      "category"    : "",
      "tags"        : "oop, instance, struct, phoenix, liveview, elixir",
      "url"         : "./instance-with-elixir.html",
      "date"        : "2023-12-29 10:32:20 +0900",
      "description" : "struct - instance 에 대해 (Elixir vs OOP languages)",
      "content"     : "elixir 에서의 구조체는 상속, 다형성 등이 지원되지 않고 한번 정의되면 구조체 내부 field 값을 변경할 수 없는, 내부에 field 가 존재하는 사용자 정의 type 이며, 해당 구조체 type 에 실제 data 를 가지게 하고 이를 변수 매칭 시킨것이 elixir instance 이다. 유사점데이터 캡슐화: Elixir의 구조체와 Java나 Python의 인스턴스 모두 데이터를 캡슐화. 여러 데이터를 하나의 구조로 묶어 관리할 수 있다.필드 정의: 두 언어에서는 자료구조에 필드(데이터 요소)를 정의할 수 있으며, 이러한 필드는 각각의 자료구조에 속한 정보를 나타냄.타입 안정성: Elixir의 구조체와 Java의 객체는 둘 다 특정 타입에 속하는 데이터를 담는데, 이는 데이터 타입에 대한 안정성과 예측 가능성을 제공.차이점불변성(Immutability) vs 가변성(Mutability): Elixir의 구조체는 불변성을 가짐. 한 번 생성되면 그 상태를 변경할 수 없음. 반면, Java나 Python의 객체는 가변적이며, 객체의 상태(필드 값 등)를 변경할 수 있음.함수형 vs 객체지향: Elixir는 함수형 프로그래밍 패러다임을 따르기 때문에, 데이터와 함수가 분리되어 있음. 구조체는 단지 데이터를 담는 용도로 사용되며, 모든 작업은 순수 함수를 통해 처리됨. 반면, Java나 Python에서는 객체가 데이터와 그 데이터를 조작하는 메소드를 모두 포함.상속과 다형성: Java나 Python에서는 클래스 상속과 다형성이 중요한 특징으로 객체는 부모 클래스의 속성과 메소드를 상속받을 수 있으며, 인터페이스나 추상 클래스를 통해 다형성을 구현할 수 있음. 반면, Elixir의 구조체는 이런 상속 메커니즘이나 다형성을 지원하지 않음.메소드와 함수: Java나 Python에서 객체는 자신의 메소드를 가지고 있으며, 이를 통해 객체의 상태를 변경하거나 정보를 얻을 수 있음. Elixir에서는 모든 작업이 함수를 통해 이루어지며, 이 함수들은 구조체의 데이터에 대한 연산을 수행하지만, 구조체 내부에 정의되지 않음.결론Elixir의 구조체는 Java나 Python의 객체와 유사하게 데이터를 캡슐화하는 역할을 하지만, 불변성, 함수형 패러다임, 상속 및 다형성 부재, 메소드와 함수의 차이라는 측면에서 분명한 차이점이 있다. 이러한 차이점들은 Elixir가 가진 함수형 프로그래밍의 특징을 반영한다."
    } ,
  
    {
      "title"       : "tail recursion",
      "category"    : "",
      "tags"        : "tail recursion, elixir",
      "url"         : "./tail-recursion.html",
      "date"        : "2023-12-27 15:32:20 +0900",
      "description" : "tail recursion",
      "content"     : "일반 재귀 (Regular Recursion) 예제defmodule RegularRecursion do def sum([]), do: 0 def sum([head | tail]), do: head + sum(tail)end이 예제에서 `sum/1` 함수는 리스트의 첫 번째 요소를 취하고, 나머지 리스트에 대해 재귀적으로 `sum/1`을 호출한 다음, 결과에 첫 번째 요소를 더한다. 여기서 중요한 점은 재귀 호출 후에 추가 작업(더하기)이 수행된다는 것.꼬리 재귀 (Tail Recursion) 예제다음 예제에서 `sum/2` 보조 함수는 누적된 합계를 유지하면서 재귀적으로 호출된다. 각 재귀 호출은 누적된 합계에 현재 요소를 더한 값과 함께 호출되며, 이는 꼬리 호출 최적화를 가능하게 한다.defmodule TailRecursion do def sum(list), do: sum(list, 0) defp sum([], total), do: total defp sum([head | tail], total) do sum(tail, head + total) endend차이점일반 재귀에서는 각 재귀 호출 후에 추가적인 계산 필요(예: head + sum(tail)).꼬리 재귀에서는 재귀 호출이 함수의 마지막 연산이며, 추가 계산이 없음(예: sum(tail, head + total)).일반 재귀는 호출 스택에 각 호출의 컨텍스트를 저장해야 하므로 메모리 사용이 더 많고, 깊은 재귀에서 스택 오버플로우를 일으킬 수 있다. 반면, 꼬리 재귀는 최적화를 통해 이러한 문제를 피할 수 있으며, 깊은 재귀 호출에서도 효율적으로 작동한다.(Regular) Recursion vs Tail Recursion - 성능 &amp; stack 사용 비교 꼬리 재귀 (Tail Recursion)Elixir에서 꼬리 재귀는 꼬리 호출 최적화(Tail-Call Optimization, TCO)라는 기술을 통해 최적화된다. 꼬리 재귀 함수에서는 재귀 호출이 함수의 마지막 작업으로, Elixir 컴파일러가 현재의 스택 프레임을 재사용할 수 있게 한다. 이러한 최적화는 새로운 스택 프레임을 추가하는 대신 현재의 프레임을 재사용함으로써 메모리 사용량을 최소화한다. 대규모 작업이나 대량의 데이터 처리에 특히 메모리 효율이 좋으며, 스택 오버플로우 위험을 피할 수 있다.일반 재귀 (Regular Recursion)반면, Elixir에서 일반 재귀는 각 함수 호출마다 새로운 스택 프레임을 추가한다. 이는 특히 깊은 재귀 또는 큰 리스트를 다룰 때 메모리 사용량을 증가시킬 수 있으며, 각 재귀 호출이 자체 스택 프레임을 요구하기 때문에 성능 문제나 극단적인 경우 스택 오버플로우를 일으킬 수 있다.성능적 영향일반적으로 꼬리 재귀는 Elixir에서 더 빠르고 메모리 효율적이며, 특히 리스트 축소나 대규모 데이터 처리에 유리하다. 하지만 모든 경우에 꼬리 재귀가 우월한 것은 아니다. 특정 상황, 특히 함수가 리스트를 축소하지 않고 단순히 매핑하는 경우, 일반 재귀가 더 효율적일 수 있다. 예를 들어, 리스트의 숫자를 두 배로 하는 함수는 일반 재귀를 사용하는 것이 더 빠를 수 있다.다른 언어의 logic 처리 (iteration) 과 Tail Recursion 비교Elixir에서 꼬리 재귀를 사용하는 것이 다른 언어에서의 일반적인 반복문(iteration)을 사용하는 것과 유사한 수준의 성능과 메모리 사용을 제공할 수 있다. 꼬리 재귀의 주요 장점 중 하나는 꼬리 호출 최적화(tail-call optimization, TCO)로 인해 메모리 사용이 최소화된다는 것. 이 최적화는 재귀 호출 시 새로운 스택 프레임을 생성하는 대신 현재 스택 프레임을 재사용하게 해, 깊은 재귀 호출에서도 스택 오버플로우 위험을 줄여준다.꼬리 재귀와 반복문의 성능 비교메모리 사용량: 꼬리 재귀를 사용하는 Elixir 함수는 일반 반복문을 사용하는 다른 언어의 함수들과 유사하게, 낮은 메모리 사용량을 가질 수 있다. 각 재귀 호출이 새로운 스택 프레임을 추가하지 않기 때문에, 깊은 재귀 수준에서도 메모리 사용량이 제한적이다. 성능: 꼬리 재귀 최적화 덕분에 Elixir의 꼬리 재귀 함수는 일반 반복문을 사용하는 함수들과 비슷한 성능을 낼 수 있다. 반복문은 일반적으로 CPU 사이클을 덜 사용하고, 반복 로직이 명시적이기 때문에 일부 경우에서 더 효율적일 수 있다. 하지만 꼬리 재귀는 이러한 성능 차이를 상당 부분 줄일 수 있다."
    } ,
  
    {
      "title"       : "Phoenix Presence (by ChatGPT)",
      "category"    : "",
      "tags"        : "phoenix presence, phoenix, liveview",
      "url"         : "./phoenix-presence.html",
      "date"        : "2023-12-26 10:32:20 +0900",
      "description" : "Phoenix Presence (by ChatGPT)",
      "content"     : "Phoenix Presence는 Elixir 언어를 사용하는 Phoenix 프레임워크의 한 부분으로, 실시간으로 사용자의 연결 상태를 추적하고 관리하는 기능을 제공합니다. 이 기능은 주로 채팅 애플리케이션, 게임, 라이브 이벤트 등에서 유용하게 사용됩니다.Phoenix Presence의 핵심은 분산 시스템에서도 사용자의 현재 상태를 효과적으로 관리할 수 있다는 점입니다. 이를 위해, Phoenix는 CRDT(Conflict-Free Replicated Data Type)라는 데이터 타입을 사용하여 네트워크의 다양한 노드 간에 사용자 상태 정보를 동기화합니다. 이를 통해 서버 간의 일관성을 유지하면서도, 네트워크 분할이나 다른 이슈들이 발생해도 사용자의 상태를 정확하게 추적할 수 있습니다.Phoenix Presence를 사용하면 어떤 사용자가 온라인인지, 어느 채널에 있는지 등의 정보를 실시간으로 확인할 수 있습니다. 또한, 이 기능은 Elixir의 가벼운 프로세스와 메시지 전달 시스템을 활용하여 높은 성능을 제공합니다. 따라서 많은 수의 사용자가 동시에 접속하는 환경에서도 안정적으로 작동합니다.Phoenix Presence를 활용하면 다음과 같은 기능을 구현할 수 있습니다사용자가 어떤 채널에 접속했는지 실시간으로 보여주기.사용자의 상태 변화(예: 온라인, 오프라인, 바쁨 등)를 추적하여 다른 사용자에게 알려주기.게임이나 다른 실시간 애플리케이션에서 사용자간의 상호 작용을 촉진하기.이 기능을 활용하려면, Phoenix 프레임워크에 대한 이해뿐만 아니라, Elixir의 동시성과 분산 시스템에 대한 지식도 필요합니다. 이미 Elixir를 공부하고 계신다면, Phoenix Presence는 백엔드 엔지니어로서의 여러분의 역량을 한층 더 향상시킬 수 있는 좋은 도구가 될 것입니다.CRDT(Conflict-Free Replicated Data Type) (by ChatGPT)CRDT(Conflict-Free Replicated Data Type)는 분산 시스템에서 데이터의 일관성을 유지하는 데 사용되는 데이터 타입입니다. 이 기술의 주요 목표는 네트워크의 다른 노드에서 동일한 데이터를 독립적으로 업데이트하고, 나중에 이러한 변경 사항들을 합쳐도 데이터의 일관성을 보장하는 것입니다.CRDT의 특징:Conflict-Free: CRDT는 다수의 노드에서 동시에 발생하는 업데이트 사이의 충돌을 자동으로 해결합니다. 이는 각 노드가 네트워크의 다른 부분과 일시적으로 연결이 끊겨도 안정적으로 작동할 수 있게 해줍니다.Replicated: 데이터는 네트워크 내의 여러 노드에 복제됩니다. 이는 각 노드가 로컬 데이터에 대해 독립적으로 작업할 수 있게 하며, 네트워크 연결이 복구되면 변경 사항을 다시 합칩니다.Data Types: CRDT는 다양한 데이터 타입을 지원합니다, 예를 들어 세트(set), 카운터(counter), 맵(map) 등이 있으며, 이러한 데이터 타입들은 분산 시스템에서 자동으로 동기화됩니다.실시간 트래픽 관리에 대한 CRDT의 기여:고가용성 및 내결함성: CRDT는 네트워크 장애나 일부 노드의 실패에도 불구하고 데이터의 가용성과 일관성을 유지합니다. 이는 실시간 트래픽이 많은 애플리케이션에서 중요합니다.실시간 데이터 동기화: 실시간 애플리케이션에서 사용자 상태나 메시지와 같은 정보는 여러 노드에 걸쳐 신속하게 동기화되어야 합니다. CRDT는 이러한 실시간 동기화를 자연스럽게 지원합니다.탄력적인 트래픽 관리: 분산 시스템에서 트래픽 부하가 한 노드에서 다른 노드로 이동할 수 있습니다. CRDT를 사용하면, 이러한 부하 이동이 데이터 일관성에 영향을 미치지 않습니다.확장성: CRDT는 시스템이 확장됨에 따라 새로운 노드를 쉽게 추가할 수 있게 해주며, 데이터의 일관성을 유지하면서도 시스템의 확장성을 지원합니다.CRDT는 Phoenix Presence와 같은 실시간 애플리케이션에서 사용자의 상태를 관리하는 데 매우 유용합니다. 사용자가 여러 노드에 걸쳐 있거나, 네트워크 상태가 변동적일 때도, 사용자의 상태(예: 온라인, 오프라인)는 모든 노드에 걸쳐 일관성 있게 유지됩니다.* CRDT 학습 자료 : CRDT Resources - crdt.tech."
    } ,
  
    {
      "title"       : "복합 쿼리를 데이터베이스에 실행할 때 발생하는 과정",
      "category"    : "",
      "tags"        : "complex query, database, phoenix, liveview",
      "url"         : "./complex-query.html",
      "date"        : "2023-12-24 13:32:20 +0900",
      "description" : "복합 쿼리의 logic 실행은 client 측에서 진행되는가, 아니면 database server 측에서 진행되는가?",
      "content"     : "복합 쿼리의 logic 실행은 client 측에서 진행되는가, 아니면 database server 측에서 진행되는가?복합 쿼리를 데이터베이스에 실행할 때 발생하는 과정은 다음과 같다.쿼리의 구성: 클라이언트 측(여기서는 Elixir/Ecto를 사용하는 서버)에서 Ecto 쿼리를 작성하고, 이는 SQL 쿼리로 변환된다. 이 변환 과정은 Ecto가 처리하며, 작성된 Ecto 쿼리를 데이터베이스가 이해할 수 있는 SQL 쿼리로 변환한다.SQL 쿼리의 전송: 변환된 SQL 쿼리는 데이터베이스 서버로 전송. 이 때, 클라이언트 측에서는 복잡한 로직을 처리하지 않고, 데이터베이스에 대한 쿼리 요청만 전송한다.데이터베이스의 처리: 데이터베이스 서버에서는 받은 SQL 쿼리를 실행. 데이터베이스 관리 시스템(DBMS)은 쿼리를 분석하고 최적화하여 적절한 방식으로 데이터를 검색한다.결과의 반환: 데이터베이스는 쿼리 결과를 클라이언트 측으로 다시 보냄. 이 결과는 요청된 조건과 매칭되는 데이터를 포함한다.복합 쿼리의 처리클라이언트 측 로직: 클라이언트는 쿼리를 구성하고 최적화하는 로직을 처리하지 않는다. 클라이언트의 역할은 적절한 쿼리를 작성하고 요청하는 것.데이터베이스 측 최적화: 실제 쿼리의 실행과 최적화는 데이터베이스 서버에서 처리됨. 데이터베이스는 쿼리 플랜을 생성하고 실행하여, 요청된 작업을 최적화된 방식으로 처리한다.요약따라서, 복합 쿼리의 로직 처리와 최적화는 주로 데이터베이스 서버에서 이루어지며, 클라이언트 측에서는 쿼리를 작성하고 요청하는 역할을 한다. 이 과정은 데이터베이스 시스템의 성능과 효율성을 보장하기 위해 필요하다.대용량 서비스에 구현에서의 Database 병목 발생과 복합 쿼리의 관계대용량 데이터베이스 서버 환경에서는 데이터베이스 서버의 처리 능력에 한계가 있으며, 이는 종종 시스템의 병목 지점이 될 수 있다. 복잡한 쿼리 로직의 처리가 데이터베이스 서버에서 이루어지는 것은 사실이지만, 이는 서비스 운영 측면에서 효율성에 영향을 미칠 수 있다. 이에 대해 몇 가지 중요한 점을 고려해볼 필요가 있다데이터베이스 서버의 병목 현상대용량 처리: 대규모 데이터와 복잡한 쿼리는 데이터베이스 서버에 상당한 부하를 주고, 성능 저하의 원인이 될 수 있다.자원 관리: 데이터베이스 서버는 한정된 자원(메모리, CPU)을 사용하기 때문에, 효율적인 쿼리 최적화와 자원 관리가 필수적.대용량 서비스에 구현에서의 Database 병목 발생과 복합 쿼리의 관계쿼리 최적화: 클라이언트 측에서 쿼리를 가능한 한 효율적으로 작성하는 것이 중요. 불필요한 데이터 로드를 피하고, 필요한 데이터만 정확히 요청하는 것이 중요하다.로드 분산: 데이터베이스에 가해지는 부하를 줄이기 위해 캐싱, 읽기 전용 복제본 사용, 데이터 분할 등의 전략을 사용할 수 있다.서비스 운영 측면에서의 고려사항스케일링: 데이터베이스 서버의 성능을 향상시키기 위해 하드웨어 스케일업(더 강력한 서버 사용), 스케일아웃(여러 서버로 작업 분산).쿼리 성능 분석: 정기적인 쿼리 성능 분석과 최적화를 통해 데이터베이스 서버의 부하를 관리.비즈니스 로직과 데이터베이스 로직의 분리: 가능하면 복잡한 비즈니스 로직을 애플리케이션 레벨에서 처리하고, 데이터베이스는 데이터 저장과 간단한 조회에 집중하게 하는 것이 바람직할 수 있다.결론데이터베이스 서버에서의 복잡한 쿼리 처리는 효율성을 저해할 수 있으며, 이를 관리하기 위해서는 쿼리 최적화, 적절한 인프라 선택, 그리고 애플리케이션 설계의 최적화가 필요. 이러한 전략들은 서비스의 규모와 요구사항에 따라 달라질 수 있다."
    } ,
  
    {
      "title"       : "Open-Closed Principle (OCP)",
      "category"    : "",
      "tags"        : "elixir, polymorphism, open-closed principle, overloading, behaviour",
      "url"         : "./open-closed-principal.html",
      "date"        : "2023-12-21 10:32:20 +0900",
      "description" : "Open-Closed Principle (OCP)",
      "content"     : "Elixir에서 오픈-클로즈드 원칙(Open-Closed Principle, OCP)은 소프트웨어 엔지니어링의 SOLID 원칙 중 하나로, 클래스, 모듈, 함수 등이 확장에는 열려 있으나, 수정에는 닫혀 있어야 한다는 개념. 이 원칙의 목적은 기존의 코드를 변경하지 않으면서도 시스템의 기능을 확장할 수 있게 하는 것이다.Elixir는 함수형 언어이며, 모듈과 함수를 사용하여 이 원칙을 적용할 수 있다. Elixir에서 OCP를 적용하는 몇 가지 방법은 다음과 같다:1. 다형성(Polymorphism)을 사용하는 방법Elixir에서는 프로토콜(Protocol)을 사용하여 다형성을 구현할 수 있다. 프로토콜은 서로 다른 데이터 타입에 대해 동일한 인터페이스를 제공하며, 새로운 타입을 추가할 때 기존 코드를 변경하지 않고도 기능을 확장할 수 있다.아래 예제와 같이 `great/1` 의 경우, 모두 동일한 parameter 갯수를 갖지만 각각 type 이 다르므로 각각 함수 요청을 구분하여, 해당 함수가 실행되도록 한다.defmodule PolymorphismExample do # 인자가 맵이고 키 :name을 가진 경우 def greet(%{name: name}), do: \"Hello, #{name}!\" # 인자가 문자열일 경우 def greet(name) when is_binary(name), do: \"Hello, #{name}!\" # 위의 경우에 모두 해당하지 않을 때 def greet(_), do: \"Hello, there!\" end2. 함수 오버로딩함수 오버로딩을 통해 같은 이름의 함수에 대해 다양한 패턴을 정의할 수 있다. 이를 통해 새로운 경우를 처리하기 위해 기존 함수를 수정하는 대신 새로운 함수 정의를 추가할 수 있다.다음의 경우, parameter 갯수가 다름에 따라 각 함수는 구분되어진다.defmodule OverloadingExample do def sum(a, b), do: a + b # 두 개의 인자를 받는 함수 def sum(list) when is_list(list), do: Enum.sum(list) # 리스트를 인자로 받는 함수end3. 행위(Behaviour)를 정의하는 방법Elixir에서는 행위(behaviour)를 정의하여 모듈이 특정 콜백을 구현하도록 할 수 있다. **(아직 이해가 부족하므로 추가 학습 필요)** 이를 통해 동일한 인터페이스를 가진 다양한 구현을 제공할 수 있으며, 새로운 구현을 추가해도 기존 모듈을 수정할 필요가 없다.****** Behaviour 에 대하여Elixir 는 함수형 언어이므로 JAVA, 나 Python 과 같은 객체에 대한 개념이 존재 하지 않으므로, 상속 또한 존재하지 않는다. 그러나 약간 유사하게 동일한 함수 signiture 를 정의하여, 이를 필요한 상황에 맞춰 callback 함수를 구현할 수 있는 기능이 있으며, 이것이 곧 behaviour 이다. (OOP 에서 부모 객체 'animal' 에서 울음소리에 대한 함수를 구현하고, 자식 객체 'cat', 'dog' 에서 각각 함수를 상속 받아 내용을 다르게 구현하는 것과 유사한 기능을 사용할 수 있음.)아래의 예제를 보면, defmodule Worker do @callback work(data :: any) :: String.t()enddefmodule FileWorker do @behaviour Worker def work(data) do \"Processing file: #{data}\" endenddefmodule DatabaseWorker do @behaviour Worker def work(data) do \"Processing database entry: #{data}\" endend `Worker` module 에서 `work/1` callback 함수를 정의한다. 이 때, 함수명, parameter &amp; return type 에 대해서만 정의한다.그리고 함수의 내용은 다른 module 에서 해당 함수를 필요할 때, `@behaviour Worker` 로 callback 을 정의 하고, 함수를 구현하여 사용하므로, 각 module 에서 필요한 logic 을 맞추어 사용할 수 있다. [공식 문서 behaviour 설명] *****4. 컨피규레이션을 통한 확장(추후학습 예정)시스템을 구성하는 요소들을 컨피규레이션을 통해 정의하고, 새로운 구성 요소를 추가하여 기능을 확장할 수 있다.(아직 이해가 부족하므로 추가 학습 필요) 이 방법은 기존 시스템의 코드를 변경하지 않고도 새로운 기능을 추가할 수 있게 한다.결론오픈-클로즈드 원칙을 적용하면, 시스템의 유지보수성과 확장성이 향상되며, 기존 코드의 안정성을 유지하면서 새로운 기능을 추가할 수 있다."
    } ,
  
    {
      "title"       : "LiveView preload/1 에 대해",
      "category"    : "",
      "tags"        : "preload/1, phoenix, liveview",
      "url"         : "./preload.html",
      "date"        : "2023-12-20 13:32:20 +0900",
      "description" : "LiveView - preload/1",
      "content"     : "Consider the preload/1 Callback (by ChatGPT)live_component/1이 처음 호출될 때, LiveView는 일반적으로 mount/1, update/2, 그리고 render/1 콜백을 순서대로 호출합니다. 하지만 이 콜백들만으로는 충분하지 않은 상황이 발생할 수 있습니다. 특히, 성능 문제, 예를 들어 N + 1 문제를 방지하기 위해 preload/1이라는 추가 콜백이 필요할 수 있습니다.N + 1 문제란? 이는 데이터베이스 쿼리와 관련된 성능 문제로, 한 번의 큰 쿼리 대신 작은 쿼리가 여러 번 발생하여 전체적인 성능이 저하되는 현상을 말합니다.preload/1 콜백은 mount/1이나 render/1 전에 호출됩니다. 이렇게 함으로써 필요한 데이터를 사전에 로드하고, 성능 저하를 방지할 수 있습니다.마운트/렌더 워크플로우의 경우, LiveView는 preload/1을 호출한 다음, mount/1, update/2, 그리고 마지막으로 render/1을 호출합니다.변경 관리 워크플로우에서는 mount/1은 생략되지만, preload/1, update/2, 그리고 render/1의 순서는 유지됩니다.preload/1 콜백의 작동 방식과 N + 1 문제와의 관계Phoenix LiveView에서 preload/1 콜백은 컴포넌트의 라이프사이클에서 중요한 역할을 합니다. 이 콜백은 컴포넌트가 마운트되기 전에 필요한 데이터를 미리 로드하는데 사용됩니다. 예를 들어, 여러 컴포넌트에 필요한 데이터를 한 번의 배치로 미리 로드하여, 각각의 컴포넌트가 마운트될 때 필요한 데이터를 제공할 수 있습니다. 이 과정은 preload(list_of_assigns) -&gt; mount(socket) -&gt; update(assigns, socket) -&gt; render(assigns)의 순서로 진행됩니다​​.preload/1 콜백의 주요 목적은 N + 1 문제를 해결하는 것입니다. 이 문제는 여러 데이터 레코드에 대한 의존성 있는 쿼리를 반복적으로 실행하여 발생하는 성능 저하 문제를 말합니다. preload/1를 사용함으로써 필요한 모든 데이터를 한 번에 로드할 수 있으며, 이는 데이터베이스에 대한 불필요한 접근을 줄이고 전체적인 성능을 향상시킵니다.Phoenix LiveView 문서에서는 preload/1과 관련된 구체적인 콜백 목록이나 사용 방법에 대해 자세히 설명하지 않지만, preload/1 콜백의 사용이 컴포넌트 라이프사이클에서 중요한 역할을 하고, 성능 최적화에 기여한다는 점은 분명합니다​​.이 정보를 바탕으로, preload/1 콜백이 데이터 처리를 mount/1 또는 update/2와 분리하여 실행함으로써 성능 최적화에 기여한다는 것을 이해할 수 있습니다. mount/1 이전에는 초기 로딩에 필요한 모든 데이터를 로드하고, update/2 이전에는 변경된 데이터에 대해서만 로드하는 방식으로 성능을 최적화합니다."
    } ,
  
    {
      "title"       : "기본적인 LiveView Authentication 적용",
      "category"    : "",
      "tags"        : "authentication, phoenix, liveview",
      "url"         : "./authentication.html",
      "date"        : "2023-12-18 13:32:20 +0900",
      "description" : "LiveView 라이브러리가 제공하는 Authentication 을 적용",
      "content"     : "Authentication Generator 사용을 위한 phx.gen 추가&gt; mix phx.gen이 중 auth 관련 generator 사용&gt; mix phx.gen.auth Accounts User uersAuthentication Generator 사용을 위한 phx.gen 추가&gt; mix phx.gen이 중 auth 관련 generator 사용&gt; mix phx.gen.auth Accounts User uers1. Context ('Accounts') Context는 Phoenix에서 도메인 특정 로직을 캡슐화하는 모듈. 이는 데이터베이스와의 상호작용을 관리하고, 애플리케이션의 나머지 부분에 서비스 API를 제공한다. \"Accounts\"는 이 예제에서 생성될 context의 이름으로 이 context는 인증과 관련된 모든 함수와 로직을 포함하게 된다.2. Schema ('User') Schema는 데이터베이스 테이블의 구조를 설명하는 Elixir 모듈. 이는 테이블의 각 열에 해당하는 필드와 그 타입을 정의한다. \"User\"는 사용자 데이터를 나타내는 schema의 이름으로 이 schema는 사용자 데이터를 저장하고 쿼리하는 데 사용된다.3. Plural name of the schema ('users') 이것은 데이터베이스 내에서 사용될 테이블의 이름. Phoenix는 일반적으로 schema 이름의 복수형을 테이블 이름으로 사용한다. \"users\"는 \"User\" schema에 대응하는 데이터베이스 테이블의 이름.&gt; mix deps.getRun Migration&gt; mix ecto.migrate해당 설정 이후 기존 `live \"/guess\", WrongLive` 를 :require_authenticated_user plug 를 실행하는 scope 로 옮겨서 추가해준다.따라서 해당 경로 접속은 Authentication 이 필요하며, 해당 인증은 LiveView 에서 재공하는 login / signup page 를 사용하여 회원 등록을 손쉽게 적용할 수 있게 된다."
    } 
  
]
